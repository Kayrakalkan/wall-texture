{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/domManagement.ts", "../../../dev/core/src/Misc/deepCopier.ts", "../../../dev/core/src/Misc/precisionDate.ts", "../../../dev/core/src/Misc/webRequest.ts", "../../../dev/core/src/Misc/filesInputStore.ts", "../../../dev/core/src/Misc/retryStrategy.ts", "../../../dev/core/src/Misc/error.ts", "../../../dev/core/src/Misc/stringTools.ts", "../../../dev/core/src/Engines/WebGL/webGLPipelineContext.ts", "../../../dev/core/src/Misc/devTools.ts", "../../../dev/core/src/Engines/abstractEngine.functions.ts", "../../../dev/core/src/Engines/thinEngine.functions.ts", "../../../dev/core/src/Engines/Processors/shaderCodeNode.ts", "../../../dev/core/src/Engines/Processors/shaderCodeCursor.ts", "../../../dev/core/src/Engines/Processors/shaderCodeConditionNode.ts", "../../../dev/core/src/Engines/Processors/shaderCodeTestNode.ts", "../../../dev/core/src/Engines/Processors/Expressions/shaderDefineExpression.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.ts", "../../../dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.ts", "../../../dev/core/src/Engines/Processors/shaderProcessor.ts", "../../../dev/core/src/Materials/effect.functions.ts", "../../../dev/core/src/Materials/effect.ts", "../../../dev/core/src/States/depthCullingState.ts", "../../../dev/core/src/States/stencilStateComposer.ts", "../../../dev/core/src/States/stencilState.ts", "../../../dev/core/src/States/alphaCullingState.ts", "../../../dev/core/src/Materials/Textures/textureSampler.ts", "../../../dev/core/src/Materials/Textures/internalTexture.ts", "../../../dev/core/src/Engines/abstractEngine.ts", "../../../dev/core/src/Misc/timingTools.ts", "../../../dev/core/src/Misc/fileTools.ts", "../../../dev/core/src/Misc/guid.ts", "../../../dev/core/src/Misc/instantiationTools.ts", "../../../dev/core/src/Misc/tools.functions.ts", "../../../dev/core/src/Misc/tools.ts", "../../../dev/core/src/Misc/andOrNotEvaluator.ts", "../../../dev/core/src/Misc/tags.ts", "../../../dev/core/src/Misc/decorators.serialization.ts", "../../../dev/core/src/Maths/math.size.ts", "../../../dev/core/src/Materials/Textures/thinTexture.ts", "../../../dev/core/src/Materials/drawWrapper.functions.ts", "../../../dev/core/src/Engines/WebGL/webGL2ShaderProcessors.ts", "../../../dev/core/src/Meshes/WebGL/webGLDataBuffer.ts", "../../../dev/core/src/Engines/WebGL/webGLHardwareTexture.ts", "../../../dev/core/src/Engines/WebGL/webGLShaderProcessors.ts", "../../../dev/core/src/Engines/thinEngine.ts", "../../../dev/core/src/Engines/Extensions/engine.readTexture.ts", "../../../dev/core/src/Materials/Textures/baseTexture.ts", "../../../dev/core/src/Maths/math.plane.ts", "../../../dev/core/src/Misc/copyTools.ts", "../../../dev/core/src/Compat/compatibilityOptions.ts", "../../../dev/core/src/Materials/Textures/texture.ts", "../../../dev/core/src/Misc/perfCounter.ts", "../../../dev/core/src/Engines/Extensions/engine.uniformBuffer.ts", "../../../dev/core/src/Materials/uniformBuffer.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * Checks if the window object exists\r\n * @returns true if the window object exists\r\n */\r\nexport function IsWindowObjectExist(): boolean {\r\n    return typeof window !== \"undefined\";\r\n}\r\n\r\n/**\r\n * Checks if the navigator object exists\r\n * @returns true if the navigator object exists\r\n */\r\nexport function IsNavigatorAvailable(): boolean {\r\n    return typeof navigator !== \"undefined\";\r\n}\r\n\r\n/**\r\n * Check if the document object exists\r\n * @returns true if the document object exists\r\n */\r\nexport function IsDocumentAvailable(): boolean {\r\n    return typeof document !== \"undefined\";\r\n}\r\n\r\n/**\r\n * Extracts text content from a DOM element hierarchy\r\n * @param element defines the root element\r\n * @returns a string\r\n */\r\nexport function GetDOMTextContent(element: HTMLElement): string {\r\n    let result = \"\";\r\n    let child = element.firstChild;\r\n\r\n    while (child) {\r\n        if (child.nodeType === 3) {\r\n            result += child.textContent;\r\n        }\r\n        child = <any>child.nextSibling;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Sets of helpers dealing with the DOM and some of the recurrent functions needed in\r\n * Babylon.js\r\n */\r\nexport const DomManagement = {\r\n    /**\r\n     * Checks if the window object exists\r\n     * @returns true if the window object exists\r\n     */\r\n    IsWindowObjectExist,\r\n\r\n    /**\r\n     * Checks if the navigator object exists\r\n     * @returns true if the navigator object exists\r\n     */\r\n    IsNavigatorAvailable,\r\n\r\n    /**\r\n     * Check if the document object exists\r\n     * @returns true if the document object exists\r\n     */\r\n    IsDocumentAvailable,\r\n    /**\r\n     * Extracts text content from a DOM element hierarchy\r\n     * @param element defines the root element\r\n     * @returns a string\r\n     */\r\n    GetDOMTextContent,\r\n};\r\n", "import { Logger } from \"./logger\";\r\n\r\nconst CloneValue = (source: any, destinationObject: any, shallowCopyValues: boolean) => {\r\n    if (!source) {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && source.getClassName() === \"Mesh\") {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && (source.getClassName() === \"SubMesh\" || source.getClassName() === \"PhysicsBody\")) {\r\n        return source.clone(destinationObject);\r\n    } else if (source.clone) {\r\n        return source.clone();\r\n    } else if (Array.isArray(source)) {\r\n        return source.slice();\r\n    } else if (shallowCopyValues && typeof source === \"object\") {\r\n        return { ...source };\r\n    }\r\n    return null;\r\n};\r\n\r\nfunction GetAllPropertyNames(obj: any): string[] {\r\n    const props: string[] = [];\r\n\r\n    do {\r\n        Object.getOwnPropertyNames(obj).forEach(function (prop) {\r\n            if (props.indexOf(prop) === -1) {\r\n                props.push(prop);\r\n            }\r\n        });\r\n    } while ((obj = Object.getPrototypeOf(obj)));\r\n\r\n    return props;\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for deep copy.\r\n */\r\nexport class DeepCopier {\r\n    /**\r\n     * Tries to copy an object by duplicating every property\r\n     * @param source defines the source object\r\n     * @param destination defines the target object\r\n     * @param doNotCopyList defines a list of properties to avoid\r\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\r\n     * @param shallowCopyValues defines wether properties referencing objects (none cloneable) must be shallow copied (false by default)\r\n     * @remarks shallowCopyValues will not instantite the copied values which makes it only usable for \"JSON objects\"\r\n     */\r\n    public static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[], shallowCopyValues = false): void {\r\n        const properties = GetAllPropertyNames(source);\r\n        for (const prop of properties) {\r\n            if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\r\n                continue;\r\n            }\r\n\r\n            if (prop.endsWith(\"Observable\")) {\r\n                continue;\r\n            }\r\n\r\n            if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\r\n                continue;\r\n            }\r\n\r\n            const sourceValue = source[prop];\r\n            const typeOfSourceValue = typeof sourceValue;\r\n\r\n            if (typeOfSourceValue === \"function\") {\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                if (typeOfSourceValue === \"object\") {\r\n                    if (sourceValue instanceof Uint8Array) {\r\n                        destination[prop] = Uint8Array.from(sourceValue);\r\n                    } else if (sourceValue instanceof Array) {\r\n                        destination[prop] = [];\r\n\r\n                        if (sourceValue.length > 0) {\r\n                            if (typeof sourceValue[0] == \"object\") {\r\n                                for (let index = 0; index < sourceValue.length; index++) {\r\n                                    const clonedValue = CloneValue(sourceValue[index], destination, shallowCopyValues);\r\n\r\n                                    if (destination[prop].indexOf(clonedValue) === -1) {\r\n                                        // Test if auto inject was not done\r\n                                        destination[prop].push(clonedValue);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                destination[prop] = sourceValue.slice(0);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        destination[prop] = CloneValue(sourceValue, destination, shallowCopyValues);\r\n                    }\r\n                } else {\r\n                    destination[prop] = sourceValue;\r\n                }\r\n            } catch (e) {\r\n                // Log a warning (it could be because of a read-only property)\r\n                Logger.Warn(e.message);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { IsWindowObjectExist } from \"./domManagement\";\r\n\r\n/**\r\n * Class containing a set of static utilities functions for precision date\r\n */\r\nexport class PrecisionDate {\r\n    /**\r\n     * Gets either window.performance.now() if supported or Date.now() else\r\n     */\r\n    public static get Now(): number {\r\n        if (IsWindowObjectExist() && window.performance && window.performance.now) {\r\n            return window.performance.now();\r\n        }\r\n\r\n        return Date.now();\r\n    }\r\n}\r\n", "import type { IWebRequest } from \"./interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { INative } from \"../Engines/Native/nativeInterfaces\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare const _native: INative;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction createXMLHttpRequest(): XMLHttpRequest {\r\n    // If running in Babylon Native, then defer to the native XMLHttpRequest, which has the same public contract\r\n    if (typeof _native !== \"undefined\" && _native.XMLHttpRequest) {\r\n        return new _native.XMLHttpRequest();\r\n    } else {\r\n        return new XMLHttpRequest();\r\n    }\r\n}\r\n\r\n/**\r\n * Extended version of XMLHttpRequest with support for customizations (headers, ...)\r\n */\r\nexport class WebRequest implements IWebRequest {\r\n    private readonly _xhr = createXMLHttpRequest();\r\n\r\n    /**\r\n     * Custom HTTP Request Headers to be sent with XMLHttpRequests\r\n     * i.e. when loading files, where the server/service expects an Authorization header\r\n     */\r\n    public static CustomRequestHeaders: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Add callback functions in this array to update all the requests before they get sent to the network\r\n     */\r\n    public static CustomRequestModifiers = new Array<(request: XMLHttpRequest, url: string) => void>();\r\n\r\n    /**\r\n     * If set to true, requests to Babylon.js CDN requests will not be modified\r\n     */\r\n    public static SkipRequestModificationForBabylonCDN = true;\r\n\r\n    /**\r\n     * This function can be called to check if there are request modifiers for network requests\r\n     * @returns true if there are any custom requests available\r\n     */\r\n    public static get IsCustomRequestAvailable(): boolean {\r\n        return Object.keys(WebRequest.CustomRequestHeaders).length > 0 || WebRequest.CustomRequestModifiers.length > 0;\r\n    }\r\n\r\n    private _requestURL: string = \"\";\r\n\r\n    private _injectCustomRequestHeaders(): void {\r\n        if (this._shouldSkipRequestModifications(this._requestURL)) {\r\n            return;\r\n        }\r\n        for (const key in WebRequest.CustomRequestHeaders) {\r\n            const val = WebRequest.CustomRequestHeaders[key];\r\n            if (val) {\r\n                this._xhr.setRequestHeader(key, val);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _shouldSkipRequestModifications(url: string): boolean {\r\n        return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes(\"preview.babylonjs.com\") || url.includes(\"cdn.babylonjs.com\"));\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a function to be called when loading progress changes\r\n     */\r\n    public get onprogress(): ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null {\r\n        return this._xhr.onprogress;\r\n    }\r\n\r\n    public set onprogress(value: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null) {\r\n        this._xhr.onprogress = value;\r\n    }\r\n\r\n    /**\r\n     * Returns client's state\r\n     */\r\n    public get readyState(): number {\r\n        return this._xhr.readyState;\r\n    }\r\n\r\n    /**\r\n     * Returns client's status\r\n     */\r\n    public get status(): number {\r\n        return this._xhr.status;\r\n    }\r\n\r\n    /**\r\n     * Returns client's status as a text\r\n     */\r\n    public get statusText(): string {\r\n        return this._xhr.statusText;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response\r\n     */\r\n    public get response(): any {\r\n        return this._xhr.response;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response url\r\n     */\r\n    public get responseURL(): string {\r\n        return this._xhr.responseURL;\r\n    }\r\n\r\n    /**\r\n     * Returns client's response as text\r\n     */\r\n    public get responseText(): string {\r\n        return this._xhr.responseText;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the expected response type\r\n     */\r\n    public get responseType(): XMLHttpRequestResponseType {\r\n        return this._xhr.responseType;\r\n    }\r\n\r\n    public set responseType(value: XMLHttpRequestResponseType) {\r\n        this._xhr.responseType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the timeout value in milliseconds\r\n     */\r\n    public get timeout(): number {\r\n        return this._xhr.timeout;\r\n    }\r\n\r\n    public set timeout(value: number) {\r\n        this._xhr.timeout = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public addEventListener<K extends keyof XMLHttpRequestEventMap>(\r\n        type: K,\r\n        listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any,\r\n        options?: boolean | AddEventListenerOptions\r\n    ): void;\r\n    public addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\r\n        this._xhr.addEventListener(type, listener, options);\r\n    }\r\n\r\n    /** @internal */\r\n    public removeEventListener<K extends keyof XMLHttpRequestEventMap>(\r\n        type: K,\r\n        listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any,\r\n        options?: boolean | EventListenerOptions\r\n    ): void;\r\n    public removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void {\r\n        this._xhr.removeEventListener(type, listener, options);\r\n    }\r\n\r\n    /**\r\n     * Cancels any network activity\r\n     */\r\n    public abort() {\r\n        this._xhr.abort();\r\n    }\r\n\r\n    /**\r\n     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD\r\n     * @param body defines an optional request body\r\n     */\r\n    public send(body?: Document | XMLHttpRequestBodyInit | null): void {\r\n        if (WebRequest.CustomRequestHeaders) {\r\n            this._injectCustomRequestHeaders();\r\n        }\r\n\r\n        this._xhr.send(body);\r\n    }\r\n\r\n    /**\r\n     * Sets the request method, request URL\r\n     * @param method defines the method to use (GET, POST, etc..)\r\n     * @param url defines the url to connect with\r\n     */\r\n    public open(method: string, url: string): void {\r\n        for (const update of WebRequest.CustomRequestModifiers) {\r\n            if (this._shouldSkipRequestModifications(url)) {\r\n                return;\r\n            }\r\n            update(this._xhr, url);\r\n        }\r\n\r\n        // Clean url\r\n        url = url.replace(\"file:http:\", \"http:\");\r\n        url = url.replace(\"file:https:\", \"https:\");\r\n\r\n        this._requestURL = url;\r\n\r\n        this._xhr.open(method, url, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the value of a request header.\r\n     * @param name The name of the header whose value is to be set\r\n     * @param value The value to set as the body of the header\r\n     */\r\n    setRequestHeader(name: string, value: string): void {\r\n        this._xhr.setRequestHeader(name, value);\r\n    }\r\n\r\n    /**\r\n     * Get the string containing the text of a particular header's value.\r\n     * @param name The name of the header\r\n     * @returns The string containing the text of the given header name\r\n     */\r\n    getResponseHeader(name: string): Nullable<string> {\r\n        return this._xhr.getResponseHeader(name);\r\n    }\r\n}\r\n", "/**\r\n * Class used to help managing file picking and drag'n'drop\r\n * File Storage\r\n */\r\nexport class FilesInputStore {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static FilesToLoad: { [key: string]: File } = {};\r\n}\r\n", "import type { WebRequest } from \"./webRequest\";\r\n\r\n/**\r\n * Class used to define a retry strategy when error happens while loading assets\r\n */\r\nexport class RetryStrategy {\r\n    /**\r\n     * Function used to defines an exponential back off strategy\r\n     * @param maxRetries defines the maximum number of retries (3 by default)\r\n     * @param baseInterval defines the interval between retries\r\n     * @returns the strategy function to use\r\n     */\r\n    public static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {\r\n        return (url: string, request: WebRequest, retryIndex: number): number => {\r\n            if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf(\"file:\") !== -1) {\r\n                return -1;\r\n            }\r\n\r\n            return Math.pow(2, retryIndex) * baseInterval;\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * Base error. Due to limitations of typedoc-check and missing documentation\r\n * in lib.es5.d.ts, cannot extend Error directly for RuntimeError.\r\n * @ignore\r\n */\r\nexport abstract class BaseError extends Error {\r\n    // See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript\r\n    // and https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n\r\n    // Polyfill for Object.setPrototypeOf if necessary.\r\n    protected static _setPrototypeOf: (o: any, proto: object | null) => any =\r\n        (Object as any).setPrototypeOf ||\r\n        ((o, proto) => {\r\n            o.__proto__ = proto;\r\n            return o;\r\n        });\r\n}\r\n\r\n/* IMP! DO NOT CHANGE THE NUMBERING OF EXISTING ERROR CODES */\r\n/**\r\n * Error codes for BaseError\r\n */\r\nexport const ErrorCodes = {\r\n    // Mesh errors 0-999\r\n    /** Invalid or empty mesh vertex positions. */\r\n    MeshInvalidPositionsError: 0,\r\n\r\n    // Texture errors 1000-1999\r\n    /** Unsupported texture found. */\r\n    UnsupportedTextureError: 1000,\r\n\r\n    // GLTFLoader errors 2000-2999\r\n    /** Unexpected magic number found in GLTF file header. */\r\n    GLTFLoaderUnexpectedMagicError: 2000,\r\n\r\n    // SceneLoader errors 3000-3999\r\n    /** SceneLoader generic error code. Ideally wraps the inner exception. */\r\n    SceneLoaderError: 3000,\r\n\r\n    // File related errors 4000-4999\r\n    /** Load file error */\r\n    LoadFileError: 4000,\r\n    /** Request file error */\r\n    RequestFileError: 4001,\r\n    /** Read file error */\r\n    ReadFileError: 4002,\r\n} as const;\r\n\r\n/**\r\n * Error code type\r\n */\r\nexport type ErrorCodesType = (typeof ErrorCodes)[keyof typeof ErrorCodes];\r\n\r\n/**\r\n * Application runtime error\r\n */\r\nexport class RuntimeError extends BaseError {\r\n    /**\r\n     * The error code\r\n     */\r\n    public errorCode: ErrorCodesType;\r\n\r\n    /**\r\n     * The error that caused this outer error\r\n     */\r\n    public innerError?: Error;\r\n\r\n    /**\r\n     * Creates a new RuntimeError\r\n     * @param message defines the message of the error\r\n     * @param errorCode the error code\r\n     * @param innerError the error that caused the outer error\r\n     */\r\n    public constructor(message: string, errorCode: ErrorCodesType, innerError?: Error) {\r\n        super(message);\r\n\r\n        this.errorCode = errorCode;\r\n        this.innerError = innerError;\r\n\r\n        this.name = \"RuntimeError\";\r\n        BaseError._setPrototypeOf(this, RuntimeError.prototype);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\n/**\r\n * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n * @param str Source string\r\n * @param suffix Suffix to search for in the source string\r\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n * @deprecated Please use native string function instead\r\n */\r\nexport const EndsWith = (str: string, suffix: string): boolean => {\r\n    return str.endsWith(suffix);\r\n};\r\n\r\n/**\r\n * Checks for a matching suffix at the beginning of a string (for ES5 and lower)\r\n * @param str Source string\r\n * @param suffix Suffix to search for in the source string\r\n * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n * @deprecated Please use native string function instead\r\n */\r\nexport const StartsWith = (str: string, suffix: string): boolean => {\r\n    if (!str) {\r\n        return false;\r\n    }\r\n    return str.startsWith(suffix);\r\n};\r\n\r\n/**\r\n * Decodes a buffer into a string\r\n * @param buffer The buffer to decode\r\n * @returns The decoded string\r\n */\r\nexport const Decode = (buffer: Uint8Array | Uint16Array): string => {\r\n    if (typeof TextDecoder !== \"undefined\") {\r\n        return new TextDecoder().decode(buffer);\r\n    }\r\n\r\n    let result = \"\";\r\n    for (let i = 0; i < buffer.byteLength; i++) {\r\n        result += String.fromCharCode(buffer[i]);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Encode a buffer to a base64 string\r\n * @param buffer defines the buffer to encode\r\n * @returns the encoded string\r\n */\r\nexport const EncodeArrayBufferToBase64 = (buffer: ArrayBuffer | ArrayBufferView): string => {\r\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n    let output = \"\";\r\n    let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n    let i = 0;\r\n    const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);\r\n\r\n    while (i < bytes.length) {\r\n        chr1 = bytes[i++];\r\n        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;\r\n        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;\r\n\r\n        enc1 = chr1 >> 2;\r\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n        enc4 = chr3 & 63;\r\n\r\n        if (isNaN(chr2)) {\r\n            enc3 = enc4 = 64;\r\n        } else if (isNaN(chr3)) {\r\n            enc4 = 64;\r\n        }\r\n        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\n/**\r\n * Converts a given base64 string as an ASCII encoded stream of data\r\n * @param base64Data The base64 encoded string to decode\r\n * @returns Decoded ASCII string\r\n */\r\nexport const DecodeBase64ToString = (base64Data: string): string => {\r\n    return atob(base64Data);\r\n};\r\n\r\n/**\r\n * Converts a given base64 string into an ArrayBuffer of raw byte data\r\n * @param base64Data The base64 encoded string to decode\r\n * @returns ArrayBuffer of byte data\r\n */\r\nexport const DecodeBase64ToBinary = (base64Data: string): ArrayBuffer => {\r\n    const decodedString = DecodeBase64ToString(base64Data);\r\n    const bufferLength = decodedString.length;\r\n    const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));\r\n\r\n    for (let i = 0; i < bufferLength; i++) {\r\n        bufferView[i] = decodedString.charCodeAt(i);\r\n    }\r\n\r\n    return bufferView.buffer;\r\n};\r\n\r\n/**\r\n * Converts a number to string and pads with preceding zeroes until it is of specified length.\r\n * @param num the number to convert and pad\r\n * @param length the expected length of the string\r\n * @returns the padded string\r\n */\r\nexport const PadNumber = (num: number, length: number): string => {\r\n    let str = String(num);\r\n    while (str.length < length) {\r\n        str = \"0\" + str;\r\n    }\r\n    return str;\r\n};\r\n/**\r\n * Helper to manipulate strings\r\n */\r\nexport const StringTools = {\r\n    EndsWith,\r\n    StartsWith,\r\n    Decode,\r\n    EncodeArrayBufferToBase64,\r\n    DecodeBase64ToString,\r\n    DecodeBase64ToBinary,\r\n    PadNumber,\r\n};\r\n", "import type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport class WebGLPipelineContext implements IPipelineContext {\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> };\r\n\r\n    public engine: ThinEngine;\r\n    public program: Nullable<WebGLProgram>;\r\n    public context?: WebGLRenderingContext;\r\n    public vertexShader?: WebGLShader;\r\n    public fragmentShader?: WebGLShader;\r\n    public isParallelCompiled: boolean;\r\n    public onCompiled?: () => void;\r\n    public transformFeedback?: WebGLTransformFeedback | null;\r\n\r\n    public vertexCompilationError: Nullable<string> = null;\r\n    public fragmentCompilationError: Nullable<string> = null;\r\n    public programLinkError: Nullable<string> = null;\r\n    public programValidationError: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n\r\n    public get isAsync() {\r\n        return this.isParallelCompiled;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.program) {\r\n            if (this.isParallelCompiled) {\r\n                return this.engine._isRenderingStateCompiled(this);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(onCompiled: (program: WebGLProgram) => void): void {\r\n        if (onCompiled && this.program) {\r\n            onCompiled(this.program);\r\n        }\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as ThinEngine;\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n        if (engine.supportsUniformBuffers) {\r\n            for (const name in uniformBuffersNames) {\r\n                effect.bindUniformBlock(name, uniformBuffersNames[name]);\r\n            }\r\n        }\r\n\r\n        const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);\r\n        effectAvailableUniforms.forEach((uniform, index) => {\r\n            uniforms[uniformsNames[index]] = uniform;\r\n        });\r\n        this._uniforms = uniforms;\r\n\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const sampler = effect.getUniform(samplerList[index]);\r\n            if (sampler == null) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n\r\n        samplerList.forEach((name, index) => {\r\n            samplers[name] = index;\r\n        });\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        this._uniforms = {};\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        const cache = this._valueCache[uniformName];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 2) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 3) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 4) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setUInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setUInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setUInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!matrices) {\r\n            return;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrices(this._uniforms[uniformName], matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.asArray())) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setFloat(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;\r\n    }\r\n}\r\n", "const warnedMap: { [key: string]: boolean } = {};\r\n/**\r\n * @internal\r\n */\r\nexport function _WarnImport(name: string, warnOnce = false) {\r\n    if (warnOnce && warnedMap[name]) {\r\n        return;\r\n    }\r\n    warnedMap[name] = true;\r\n    return `${name} needs to be imported before as it contains a side-effect required by your code.`;\r\n}\r\n", "import { _WarnImport } from \"core/Misc/devTools\";\r\nimport { IsDocumentAvailable } from \"core/Misc/domManagement\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport type { IWebRequest } from \"core/Misc/interfaces/iWebRequest\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IOfflineProvider } from \"core/Offline/IOfflineProvider\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nexport const EngineFunctionContext: {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ) => IFileRequest;\r\n} = {};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _ConcatenateShader(source: string, defines: Nullable<string>, shaderVersion: string = \"\"): string {\r\n    return shaderVersion + (defines ? defines + \"\\n\" : \"\") + source;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _loadFile(\r\n    url: string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n    onProgress?: (data: any) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: IWebRequest, exception?: any) => void,\r\n    injectedLoadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined\r\n    ) => IFileRequest\r\n): IFileRequest {\r\n    const loadFile = injectedLoadFile || EngineFunctionContext.loadFile;\r\n    if (loadFile) {\r\n        const request = loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        return request;\r\n    }\r\n    throw _WarnImport(\"FileTools\");\r\n}\r\n\r\n/**\r\n * Gets host document\r\n * @param renderingCanvas if provided, the canvas' owner document will be returned\r\n * @returns the host document object\r\n */\r\nexport function getHostDocument(renderingCanvas: Nullable<HTMLCanvasElement> = null): Nullable<Document> {\r\n    if (renderingCanvas && renderingCanvas.ownerDocument) {\r\n        return renderingCanvas.ownerDocument;\r\n    }\r\n\r\n    return IsDocumentAvailable() ? document : null;\r\n}\r\n\r\n/** @internal */\r\nexport function _getGlobalDefines(\r\n    defines?: { [key: string]: string },\r\n    isNDCHalfZRange?: boolean,\r\n    useReverseDepthBuffer?: boolean,\r\n    useExactSrgbConversions?: boolean\r\n): string | undefined {\r\n    if (defines) {\r\n        if (isNDCHalfZRange) {\r\n            defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n        } else {\r\n            delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n        }\r\n        return;\r\n    } else {\r\n        let s = \"\";\r\n        if (isNDCHalfZRange) {\r\n            s += \"#define IS_NDC_HALF_ZRANGE\";\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n        }\r\n        return s;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGLPipelineContext } from \"./WebGL/webGLPipelineContext\";\r\nimport type { _loadFile } from \"./abstractEngine.functions\";\r\nimport { _ConcatenateShader } from \"./abstractEngine.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IThinEngineStateObject {\r\n    _contextWasLost?: boolean;\r\n    validateShaderPrograms?: boolean;\r\n    _webGLVersion: number;\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    _context?: WebGLContext;\r\n    _createShaderProgramInjection?: typeof _createShaderProgram;\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram;\r\n    createShaderProgramInjection?: typeof createShaderProgram;\r\n    loadFileInjection?: typeof _loadFile;\r\n    cachedPipelines: { [name: string]: IPipelineContext };\r\n}\r\n/**\r\n * @internal\r\n */\r\nconst _stateObject: WeakMap<WebGLContext, IThinEngineStateObject> = new WeakMap();\r\n\r\n/**\r\n * This will be used in cases where the engine doesn't have a context (like the nullengine)\r\n */\r\nconst singleStateObject: IThinEngineStateObject = {\r\n    _webGLVersion: 2,\r\n    cachedPipelines: {},\r\n};\r\n\r\n/**\r\n * get or create a state object for the given context\r\n * Note - Used in WebGL only at the moment.\r\n * @param context The context to get the state object from\r\n * @returns the state object\r\n * @internal\r\n */\r\nexport function getStateObject(context: WebGLContext): IThinEngineStateObject {\r\n    let state = _stateObject.get(context);\r\n    if (!state) {\r\n        if (!context) {\r\n            return singleStateObject;\r\n        }\r\n        state = {\r\n            // use feature detection. instanceof returns false. This only exists on WebGL2 context\r\n            _webGLVersion: (context as WebGL2RenderingContext).TEXTURE_BINDING_3D ? 2 : 1,\r\n            _context: context,\r\n            cachedPipelines: {},\r\n        };\r\n        _stateObject.set(context, state);\r\n    }\r\n    return state;\r\n}\r\n/**\r\n * Remove the state object that belongs to the specific context\r\n * @param context the context that is being\r\n */\r\nexport function deleteStateObject(context: WebGLContext): void {\r\n    _stateObject.delete(context);\r\n}\r\n\r\nexport type WebGLContext = WebGLRenderingContext | WebGL2RenderingContext;\r\n/**\r\n * Directly creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createRawShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n\r\n    const vertexShader = _compileRawShader(vertexCode, \"vertex\", context, stateObject._contextWasLost);\r\n    const fragmentShader = _compileRawShader(fragmentCode, \"fragment\", context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode  defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param defines defines the string containing the defines to use to compile the shaders\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    defines: Nullable<string>,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]> = null,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n    const shaderVersion = stateObject._webGLVersion > 1 ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\";\r\n    const vertexShader = _compileShader(vertexCode, \"vertex\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n    const fragmentShader = _compileShader(fragmentCode, \"fragment\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a new pipeline context. Note, make sure to attach an engine instance to the created context\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param _shaderProcessingContext defines the shader processing context used during the processing if available\r\n * @returns the new pipeline\r\n */\r\nexport function createPipelineContext(context: WebGLContext, _shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n    const pipelineContext = new WebGLPipelineContext();\r\n    const stateObject = getStateObject(context);\r\n    if (stateObject.parallelShaderCompile) {\r\n        pipelineContext.isParallelCompiled = true;\r\n    }\r\n    pipelineContext.context = stateObject._context;\r\n    return pipelineContext;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _createShaderProgram(\r\n    pipelineContext: WebGLPipelineContext,\r\n    vertexShader: WebGLShader,\r\n    fragmentShader: WebGLShader,\r\n    context: WebGLContext,\r\n    _transformFeedbackVaryings: Nullable<string[]> = null,\r\n    validateShaderPrograms?: boolean\r\n): WebGLProgram {\r\n    const shaderProgram = context.createProgram();\r\n    pipelineContext.program = shaderProgram;\r\n\r\n    if (!shaderProgram) {\r\n        throw new Error(\"Unable to create program\");\r\n    }\r\n\r\n    context.attachShader(shaderProgram, vertexShader);\r\n    context.attachShader(shaderProgram, fragmentShader);\r\n\r\n    context.linkProgram(shaderProgram);\r\n\r\n    pipelineContext.context = context;\r\n    pipelineContext.vertexShader = vertexShader;\r\n    pipelineContext.fragmentShader = fragmentShader;\r\n\r\n    if (!pipelineContext.isParallelCompiled) {\r\n        _finalizePipelineContext(pipelineContext, context, validateShaderPrograms);\r\n    }\r\n\r\n    return shaderProgram;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _finalizePipelineContext(pipelineContext: WebGLPipelineContext, gl: WebGLContext, validateShaderPrograms?: boolean) {\r\n    const context = pipelineContext.context!;\r\n    const vertexShader = pipelineContext.vertexShader!;\r\n    const fragmentShader = pipelineContext.fragmentShader!;\r\n    const program = pipelineContext.program!;\r\n\r\n    const linked = context.getProgramParameter(program, context.LINK_STATUS);\r\n    if (!linked) {\r\n        // Get more info\r\n        // Vertex\r\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(vertexShader);\r\n            if (log) {\r\n                pipelineContext.vertexCompilationError = log;\r\n                throw new Error(\"VERTEX SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        // Fragment\r\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(fragmentShader);\r\n            if (log) {\r\n                pipelineContext.fragmentCompilationError = log;\r\n                throw new Error(\"FRAGMENT SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        const error = context.getProgramInfoLog(program);\r\n        if (error) {\r\n            pipelineContext.programLinkError = error;\r\n            throw new Error(error);\r\n        }\r\n    }\r\n\r\n    if (/*this.*/ validateShaderPrograms) {\r\n        context.validateProgram(program);\r\n        const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);\r\n\r\n        if (!validated) {\r\n            const error = context.getProgramInfoLog(program);\r\n            if (error) {\r\n                pipelineContext.programValidationError = error;\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    context.deleteShader(vertexShader);\r\n    context.deleteShader(fragmentShader);\r\n\r\n    pipelineContext.vertexShader = undefined;\r\n    pipelineContext.fragmentShader = undefined;\r\n\r\n    if (pipelineContext.onCompiled) {\r\n        pipelineContext.onCompiled();\r\n        pipelineContext.onCompiled = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _preparePipelineContext(\r\n    pipelineContext: IPipelineContext,\r\n    vertexSourceCode: string,\r\n    fragmentSourceCode: string,\r\n    createAsRaw: boolean,\r\n    _rawVertexSourceCode: string,\r\n    _rawFragmentSourceCode: string,\r\n    rebuildRebind: any,\r\n    defines: Nullable<string>,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _key: string = \"\",\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram,\r\n    createShaderProgramInjection?: typeof createShaderProgram\r\n) {\r\n    const stateObject = getStateObject((pipelineContext as WebGLPipelineContext).context!);\r\n    if (!createRawShaderProgramInjection) {\r\n        createRawShaderProgramInjection = stateObject.createRawShaderProgramInjection ?? createRawShaderProgram;\r\n    }\r\n    if (!createShaderProgramInjection) {\r\n        createShaderProgramInjection = stateObject.createShaderProgramInjection ?? createShaderProgram;\r\n    }\r\n    const webGLRenderingState = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (createAsRaw) {\r\n        webGLRenderingState.program = createRawShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    } else {\r\n        webGLRenderingState.program = createShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            defines,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    }\r\n    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;\r\n}\r\n\r\nfunction _compileShader(source: string, type: string, defines: Nullable<string>, shaderVersion: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    return _compileRawShader(_ConcatenateShader(source, defines, shaderVersion), type, gl, _contextWasLost);\r\n}\r\n\r\nfunction _compileRawShader(source: string, type: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    const shader = gl.createShader(type === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\r\n\r\n    if (!shader) {\r\n        let error: GLenum = gl.NO_ERROR;\r\n        let tempError: GLenum = gl.NO_ERROR;\r\n        while ((tempError = gl.getError()) !== gl.NO_ERROR) {\r\n            error = tempError;\r\n        }\r\n\r\n        throw new Error(\r\n            `Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${_contextWasLost}`\r\n        );\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    return shader;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _setProgram(program: WebGLProgram, gl: WebGLContext): void {\r\n    gl.useProgram(program);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: (pipelineContext?: IPipelineContext) => void) {\r\n    const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (!webGLPipelineContext.isParallelCompiled) {\r\n        action(pipelineContext);\r\n        return;\r\n    }\r\n\r\n    const oldHandler = webGLPipelineContext.onCompiled;\r\n\r\n    webGLPipelineContext.onCompiled = () => {\r\n        oldHandler?.();\r\n        action(pipelineContext);\r\n    };\r\n}\r\n", "import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst defaultAttributeKeywordName = \"attribute\";\r\nconst defaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                          ? options.processor?.varyingVertexKeywordName\r\n                          : defaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (\r\n                    processor.varyingProcessor &&\r\n                    (processor.varyingCheck?.(this.line, options.isFragment) || (!processor.varyingCheck && this.line.startsWith(varyingKeyword)))\r\n                ) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "/** @internal */\r\nexport class ShaderCodeCursor {\r\n    private _lines: string[] = [];\r\n    lineIndex: number;\r\n\r\n    get currentLine(): string {\r\n        return this._lines[this.lineIndex];\r\n    }\r\n\r\n    get canRead(): boolean {\r\n        return this.lineIndex < this._lines.length - 1;\r\n    }\r\n\r\n    set lines(value: string[]) {\r\n        this._lines.length = 0;\r\n\r\n        for (const line of value) {\r\n            // Skip empty lines\r\n            if (!line || line === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // Prevent removing line break in macros.\r\n            if (line[0] === \"#\") {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Do not split single line comments\r\n            const trimmedLine = line.trim();\r\n\r\n            if (!trimmedLine) {\r\n                continue;\r\n            }\r\n\r\n            if (trimmedLine.startsWith(\"//\")) {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Work with semicolon in the line\r\n            const semicolonIndex = trimmedLine.indexOf(\";\");\r\n\r\n            if (semicolonIndex === -1) {\r\n                // No semicolon in the line\r\n                this._lines.push(trimmedLine);\r\n            } else if (semicolonIndex === trimmedLine.length - 1) {\r\n                // Single semicolon at the end of the line\r\n                // If trimmedLine == \";\", we must not push, to be backward compatible with the old code!\r\n                if (trimmedLine.length > 1) {\r\n                    this._lines.push(trimmedLine);\r\n                }\r\n            } else {\r\n                // Semicolon in the middle of the line\r\n                const split = line.split(\";\");\r\n\r\n                for (let index = 0; index < split.length; index++) {\r\n                    let subLine = split[index];\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    subLine = subLine.trim();\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    this._lines.push(subLine + (index !== split.length - 1 ? \";\" : \"\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeConditionNode extends ShaderCodeNode {\r\n    override process(preprocessors: { [key: string]: string }, options: ProcessingOptions) {\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const node = this.children[index];\r\n\r\n            if (node.isValid(preprocessors)) {\r\n                return node.process(preprocessors, options);\r\n            }\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeTestNode extends ShaderCodeNode {\r\n    public testExpression: ShaderDefineExpression;\r\n\r\n    public override isValid(preprocessors: { [key: string]: string }) {\r\n        return this.testExpression.isTrue(preprocessors);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\nexport class ShaderDefineExpression {\r\n    /**\r\n     * Cache items count limit for the InfixToPostfix cache.\r\n     * It uses to improve the performance of the shader compilation.\r\n     * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\r\n     */\r\n    static InfixToPostfixCacheLimitSize = 50000;\r\n\r\n    /**\r\n     * When the cache size is exceeded, a cache cleanup will be triggered\r\n     * and the cache will be reduced by the size specified\r\n     * in the InfixToPostfixCacheCleanupSize variable, removing entries\r\n     * that have not been accessed the longest.\r\n     */\r\n    static InfixToPostfixCacheCleanupSize = 25000;\r\n\r\n    protected static _InfixToPostfixCache: Map<\r\n        string,\r\n        {\r\n            accessTime: number;\r\n            result: string[];\r\n        }\r\n    > = new Map();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    private static _OperatorPriority: { [name: string]: number } = {\r\n        \")\": 0,\r\n        \"(\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n    };\r\n\r\n    private static _Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\r\n\r\n    public static postfixToInfix(postfix: string[]): string {\r\n        const stack: string[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\r\n                stack.push(c);\r\n            } else {\r\n                const v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n                stack.push(`(${v2}${c}${v1})`);\r\n            }\r\n        }\r\n\r\n        return stack[stack.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Converts an infix expression to a postfix expression.\r\n     *\r\n     * This method is used to transform infix expressions, which are more human-readable,\r\n     * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\r\n     * evaluated more efficiently by a computer. The conversion is based on the operator\r\n     * priority defined in _OperatorPriority.\r\n     *\r\n     * The function employs a stack-based algorithm for the conversion and caches the result\r\n     * to improve performance. The cache keeps track of each converted expression's access time\r\n     * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\r\n     * limit, the least recently accessed items in the cache are deleted.\r\n     *\r\n     * The cache mechanism is particularly helpful for shader compilation, where the same infix\r\n     * expressions might be encountered repeatedly, hence the caching can speed up the process.\r\n     *\r\n     * @param infix - The infix expression to be converted.\r\n     * @returns The postfix expression as an array of strings.\r\n     */\r\n    public static infixToPostfix(infix: string): string[] {\r\n        // Is infix already in cache\r\n        const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\r\n        if (cacheItem) {\r\n            cacheItem.accessTime = Date.now();\r\n            return cacheItem.result;\r\n        }\r\n\r\n        // Is infix contain any operator\r\n        if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\r\n            return [infix];\r\n        }\r\n\r\n        const result: string[] = [];\r\n\r\n        let stackIdx = -1;\r\n\r\n        const pushOperand = () => {\r\n            operand = operand.trim();\r\n            if (operand !== \"\") {\r\n                result.push(operand);\r\n                operand = \"\";\r\n            }\r\n        };\r\n\r\n        const push = (s: string) => {\r\n            if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\r\n                ShaderDefineExpression._Stack[++stackIdx] = s;\r\n            }\r\n        };\r\n\r\n        const peek = () => ShaderDefineExpression._Stack[stackIdx];\r\n\r\n        const pop = () => (stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--]);\r\n\r\n        let idx = 0,\r\n            operand = \"\";\r\n\r\n        while (idx < infix.length) {\r\n            const c = infix.charAt(idx),\r\n                token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\r\n\r\n            if (c === \"(\") {\r\n                operand = \"\";\r\n                push(c);\r\n            } else if (c === \")\") {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && peek() !== \"(\") {\r\n                    result.push(pop());\r\n                }\r\n                pop();\r\n            } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\r\n                    result.push(pop());\r\n                }\r\n                push(token);\r\n                idx++;\r\n            } else {\r\n                operand += c;\r\n            }\r\n            idx++;\r\n        }\r\n\r\n        pushOperand();\r\n\r\n        while (stackIdx !== -1) {\r\n            if (peek() === \"(\") {\r\n                pop();\r\n            } else {\r\n                result.push(pop());\r\n            }\r\n        }\r\n\r\n        // If the cache is at capacity, clear it before adding a new item\r\n        if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\r\n            ShaderDefineExpression.ClearCache();\r\n        }\r\n\r\n        // Add the new item to the cache, including the current time as the last access time\r\n        ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });\r\n\r\n        return result;\r\n    }\r\n\r\n    private static ClearCache(): void {\r\n        // Convert the cache to an array and sort by last access time\r\n        const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\r\n\r\n        // Remove the least recently accessed half of the cache\r\n        for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\r\n            ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\r\n        }\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineIsDefinedOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public not: boolean = false\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let condition = preprocessors[this.define] !== undefined;\r\n\r\n        if (this.not) {\r\n            condition = !condition;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineOrOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineAndOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineArithmeticOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public operand: string,\r\n        public testValue: string\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let value = preprocessors[this.define];\r\n\r\n        if (value === undefined) {\r\n            value = this.define;\r\n        }\r\n\r\n        let condition = false;\r\n        const left = parseInt(value);\r\n        const right = parseInt(this.testValue);\r\n\r\n        switch (this.operand) {\r\n            case \">\":\r\n                condition = left > right;\r\n                break;\r\n            case \"<\":\r\n                condition = left < right;\r\n                break;\r\n            case \"<=\":\r\n                condition = left <= right;\r\n                break;\r\n            case \">=\":\r\n                condition = left >= right;\r\n                break;\r\n            case \"==\":\r\n                condition = left === right;\r\n                break;\r\n            case \"!=\":\r\n                condition = left !== right;\r\n                break;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport type { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../../Misc/fileTools\";\r\nimport type { IOfflineProvider } from \"../../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"../../Misc/fileRequest\";\r\nimport { _getGlobalDefines } from \"../abstractEngine.functions\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\nconst regexShaderDecl = /__decl__/;\r\nconst regexLightX = /light\\{X\\}.(\\w*)/g;\r\nconst regexX = /\\{X\\}/g;\r\nconst reusableMatches: RegExpMatchArray[] = [];\r\n\r\nconst _MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n\r\nexport function Initialize(options: ProcessingOptions): void {\r\n    if (options.processor && options.processor.initializeShaders) {\r\n        options.processor.initializeShaders(options.processingContext);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine?: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    _ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = _ProcessShaderConversion(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function PreProcess(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    _ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = _ApplyPreProcessing(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function Finalize(vertexCode: string, fragmentCode: string, options: ProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n    if (!options.processor || !options.processor.finalizeShaders) {\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n}\r\n\r\nfunction _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n    if (options.processor?.noPrecision) {\r\n        return source;\r\n    }\r\n\r\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n    if (source.indexOf(\"precision highp float\") === -1) {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            source = \"precision mediump float;\\n\" + source;\r\n        } else {\r\n            source = \"precision highp float;\\n\" + source;\r\n        }\r\n    } else {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            // Moving highp to mediump\r\n            source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n        }\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\nfunction _ExtractOperation(expression: string) {\r\n    const regex = /defined\\((.+)\\)/;\r\n\r\n    const match = regex.exec(expression);\r\n\r\n    if (match && match.length) {\r\n        return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n    }\r\n\r\n    const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\r\n    let operator = \"\";\r\n    let indexOperator = 0;\r\n\r\n    for (operator of operators) {\r\n        indexOperator = expression.indexOf(operator);\r\n\r\n        if (indexOperator > -1) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (indexOperator === -1) {\r\n        return new ShaderDefineIsDefinedOperator(expression);\r\n    }\r\n\r\n    const define = expression.substring(0, indexOperator).trim();\r\n    const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n    return new ShaderDefineArithmeticOperator(define, operator, value);\r\n}\r\n\r\nfunction _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n    expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n    const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n    for (const c of postfix) {\r\n        if (c !== \"||\" && c !== \"&&\") {\r\n            stack.push(c);\r\n        } else if (stack.length >= 2) {\r\n            let v1 = stack[stack.length - 1],\r\n                v2 = stack[stack.length - 2];\r\n\r\n            stack.length -= 2;\r\n\r\n            const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n            if (typeof v1 === \"string\") {\r\n                v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n            }\r\n\r\n            if (typeof v2 === \"string\") {\r\n                v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n            }\r\n\r\n            operator.leftOperand = typeof v2 === \"string\" ? _ExtractOperation(v2) : v2;\r\n            operator.rightOperand = typeof v1 === \"string\" ? _ExtractOperation(v1) : v1;\r\n\r\n            stack.push(operator);\r\n        }\r\n    }\r\n\r\n    let result = stack[stack.length - 1];\r\n\r\n    if (typeof result === \"string\") {\r\n        result = result.replace(regexSERevert, \"defined($1)\");\r\n    }\r\n\r\n    // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n    return typeof result === \"string\" ? _ExtractOperation(result) : result;\r\n}\r\n\r\nfunction _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n    const node = new ShaderCodeTestNode();\r\n    const command = line.substring(0, start);\r\n    let expression = line.substring(start);\r\n\r\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n    if (command === \"#ifdef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n    } else if (command === \"#ifndef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n    } else {\r\n        node.testExpression = _BuildSubExpression(expression);\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nfunction _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n    let line = cursor.currentLine;\r\n    while (_MoveCursor(cursor, ifNode)) {\r\n        line = cursor.currentLine;\r\n        const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n        if (first5 === \"#else\") {\r\n            const elseNode = new ShaderCodeNode();\r\n            rootNode.children.push(elseNode);\r\n            _MoveCursor(cursor, elseNode);\r\n            return;\r\n        } else if (first5 === \"#elif\") {\r\n            const elifNode = _BuildExpression(line, 5);\r\n\r\n            rootNode.children.push(elifNode);\r\n            ifNode = elifNode;\r\n        }\r\n    }\r\n}\r\n\r\nfunction _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n    while (cursor.canRead) {\r\n        cursor.lineIndex++;\r\n        const line = cursor.currentLine;\r\n\r\n        if (line.indexOf(\"#\") >= 0) {\r\n            const matches = _MoveCursorRegex.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                const keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = _BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = _BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        const ifNode = _BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        _MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        const newNode = new ShaderCodeNode();\r\n        newNode.line = line;\r\n        rootNode.children.push(newNode);\r\n\r\n        // Detect additional defines\r\n        if (line[0] === \"#\" && line[1] === \"d\") {\r\n            const split = line.replace(\";\", \"\").split(\" \");\r\n            newNode.additionalDefineKey = split[1];\r\n\r\n            if (split.length === 3) {\r\n                newNode.additionalDefineValue = split[2];\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n    const rootNode = new ShaderCodeNode();\r\n    const cursor = new ShaderCodeCursor();\r\n\r\n    cursor.lineIndex = -1;\r\n    cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n    _MoveCursor(cursor, rootNode);\r\n\r\n    // Recompose\r\n    return rootNode.process(preprocessors, options);\r\n}\r\n\r\nfunction _PreparePreProcessors(options: ProcessingOptions, engine?: AbstractEngine): { [key: string]: string } {\r\n    const defines = options.defines;\r\n    const preprocessors: { [key: string]: string } = {};\r\n\r\n    for (const define of defines) {\r\n        const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n        const split = keyValue.split(\" \");\r\n        preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n    }\r\n\r\n    if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n        preprocessors[\"GL_ES\"] = \"true\";\r\n    }\r\n    preprocessors[\"__VERSION__\"] = options.version;\r\n    preprocessors[options.platformName] = \"true\";\r\n\r\n    _getGlobalDefines(preprocessors, engine?.isNDCHalfZRange, engine?.useReverseDepthBuffer, engine?.useExactSrgbConversions);\r\n\r\n    return preprocessors;\r\n}\r\n\r\nfunction _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine?: AbstractEngine): string {\r\n    let preparedSourceCode = _ProcessPrecision(sourceCode, options);\r\n\r\n    if (!options.processor) {\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    // Already converted\r\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n        preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n        if (!options.processor.parseGLES3) {\r\n            return preparedSourceCode;\r\n        }\r\n    }\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = _PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    preparedSourceCode = _EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n    // Post processing\r\n    if (options.processor.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {}\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine?._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\nfunction _ApplyPreProcessing(sourceCode: string, options: ProcessingOptions, engine: AbstractEngine): string {\r\n    let preparedSourceCode = sourceCode;\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = _PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor?.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    preparedSourceCode = _EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n    // Post processing\r\n    if (options.processor?.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {}\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\n/** @internal */\r\nexport function _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n    reusableMatches.length = 0;\r\n    let match: RegExpMatchArray | null;\r\n    // stay back-compat to the old matchAll syntax\r\n    while ((match = regexShaderInclude.exec(sourceCode)) !== null) {\r\n        reusableMatches.push(match);\r\n    }\r\n\r\n    let returnValue = String(sourceCode);\r\n    let parts = [sourceCode];\r\n\r\n    let keepProcessing = false;\r\n\r\n    for (const match of reusableMatches) {\r\n        let includeFile = match[1];\r\n\r\n        // Uniform declaration\r\n        if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n            includeFile = includeFile.replace(regexShaderDecl, \"\");\r\n            if (options.supportsUniformBuffers) {\r\n                includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\r\n            }\r\n            includeFile = includeFile + \"Declaration\";\r\n        }\r\n\r\n        if (options.includesShadersStore[includeFile]) {\r\n            // Substitution\r\n            let includeContent = options.includesShadersStore[includeFile];\r\n            if (match[2]) {\r\n                const splits = match[3].split(\",\");\r\n\r\n                for (let index = 0; index < splits.length; index += 2) {\r\n                    const source = new RegExp(splits[index], \"g\");\r\n                    const dest = splits[index + 1];\r\n\r\n                    includeContent = includeContent.replace(source, dest);\r\n                }\r\n            }\r\n\r\n            if (match[4]) {\r\n                const indexString = match[5];\r\n\r\n                if (indexString.indexOf(\"..\") !== -1) {\r\n                    const indexSplits = indexString.split(\"..\");\r\n                    const minIndex = parseInt(indexSplits[0]);\r\n                    let maxIndex = parseInt(indexSplits[1]);\r\n                    let sourceIncludeContent = includeContent.slice(0);\r\n                    includeContent = \"\";\r\n\r\n                    if (isNaN(maxIndex)) {\r\n                        maxIndex = options.indexParameters[indexSplits[1]];\r\n                    }\r\n\r\n                    for (let i = minIndex; i < maxIndex; i++) {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent += sourceIncludeContent.replace(regexX, i.toString()) + \"\\n\";\r\n                    }\r\n                } else {\r\n                    if (!options.supportsUniformBuffers) {\r\n                        // Ubo replacement\r\n                        includeContent = includeContent.replace(regexLightX, (str: string, p1: string) => {\r\n                            return p1 + \"{X}\";\r\n                        });\r\n                    }\r\n                    includeContent = includeContent.replace(regexX, indexString);\r\n                }\r\n            }\r\n\r\n            // Replace\r\n            // Split all parts on match[0] and intersperse the parts with the include content\r\n            const newParts = [];\r\n            for (const part of parts) {\r\n                const splitPart = part.split(match[0]);\r\n                for (let i = 0; i < splitPart.length - 1; i++) {\r\n                    newParts.push(splitPart[i]);\r\n                    newParts.push(includeContent);\r\n                }\r\n                newParts.push(splitPart[splitPart.length - 1]);\r\n            }\r\n            parts = newParts;\r\n\r\n            keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n        } else {\r\n            const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n            _functionContainer.loadFile(includeShaderUrl, (fileContent) => {\r\n                options.includesShadersStore[includeFile] = fileContent as string;\r\n                _ProcessIncludes(parts.join(\"\"), options, callback);\r\n            });\r\n            return;\r\n        }\r\n    }\r\n    reusableMatches.length = 0;\r\n\r\n    returnValue = parts.join(\"\");\r\n\r\n    if (keepProcessing) {\r\n        _ProcessIncludes(returnValue.toString(), options, callback);\r\n    } else {\r\n        callback(returnValue);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport const _functionContainer = {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest => {\r\n        throw _WarnImport(\"FileTools\");\r\n    },\r\n};\r\n", "import type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"core/Misc/domManagement\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { WebGLContext } from \"core/Engines/thinEngine.functions\";\r\nimport { getStateObject } from \"core/Engines/thinEngine.functions\";\r\nimport { ShaderStore } from \"core/Engines/shaderStore\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Effect, IShaderPath } from \"./effect\";\r\nimport type { IPipelineContext } from \"core/Engines/IPipelineContext\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Finalize, Initialize, Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport { _loadFile } from \"core/Engines/abstractEngine.functions\";\r\nimport type { WebGLPipelineContext } from \"core/Engines/WebGL/webGLPipelineContext\";\r\n\r\n/**\r\n * Options to be used when creating a pipeline\r\n */\r\nexport interface IPipelineGenerationOptions {\r\n    /**\r\n     * The definition of the shader content.\r\n     * Can be either a unified name, name per vertex and frament or the shader code content itself\r\n     */\r\n    shaderNameOrContent: string | IShaderPath;\r\n    /**\r\n     * Unique key to identify the pipeline.\r\n     * Note that though not mandatory, it's recommended to provide a key to be able to use the automated pipeline loading system.\r\n     */\r\n    key?: string;\r\n    /**\r\n     * The list of defines to be used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * If true, the global defines will be added to the defines array\r\n     */\r\n    addGlobalDefines?: boolean;\r\n    /**\r\n     * The shader language.\r\n     * Defaults to the language suiting the platform name (GLSL for WEBGL2, WGSL for WEBGPU)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * The name of the platform to be used when processing the shader\r\n     * defaults to WEBGL2\r\n     */\r\n    platformName?: string /* \"WEBGL2\" | \"WEBGL1\" | \"WEBGPU\" */;\r\n\r\n    /**\r\n     * extend the processing options when running code processing\r\n     */\r\n    extendedProcessingOptions?: Partial<ProcessingOptions>;\r\n\r\n    /**\r\n     * extend the pipeline generation options\r\n     */\r\n    extendedCreatePipelineOptions?: Partial<ICreateAndPreparePipelineContextOptions>;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ICreateAndPreparePipelineContextOptions {\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    shaderProcessingContext: Nullable<ShaderProcessingContext>;\r\n    existingPipelineContext?: Nullable<IPipelineContext>;\r\n    name?: string;\r\n    rebuildRebind?: (vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) => void;\r\n    onRenderingStateCompiled?: (pipelineContext?: IPipelineContext) => void;\r\n    context?: WebGL2RenderingContext | WebGLRenderingContext;\r\n    // preparePipeline options\r\n    createAsRaw?: boolean;\r\n    vertex: string;\r\n    fragment: string;\r\n    defines: Nullable<string>;\r\n    transformFeedbackVaryings: Nullable<string[]>;\r\n}\r\n\r\n/**\r\n * Get a cached pipeline context\r\n * @param name the pipeline name\r\n * @param context the context to be used when creating the pipeline\r\n * @returns the cached pipeline context if it exists\r\n * @internal\r\n */\r\nexport function getCachedPipeline(name: string, context: WebGLContext): IPipelineContext | undefined {\r\n    const stateObject = getStateObject(context);\r\n    return stateObject.cachedPipelines[name];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function resetCachedPipeline(pipeline: IPipelineContext): void {\r\n    const name = pipeline._name;\r\n    const context = (pipeline as WebGLPipelineContext).context;\r\n    if (name && context) {\r\n        const stateObject = getStateObject(context!);\r\n        const cachedPipeline = stateObject.cachedPipelines[name];\r\n        cachedPipeline?.dispose();\r\n        delete stateObject.cachedPipelines[name];\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function _processShaderCode(\r\n    processorOptions: ProcessingOptions,\r\n    baseName: any,\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>,\r\n    onFinalCodeReady?: (vertexCode: string, fragmentCode: string) => void,\r\n    shaderLanguage?: ShaderLanguage,\r\n    engine?: AbstractEngine,\r\n    effectContext?: Effect\r\n) {\r\n    let vertexSource: string | HTMLElement | IShaderPath;\r\n    let fragmentSource: string | HTMLElement | IShaderPath;\r\n\r\n    // const baseName = this.name;\r\n    const hostDocument = IsWindowObjectExist() ? engine?.getHostDocument() : null;\r\n\r\n    if (typeof baseName === \"string\") {\r\n        vertexSource = baseName;\r\n    } else if (baseName.vertexSource) {\r\n        vertexSource = \"source:\" + baseName.vertexSource;\r\n    } else if (baseName.vertexElement) {\r\n        vertexSource = hostDocument?.getElementById(baseName.vertexElement) || baseName.vertexElement;\r\n    } else {\r\n        vertexSource = baseName.vertex || baseName;\r\n    }\r\n    if (typeof baseName === \"string\") {\r\n        fragmentSource = baseName;\r\n    } else if (baseName.fragmentSource) {\r\n        fragmentSource = \"source:\" + baseName.fragmentSource;\r\n    } else if (baseName.fragmentElement) {\r\n        fragmentSource = hostDocument?.getElementById(baseName.fragmentElement) || baseName.fragmentElement;\r\n    } else {\r\n        fragmentSource = baseName.fragment || baseName;\r\n    }\r\n\r\n    const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n    const shadersLoaded = () => {\r\n        if (shaderCodes[0] && shaderCodes[1]) {\r\n            processorOptions.isFragment = true;\r\n            const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n            Process(\r\n                fragmentCode,\r\n                processorOptions,\r\n                (migratedFragmentCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                    }\r\n                    const finalShaders = Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                    processorOptions = null as any;\r\n                    const finalCode = _useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, shaderLanguage);\r\n                    onFinalCodeReady?.(finalCode.vertexSourceCode, finalCode.fragmentSourceCode);\r\n                },\r\n                engine\r\n            );\r\n        }\r\n    };\r\n    _loadShader(\r\n        vertexSource,\r\n        \"Vertex\",\r\n        \"\",\r\n        (vertexCode) => {\r\n            Initialize(processorOptions);\r\n            Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._rawVertexSourceCode = vertexCode;\r\n                        effectContext._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                engine\r\n            );\r\n        },\r\n        shaderLanguage\r\n    );\r\n    _loadShader(\r\n        fragmentSource,\r\n        \"Fragment\",\r\n        \"Pixel\",\r\n        (fragmentCode) => {\r\n            if (effectContext) {\r\n                effectContext._rawFragmentSourceCode = fragmentCode;\r\n            }\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        },\r\n        shaderLanguage\r\n    );\r\n}\r\n\r\nfunction _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void, shaderLanguage?: ShaderLanguage, _loadFileInjection?: typeof _loadFile) {\r\n    if (typeof HTMLElement !== \"undefined\") {\r\n        // DOM element ?\r\n        if (shader instanceof HTMLElement) {\r\n            const shaderCode = GetDOMTextContent(shader);\r\n            callback(shaderCode);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Direct source ?\r\n    if (shader.substr(0, 7) === \"source:\") {\r\n        callback(shader.substr(7));\r\n        return;\r\n    }\r\n\r\n    // Base64 encoded ?\r\n    if (shader.substr(0, 7) === \"base64:\") {\r\n        const shaderBinary = window.atob(shader.substr(7));\r\n        callback(shaderBinary);\r\n        return;\r\n    }\r\n\r\n    const shaderStore = ShaderStore.GetShadersStore(shaderLanguage);\r\n\r\n    // Is in local store ?\r\n    if (shaderStore[shader + key + \"Shader\"]) {\r\n        callback(shaderStore[shader + key + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n        callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    let shaderUrl;\r\n\r\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n        shaderUrl = shader;\r\n    } else {\r\n        shaderUrl = ShaderStore.GetShadersRepository(shaderLanguage) + shader;\r\n    }\r\n    _loadFileInjection = _loadFileInjection || _loadFile;\r\n    if (!_loadFileInjection) {\r\n        // we got to this point and loadFile was not injected - throw an error\r\n        throw new Error(\"loadFileInjection is not defined\");\r\n    }\r\n    // Vertex shader\r\n    _loadFileInjection(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n}\r\n\r\nfunction _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, shaderLanguage?: ShaderLanguage) {\r\n    if (baseName) {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n        return {\r\n            vertexSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode,\r\n            fragmentSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode,\r\n        };\r\n    } else {\r\n        return {\r\n            vertexSourceCode: migratedVertexCode,\r\n            fragmentSourceCode: migratedFragmentCode,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates and prepares a pipeline context\r\n * @internal\r\n */\r\nexport const createAndPreparePipelineContext = (\r\n    options: ICreateAndPreparePipelineContextOptions,\r\n    createPipelineContext: typeof AbstractEngine.prototype.createPipelineContext,\r\n    _preparePipelineContext: typeof AbstractEngine.prototype._preparePipelineContext,\r\n    _executeWhenRenderingStateIsCompiled: typeof AbstractEngine.prototype._executeWhenRenderingStateIsCompiled\r\n) => {\r\n    try {\r\n        const pipelineContext: IPipelineContext = options.existingPipelineContext || createPipelineContext(options.shaderProcessingContext);\r\n        pipelineContext._name = options.name;\r\n        if (options.name && options.context) {\r\n            const stateObject = getStateObject(options.context);\r\n            stateObject.cachedPipelines[options.name] = pipelineContext;\r\n        }\r\n\r\n        _preparePipelineContext(\r\n            pipelineContext,\r\n            options.vertex,\r\n            options.fragment,\r\n            !!options.createAsRaw,\r\n            \"\",\r\n            \"\",\r\n            options.rebuildRebind,\r\n            options.defines,\r\n            options.transformFeedbackVaryings,\r\n            \"\"\r\n        );\r\n\r\n        _executeWhenRenderingStateIsCompiled(pipelineContext, () => {\r\n            options.onRenderingStateCompiled?.(pipelineContext);\r\n        });\r\n\r\n        return pipelineContext;\r\n    } catch (e) {\r\n        Logger.Error(\"Error compiling effect\");\r\n        throw e;\r\n    }\r\n};\r\n", "import { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IShaderProcessor } from \"../Engines/Processors/iShaderProcessor\";\r\nimport type { ProcessingOptions, ShaderCustomProcessingFunction, ShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../Maths/math.like\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { IPipelineGenerationOptions } from \"./effect.functions\";\r\nimport { _processShaderCode, getCachedPipeline, createAndPreparePipelineContext, resetCachedPipeline } from \"./effect.functions\";\r\n\r\n/**\r\n * Defines the route to the shader code. The priority is as follows:\r\n *  * object: `{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" }` for directly passing the shader code\r\n *  * object: `{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }`, used with shader code in script tags\r\n *  * object: `{ vertex: \"custom\", fragment: \"custom\" }`, used with `Effect.ShadersStore[\"customVertexShader\"]` and `Effect.ShadersStore[\"customFragmentShader\"]`\r\n *  * string: `\"./COMMON_NAME\"`, used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n */\r\nexport type IShaderPath = {\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    vertexSource?: string;\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    fragmentSource?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `vertex` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customVertexShader\"]\r\n     */\r\n    vertex?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `fragment` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customFragmentShader\"]\r\n     */\r\n    fragment?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    vertexElement?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    fragmentElement?: string;\r\n    /**\r\n     * Defines the name appearing in spector when framgent/vertex...source are being used\r\n     */\r\n    spectorName?: string;\r\n};\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * Provide an existing pipeline context to avoid creating a new one\r\n     */\r\n    existingPipelineContext?: IPipelineContext;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: IShaderPath | string;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @internal */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @internal */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @internal */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @internal */\r\n    public _samplerList: string[];\r\n    /** @internal */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @internal */\r\n    public _engine: AbstractEngine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    /** @internal */\r\n    public _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    /** @internal */\r\n    public _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @internal\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @internal\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @internal */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @internal */\r\n    public _vertexSourceCodeBeforeMigration: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCodeBeforeMigration: string = \"\";\r\n\r\n    /** @internal */\r\n    public _rawVertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<ShaderProcessingContext>;\r\n\r\n    private _processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n    private _processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n    /**\r\n     * Gets the shader language type used to write vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    constructor(\r\n        baseName: IShaderPath | string,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: AbstractEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n        const pipelineName = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\r\n        let cachedPipeline: IPipelineContext | undefined = undefined;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <AbstractEngine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            this._processFinalCode = options.processFinalCode ?? null;\r\n            this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n\r\n            cachedPipeline = options.existingPipelineContext;\r\n        } else {\r\n            this._engine = <AbstractEngine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        // Use the cache if we can. For now, WebGL2 only.\r\n        if (this._engine.shaderPlatformName === \"WEBGL2\") {\r\n            cachedPipeline = getCachedPipeline(pipelineName, (this._engine as any)._gl) ?? cachedPipeline;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n        if (!cachedPipeline) {\r\n            this._processShaderCode();\r\n        } else {\r\n            this._pipelineContext = cachedPipeline;\r\n            this._pipelineContext.setEngine(this._engine);\r\n            this._onRenderingStateCompiled(this._pipelineContext);\r\n            // rebuildRebind for spector\r\n            if ((this._pipelineContext as any).program) {\r\n                (this._pipelineContext as any).program.__SPECTOR_rebuildProgram = this._rebuildProgram.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _processShaderCode(\r\n        shaderProcessor: Nullable<IShaderProcessor> = null,\r\n        keepExistingPipelineContext = false,\r\n        shaderProcessingContext: Nullable<ShaderProcessingContext> = null\r\n    ) {\r\n        this._processingContext = shaderProcessingContext || this._engine._getShaderProcessingContext(this._shaderLanguage);\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: this._processCodeAfterIncludes,\r\n        };\r\n\r\n        _processShaderCode(\r\n            processorOptions,\r\n            this.name,\r\n            this._processFinalCode,\r\n            (migratedVertexCode, migratedFragmentCode) => {\r\n                this._vertexSourceCode = migratedVertexCode;\r\n                this._fragmentSourceCode = migratedFragmentCode;\r\n                this._prepareEffect(keepExistingPipelineContext);\r\n            },\r\n            this._shaderLanguage,\r\n            this._engine,\r\n            this\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get vertexSourceCodeBeforeMigration(): string {\r\n        return this._vertexSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get fragmentSourceCodeBeforeMigration(): string {\r\n        return this._fragmentSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been modified by any processing\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been modified by any processing\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    public getPipelineGenerationOptions(): IPipelineGenerationOptions {\r\n        return {\r\n            platformName: this._engine.shaderPlatformName,\r\n            shaderLanguage: this._shaderLanguage,\r\n            shaderNameOrContent: this.name,\r\n            key: this._key,\r\n            defines: this.defines.split(\"\\n\"),\r\n            addGlobalDefines: false,\r\n            extendedProcessingOptions: {\r\n                indexParameters: this._indexParameters,\r\n                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            },\r\n            extendedCreatePipelineOptions: {\r\n                transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                createAsRaw: !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @internal\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback?.(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    private _onRenderingStateCompiled(pipelineContext: IPipelineContext) {\r\n        this._pipelineContext = pipelineContext;\r\n        this._pipelineContext.setEngine(this._engine);\r\n        this._attributes = [];\r\n        this._pipelineContext!._fillEffectInformation(\r\n            this,\r\n            this._uniformBuffersNames,\r\n            this._uniformsNames,\r\n            this._uniforms,\r\n            this._samplerList,\r\n            this._samplers,\r\n            this._attributesNames,\r\n            this._attributes\r\n        );\r\n\r\n        // Caches attribute locations.\r\n        if (this._attributesNames) {\r\n            for (let i = 0; i < this._attributesNames.length; i++) {\r\n                const name = this._attributesNames[i];\r\n                this._attributeLocationByName[name] = this._attributes[i];\r\n            }\r\n        }\r\n\r\n        this._engine.bindSamplers(this);\r\n\r\n        this._compilationError = \"\";\r\n        this._isReady = true;\r\n        if (this.onCompiled) {\r\n            this.onCompiled(this);\r\n        }\r\n        this.onCompileObservable.notifyObservers(this);\r\n        this.onCompileObservable.clear();\r\n\r\n        // Unbind mesh reference in fallbacks\r\n        if (this._fallbacks) {\r\n            this._fallbacks.unBindMesh();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect(keepExistingPipelineContext = false) {\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const overrides = !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride);\r\n            const defines = overrides ? null : this.defines;\r\n            const vertex = overrides ? this._vertexSourceCodeOverride : this._vertexSourceCode;\r\n            const fragment = overrides ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\r\n            const engine = this._engine;\r\n            this._pipelineContext = createAndPreparePipelineContext(\r\n                {\r\n                    existingPipelineContext: keepExistingPipelineContext ? previousPipelineContext : null,\r\n                    vertex,\r\n                    fragment,\r\n                    context: engine.shaderPlatformName === \"WEBGL2\" ? (engine as any)._gl : undefined,\r\n                    rebuildRebind: (\r\n                        vertexSourceCode: string,\r\n                        fragmentSourceCode: string,\r\n                        onCompiled: (pipelineContext: IPipelineContext) => void,\r\n                        onError: (message: string) => void\r\n                    ) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError),\r\n                    defines,\r\n                    transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                    name: this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\"),\r\n                    createAsRaw: overrides,\r\n                    parallelShaderCompile: engine._caps.parallelShaderCompile,\r\n                    shaderProcessingContext: this._processingContext,\r\n                    onRenderingStateCompiled: (pipelineContext) => {\r\n                        if (previousPipelineContext && !keepExistingPipelineContext) {\r\n                            this._engine._deletePipelineContext(previousPipelineContext);\r\n                        }\r\n                        if (pipelineContext) {\r\n                            this._onRenderingStateCompiled(pipelineContext);\r\n                        }\r\n                    },\r\n                },\r\n                this._engine.createPipelineContext.bind(this._engine),\r\n                this._engine._preparePipelineContext.bind(this._engine),\r\n                this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)\r\n            );\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\r\n            \"Uniforms: \" +\r\n                this._uniformsNames.map(function (uniform) {\r\n                    return \" \" + uniform;\r\n                })\r\n        );\r\n        Logger.Error(\r\n            \"Attributes: \" +\r\n                attributesNames.map(function (attribute) {\r\n                    return \" \" + attribute;\r\n                })\r\n        );\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n\r\n        const notifyErrors = () => {\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        // In case a previous compilation was successful, we need to restore the previous pipeline context\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            notifyErrors();\r\n        }\r\n\r\n        // Lets try to compile fallbacks as long as we have some.\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                notifyErrors();\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n\r\n            // In case of error, without any prior successful compilation, let s notify observers\r\n            if (!previousPipelineContext) {\r\n                notifyErrors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setUInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setUInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setUInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setUInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): Effect {\r\n        this._pipelineContext!.setQuaternion(uniformName, quaternion);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            resetCachedPipeline(this._pipelineContext);\r\n        }\r\n        this._engine._releaseEffect(this);\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class DepthCullingState {\r\n    protected _isDepthTestDirty = false;\r\n    protected _isDepthMaskDirty = false;\r\n    protected _isDepthFuncDirty = false;\r\n    protected _isCullFaceDirty = false;\r\n    protected _isCullDirty = false;\r\n    protected _isZOffsetDirty = false;\r\n    protected _isFrontFaceDirty = false;\r\n\r\n    protected _depthTest: boolean;\r\n    protected _depthMask: boolean;\r\n    protected _depthFunc: Nullable<number>;\r\n    protected _cull: Nullable<boolean>;\r\n    protected _cullFace: Nullable<number>;\r\n    protected _zOffset: number;\r\n    protected _zOffsetUnits: number;\r\n    protected _frontFace: Nullable<number>;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     * @param reset\r\n     */\r\n    public constructor(reset = true) {\r\n        if (reset) {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    public get isDirty(): boolean {\r\n        return (\r\n            this._isDepthFuncDirty ||\r\n            this._isDepthTestDirty ||\r\n            this._isDepthMaskDirty ||\r\n            this._isCullFaceDirty ||\r\n            this._isCullDirty ||\r\n            this._isZOffsetDirty ||\r\n            this._isFrontFaceDirty\r\n        );\r\n    }\r\n\r\n    public get zOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    public set zOffset(value: number) {\r\n        if (this._zOffset === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffset = value;\r\n        this._isZOffsetDirty = true;\r\n    }\r\n\r\n    public get zOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    public set zOffsetUnits(value: number) {\r\n        if (this._zOffsetUnits === value) {\r\n            return;\r\n        }\r\n\r\n        this._zOffsetUnits = value;\r\n        this._isZOffsetDirty = true;\r\n    }\r\n\r\n    public get cullFace(): Nullable<number> {\r\n        return this._cullFace;\r\n    }\r\n\r\n    public set cullFace(value: Nullable<number>) {\r\n        if (this._cullFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._cullFace = value;\r\n        this._isCullFaceDirty = true;\r\n    }\r\n\r\n    public get cull(): Nullable<boolean> {\r\n        return this._cull;\r\n    }\r\n\r\n    public set cull(value: Nullable<boolean>) {\r\n        if (this._cull === value) {\r\n            return;\r\n        }\r\n\r\n        this._cull = value;\r\n        this._isCullDirty = true;\r\n    }\r\n\r\n    public get depthFunc(): Nullable<number> {\r\n        return this._depthFunc;\r\n    }\r\n\r\n    public set depthFunc(value: Nullable<number>) {\r\n        if (this._depthFunc === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthFunc = value;\r\n        this._isDepthFuncDirty = true;\r\n    }\r\n\r\n    public get depthMask(): boolean {\r\n        return this._depthMask;\r\n    }\r\n\r\n    public set depthMask(value: boolean) {\r\n        if (this._depthMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthMask = value;\r\n        this._isDepthMaskDirty = true;\r\n    }\r\n\r\n    public get depthTest(): boolean {\r\n        return this._depthTest;\r\n    }\r\n\r\n    public set depthTest(value: boolean) {\r\n        if (this._depthTest === value) {\r\n            return;\r\n        }\r\n\r\n        this._depthTest = value;\r\n        this._isDepthTestDirty = true;\r\n    }\r\n\r\n    public get frontFace(): Nullable<number> {\r\n        return this._frontFace;\r\n    }\r\n\r\n    public set frontFace(value: Nullable<number>) {\r\n        if (this._frontFace === value) {\r\n            return;\r\n        }\r\n\r\n        this._frontFace = value;\r\n        this._isFrontFaceDirty = true;\r\n    }\r\n\r\n    public reset() {\r\n        this._depthMask = true;\r\n        this._depthTest = true;\r\n        this._depthFunc = null;\r\n        this._cullFace = null;\r\n        this._cull = null;\r\n        this._zOffset = 0;\r\n        this._zOffsetUnits = 0;\r\n        this._frontFace = null;\r\n\r\n        this._isDepthTestDirty = true;\r\n        this._isDepthMaskDirty = true;\r\n        this._isDepthFuncDirty = false;\r\n        this._isCullFaceDirty = false;\r\n        this._isCullDirty = false;\r\n        this._isZOffsetDirty = true;\r\n        this._isFrontFaceDirty = false;\r\n    }\r\n\r\n    public apply(gl: WebGLRenderingContext) {\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Cull\r\n        if (this._isCullDirty) {\r\n            if (this.cull) {\r\n                gl.enable(gl.CULL_FACE);\r\n            } else {\r\n                gl.disable(gl.CULL_FACE);\r\n            }\r\n\r\n            this._isCullDirty = false;\r\n        }\r\n\r\n        // Cull face\r\n        if (this._isCullFaceDirty) {\r\n            gl.cullFace(<number>this.cullFace);\r\n            this._isCullFaceDirty = false;\r\n        }\r\n\r\n        // Depth mask\r\n        if (this._isDepthMaskDirty) {\r\n            gl.depthMask(this.depthMask);\r\n            this._isDepthMaskDirty = false;\r\n        }\r\n\r\n        // Depth test\r\n        if (this._isDepthTestDirty) {\r\n            if (this.depthTest) {\r\n                gl.enable(gl.DEPTH_TEST);\r\n            } else {\r\n                gl.disable(gl.DEPTH_TEST);\r\n            }\r\n            this._isDepthTestDirty = false;\r\n        }\r\n\r\n        // Depth func\r\n        if (this._isDepthFuncDirty) {\r\n            gl.depthFunc(<number>this.depthFunc);\r\n            this._isDepthFuncDirty = false;\r\n        }\r\n\r\n        // zOffset\r\n        if (this._isZOffsetDirty) {\r\n            if (this.zOffset || this.zOffsetUnits) {\r\n                gl.enable(gl.POLYGON_OFFSET_FILL);\r\n                gl.polygonOffset(this.zOffset, this.zOffsetUnits);\r\n            } else {\r\n                gl.disable(gl.POLYGON_OFFSET_FILL);\r\n            }\r\n\r\n            this._isZOffsetDirty = false;\r\n        }\r\n\r\n        // Front face\r\n        if (this._isFrontFaceDirty) {\r\n            gl.frontFace(<number>this.frontFace);\r\n            this._isFrontFaceDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import type { IStencilState } from \"./IStencilState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class StencilStateComposer {\r\n    protected _isStencilTestDirty = false;\r\n    protected _isStencilMaskDirty = false;\r\n    protected _isStencilFuncDirty = false;\r\n    protected _isStencilOpDirty = false;\r\n\r\n    protected _enabled: boolean;\r\n\r\n    protected _mask: number;\r\n\r\n    protected _func: number;\r\n    protected _funcRef: number;\r\n    protected _funcMask: number;\r\n\r\n    protected _opStencilFail: number;\r\n    protected _opDepthFail: number;\r\n    protected _opStencilDepthPass: number;\r\n\r\n    public stencilGlobal: IStencilState;\r\n    public stencilMaterial: IStencilState | undefined;\r\n\r\n    public useStencilGlobalOnly = false;\r\n\r\n    public get isDirty(): boolean {\r\n        return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;\r\n    }\r\n\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        if (this._func === value) {\r\n            return;\r\n        }\r\n\r\n        this._func = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        if (this._funcRef === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcRef = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        if (this._funcMask === value) {\r\n            return;\r\n        }\r\n\r\n        this._funcMask = value;\r\n        this._isStencilFuncDirty = true;\r\n    }\r\n\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        if (this._opStencilFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilFail = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        if (this._opDepthFail === value) {\r\n            return;\r\n        }\r\n\r\n        this._opDepthFail = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        if (this._opStencilDepthPass === value) {\r\n            return;\r\n        }\r\n\r\n        this._opStencilDepthPass = value;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n        this._isStencilMaskDirty = true;\r\n    }\r\n\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        if (this._enabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._enabled = value;\r\n        this._isStencilTestDirty = true;\r\n    }\r\n\r\n    public constructor(reset = true) {\r\n        if (reset) {\r\n            this.reset();\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this.stencilMaterial = undefined;\r\n\r\n        this.stencilGlobal?.reset();\r\n\r\n        this._isStencilTestDirty = true;\r\n        this._isStencilMaskDirty = true;\r\n        this._isStencilFuncDirty = true;\r\n        this._isStencilOpDirty = true;\r\n    }\r\n\r\n    public apply(gl?: WebGLRenderingContext) {\r\n        if (!gl) {\r\n            return;\r\n        }\r\n\r\n        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;\r\n\r\n        this.enabled = stencilMaterialEnabled ? this.stencilMaterial!.enabled : this.stencilGlobal.enabled;\r\n        this.func = stencilMaterialEnabled ? this.stencilMaterial!.func : this.stencilGlobal.func;\r\n        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial!.funcRef : this.stencilGlobal.funcRef;\r\n        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial!.funcMask : this.stencilGlobal.funcMask;\r\n        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial!.opStencilFail : this.stencilGlobal.opStencilFail;\r\n        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial!.opDepthFail : this.stencilGlobal.opDepthFail;\r\n        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial!.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;\r\n        this.mask = stencilMaterialEnabled ? this.stencilMaterial!.mask : this.stencilGlobal.mask;\r\n\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Stencil test\r\n        if (this._isStencilTestDirty) {\r\n            if (this.enabled) {\r\n                gl.enable(gl.STENCIL_TEST);\r\n            } else {\r\n                gl.disable(gl.STENCIL_TEST);\r\n            }\r\n            this._isStencilTestDirty = false;\r\n        }\r\n\r\n        // Stencil mask\r\n        if (this._isStencilMaskDirty) {\r\n            gl.stencilMask(this.mask);\r\n            this._isStencilMaskDirty = false;\r\n        }\r\n\r\n        // Stencil func\r\n        if (this._isStencilFuncDirty) {\r\n            gl.stencilFunc(this.func, this.funcRef, this.funcMask);\r\n            this._isStencilFuncDirty = false;\r\n        }\r\n\r\n        // Stencil op\r\n        if (this._isStencilOpDirty) {\r\n            gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);\r\n            this._isStencilOpDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport type { IStencilState } from \"./IStencilState\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class StencilState implements IStencilState {\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\r\n    public static readonly ALWAYS = Constants.ALWAYS;\r\n    /** Passed to stencilOperation to specify that stencil value must be kept */\r\n    public static readonly KEEP = Constants.KEEP;\r\n    /** Passed to stencilOperation to specify that stencil value must be replaced */\r\n    public static readonly REPLACE = Constants.REPLACE;\r\n\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = StencilState.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = StencilState.KEEP;\r\n        this.opDepthFail = StencilState.KEEP;\r\n        this.opStencilDepthPass = StencilState.REPLACE;\r\n    }\r\n\r\n    public func: number;\r\n    public get stencilFunc(): number {\r\n        return this.func;\r\n    }\r\n\r\n    public set stencilFunc(value: number) {\r\n        this.func = value;\r\n    }\r\n\r\n    public funcRef: number;\r\n    public get stencilFuncRef(): number {\r\n        return this.funcRef;\r\n    }\r\n\r\n    public set stencilFuncRef(value: number) {\r\n        this.funcRef = value;\r\n    }\r\n\r\n    public funcMask: number;\r\n    public get stencilFuncMask(): number {\r\n        return this.funcMask;\r\n    }\r\n\r\n    public set stencilFuncMask(value: number) {\r\n        this.funcMask = value;\r\n    }\r\n\r\n    public opStencilFail: number;\r\n    public get stencilOpStencilFail(): number {\r\n        return this.opStencilFail;\r\n    }\r\n\r\n    public set stencilOpStencilFail(value: number) {\r\n        this.opStencilFail = value;\r\n    }\r\n\r\n    public opDepthFail: number;\r\n    public get stencilOpDepthFail(): number {\r\n        return this.opDepthFail;\r\n    }\r\n\r\n    public set stencilOpDepthFail(value: number) {\r\n        this.opDepthFail = value;\r\n    }\r\n\r\n    public opStencilDepthPass: number;\r\n    public get stencilOpStencilDepthPass(): number {\r\n        return this.opStencilDepthPass;\r\n    }\r\n\r\n    public set stencilOpStencilDepthPass(value: number) {\r\n        this.opStencilDepthPass = value;\r\n    }\r\n\r\n    public mask: number;\r\n    public get stencilMask(): number {\r\n        return this.mask;\r\n    }\r\n\r\n    public set stencilMask(value: number) {\r\n        this.mask = value;\r\n    }\r\n\r\n    public enabled: boolean;\r\n    public get stencilTest(): boolean {\r\n        return this.enabled;\r\n    }\r\n\r\n    public set stencilTest(value: boolean) {\r\n        this.enabled = value;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n **/\r\nexport class AlphaState {\r\n    public _blendFunctionParameters = new Array<Nullable<number>>(4);\r\n    public _blendEquationParameters = new Array<Nullable<number>>(2);\r\n    public _blendConstants = new Array<Nullable<number>>(4);\r\n    public _isBlendConstantsDirty = false;\r\n\r\n    private _alphaBlend = false;\r\n    private _isAlphaBlendDirty = false;\r\n    private _isBlendFunctionParametersDirty = false;\r\n    private _isBlendEquationParametersDirty = false;\r\n\r\n    /**\r\n     * Initializes the state.\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public get isDirty(): boolean {\r\n        return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;\r\n    }\r\n\r\n    public get alphaBlend(): boolean {\r\n        return this._alphaBlend;\r\n    }\r\n\r\n    public set alphaBlend(value: boolean) {\r\n        if (this._alphaBlend === value) {\r\n            return;\r\n        }\r\n\r\n        this._alphaBlend = value;\r\n        this._isAlphaBlendDirty = true;\r\n    }\r\n\r\n    public setAlphaBlendConstants(r: number, g: number, b: number, a: number): void {\r\n        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {\r\n            return;\r\n        }\r\n\r\n        this._blendConstants[0] = r;\r\n        this._blendConstants[1] = g;\r\n        this._blendConstants[2] = b;\r\n        this._blendConstants[3] = a;\r\n\r\n        this._isBlendConstantsDirty = true;\r\n    }\r\n\r\n    public setAlphaBlendFunctionParameters(value0: number, value1: number, value2: number, value3: number): void {\r\n        if (\r\n            this._blendFunctionParameters[0] === value0 &&\r\n            this._blendFunctionParameters[1] === value1 &&\r\n            this._blendFunctionParameters[2] === value2 &&\r\n            this._blendFunctionParameters[3] === value3\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        this._blendFunctionParameters[0] = value0;\r\n        this._blendFunctionParameters[1] = value1;\r\n        this._blendFunctionParameters[2] = value2;\r\n        this._blendFunctionParameters[3] = value3;\r\n\r\n        this._isBlendFunctionParametersDirty = true;\r\n    }\r\n\r\n    public setAlphaEquationParameters(rgb: number, alpha: number): void {\r\n        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {\r\n            return;\r\n        }\r\n\r\n        this._blendEquationParameters[0] = rgb;\r\n        this._blendEquationParameters[1] = alpha;\r\n\r\n        this._isBlendEquationParametersDirty = true;\r\n    }\r\n\r\n    public reset() {\r\n        this._alphaBlend = false;\r\n        this._blendFunctionParameters[0] = null;\r\n        this._blendFunctionParameters[1] = null;\r\n        this._blendFunctionParameters[2] = null;\r\n        this._blendFunctionParameters[3] = null;\r\n\r\n        this._blendEquationParameters[0] = null;\r\n        this._blendEquationParameters[1] = null;\r\n\r\n        this._blendConstants[0] = null;\r\n        this._blendConstants[1] = null;\r\n        this._blendConstants[2] = null;\r\n        this._blendConstants[3] = null;\r\n\r\n        this._isAlphaBlendDirty = true;\r\n        this._isBlendFunctionParametersDirty = false;\r\n        this._isBlendEquationParametersDirty = false;\r\n        this._isBlendConstantsDirty = false;\r\n    }\r\n\r\n    public apply(gl: WebGLRenderingContext) {\r\n        if (!this.isDirty) {\r\n            return;\r\n        }\r\n\r\n        // Alpha blend\r\n        if (this._isAlphaBlendDirty) {\r\n            if (this._alphaBlend) {\r\n                gl.enable(gl.BLEND);\r\n            } else {\r\n                gl.disable(gl.BLEND);\r\n            }\r\n\r\n            this._isAlphaBlendDirty = false;\r\n        }\r\n\r\n        // Alpha function\r\n        if (this._isBlendFunctionParametersDirty) {\r\n            gl.blendFuncSeparate(\r\n                <number>this._blendFunctionParameters[0],\r\n                <number>this._blendFunctionParameters[1],\r\n                <number>this._blendFunctionParameters[2],\r\n                <number>this._blendFunctionParameters[3]\r\n            );\r\n            this._isBlendFunctionParametersDirty = false;\r\n        }\r\n\r\n        // Alpha equation\r\n        if (this._isBlendEquationParametersDirty) {\r\n            gl.blendEquationSeparate(this._blendEquationParameters[0]!, this._blendEquationParameters[1]!);\r\n            this._isBlendEquationParametersDirty = false;\r\n        }\r\n\r\n        // Constants\r\n        if (this._isBlendConstantsDirty) {\r\n            gl.blendColor(<number>this._blendConstants[0], <number>this._blendConstants[1], <number>this._blendConstants[2], <number>this._blendConstants[3]);\r\n            this._isBlendConstantsDirty = false;\r\n        }\r\n    }\r\n}\r\n", "import { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Class used to store a texture sampler data\r\n */\r\nexport class TextureSampler {\r\n    /**\r\n     * Gets the sampling mode of the texture\r\n     */\r\n    public samplingMode: number = -1;\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._cachedWrapU;\r\n    }\r\n\r\n    public set wrapU(value: Nullable<number>) {\r\n        this._cachedWrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._cachedWrapV;\r\n    }\r\n\r\n    public set wrapV(value: Nullable<number>) {\r\n        this._cachedWrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapR() {\r\n        return this._cachedWrapR;\r\n    }\r\n\r\n    public set wrapR(value: Nullable<number>) {\r\n        this._cachedWrapR = value;\r\n    }\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower.\r\n     */\r\n    public get anisotropicFilteringLevel() {\r\n        return this._cachedAnisotropicFilteringLevel;\r\n    }\r\n\r\n    public set anisotropicFilteringLevel(value: Nullable<number>) {\r\n        this._cachedAnisotropicFilteringLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the comparison function (Constants.LESS, Constants.EQUAL, etc). Set 0 to not use a comparison function\r\n     */\r\n    public get comparisonFunction() {\r\n        return this._comparisonFunction;\r\n    }\r\n\r\n    public set comparisonFunction(value: number) {\r\n        this._comparisonFunction = value;\r\n    }\r\n\r\n    private _useMipMaps = true;\r\n    /**\r\n     * Indicates to use the mip maps (if available on the texture).\r\n     * Thanks to this flag, you can instruct the sampler to not sample the mipmaps even if they exist (and if the sampling mode is set to a value that normally samples the mipmaps!)\r\n     */\r\n    public get useMipMaps() {\r\n        return this._useMipMaps;\r\n    }\r\n\r\n    public set useMipMaps(value: boolean) {\r\n        this._useMipMaps = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public _cachedWrapU: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedWrapV: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedWrapR: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _cachedAnisotropicFilteringLevel: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _comparisonFunction: number = 0;\r\n\r\n    /**\r\n     * Used for debugging purpose only\r\n     */\r\n    public label?: string;\r\n\r\n    /**\r\n     * Creates a Sampler instance\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Sets all the parameters of the sampler\r\n     * @param wrapU u address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param wrapV v address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param wrapR r address mode (default: TEXTURE_WRAP_ADDRESSMODE)\r\n     * @param anisotropicFilteringLevel anisotropic level (default: 1)\r\n     * @param samplingMode sampling mode (default: Constants.TEXTURE_BILINEAR_SAMPLINGMODE)\r\n     * @param comparisonFunction comparison function (default: 0 - no comparison function)\r\n     * @returns the current sampler instance\r\n     */\r\n    public setParameters(\r\n        wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE,\r\n        anisotropicFilteringLevel = 1,\r\n        samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        comparisonFunction = 0\r\n    ): TextureSampler {\r\n        this._cachedWrapU = wrapU;\r\n        this._cachedWrapV = wrapV;\r\n        this._cachedWrapR = wrapR;\r\n        this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;\r\n        this.samplingMode = samplingMode;\r\n        this._comparisonFunction = comparisonFunction;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compares this sampler with another one\r\n     * @param other sampler to compare with\r\n     * @returns true if the samplers have the same parametres, else false\r\n     */\r\n    public compareSampler(other: TextureSampler): boolean {\r\n        return (\r\n            this._cachedWrapU === other._cachedWrapU &&\r\n            this._cachedWrapV === other._cachedWrapV &&\r\n            this._cachedWrapR === other._cachedWrapR &&\r\n            this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel &&\r\n            this.samplingMode === other.samplingMode &&\r\n            this._comparisonFunction === other._comparisonFunction &&\r\n            this._useMipMaps === other._useMipMaps\r\n        );\r\n    }\r\n}\r\n", "import { Observable } from \"../../Misc/observable\";\r\nimport type { ImageSource, Nullable, int } from \"../../types\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"./hardwareTextureWrapper\";\r\nimport { TextureSampler } from \"./textureSampler\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\n\r\n/**\r\n * Defines the source of the internal texture\r\n */\r\nexport const enum InternalTextureSource {\r\n    /**\r\n     * The source of the texture data is unknown\r\n     */\r\n    Unknown,\r\n    /**\r\n     * Texture data comes from an URL\r\n     */\r\n    Url,\r\n    /**\r\n     * Texture data is only used for temporary storage\r\n     */\r\n    Temp,\r\n    /**\r\n     * Texture data comes from raw data (ArrayBuffer)\r\n     */\r\n    Raw,\r\n    /**\r\n     * Texture content is dynamic (video or dynamic texture)\r\n     */\r\n    Dynamic,\r\n    /**\r\n     * Texture content is generated by rendering to it\r\n     */\r\n    RenderTarget,\r\n    /**\r\n     * Texture content is part of a multi render target process\r\n     */\r\n    MultiRenderTarget,\r\n    /**\r\n     * Texture data comes from a cube data file\r\n     */\r\n    Cube,\r\n    /**\r\n     * Texture data comes from a raw cube data\r\n     */\r\n    CubeRaw,\r\n    /**\r\n     * Texture data come from a prefiltered cube data file\r\n     */\r\n    CubePrefiltered,\r\n    /**\r\n     * Texture content is raw 3D data\r\n     */\r\n    Raw3D,\r\n    /**\r\n     * Texture content is raw 2D array data\r\n     */\r\n    Raw2DArray,\r\n    /**\r\n     * Texture content is a depth/stencil texture\r\n     */\r\n    DepthStencil,\r\n    /**\r\n     * Texture data comes from a raw cube data encoded with RGBD\r\n     */\r\n    CubeRawRGBD,\r\n    /**\r\n     * Texture content is a depth texture\r\n     */\r\n    Depth,\r\n}\r\n\r\n/**\r\n * Class used to store data associated with WebGL texture data for the engine\r\n * This class should not be used directly\r\n */\r\nexport class InternalTexture extends TextureSampler {\r\n    /**\r\n     * Defines if the texture is ready\r\n     */\r\n    public isReady: boolean = false;\r\n    /**\r\n     * Defines if the texture is a cube texture\r\n     */\r\n    public isCube: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 3D data\r\n     */\r\n    public is3D: boolean = false;\r\n    /**\r\n     * Defines if the texture contains 2D array data\r\n     */\r\n    public is2DArray: boolean = false;\r\n    /**\r\n     * Defines if the texture contains multiview data\r\n     */\r\n    public isMultiview: boolean = false;\r\n    /**\r\n     * Gets the URL used to load this texture\r\n     */\r\n    public url: string = \"\";\r\n    /** @internal */\r\n    public _originalUrl: string; // not empty only if different from url\r\n    /**\r\n     * Gets a boolean indicating if the texture needs mipmaps generation\r\n     */\r\n    public generateMipMaps: boolean = false;\r\n    /**\r\n     * Gets a boolean indicating if the texture uses mipmaps\r\n     * TODO implements useMipMaps as a separate setting from generateMipMaps\r\n     */\r\n    public override get useMipMaps() {\r\n        return this.generateMipMaps;\r\n    }\r\n    public override set useMipMaps(value: boolean) {\r\n        this.generateMipMaps = value;\r\n    }\r\n    /**\r\n     * Gets the number of samples used by the texture (WebGL2+ only)\r\n     */\r\n    public samples: number = 0;\r\n    /**\r\n     * Gets the type of the texture (int, float...)\r\n     */\r\n    public type: number = -1;\r\n    /**\r\n     * Gets the format of the texture (RGB, RGBA...)\r\n     */\r\n    public format: number = -1;\r\n    /**\r\n     * Observable called when the texture is loaded\r\n     */\r\n    public onLoadedObservable = new Observable<InternalTexture>();\r\n    /**\r\n     * Observable called when the texture load is raising an error\r\n     */\r\n    public onErrorObservable = new Observable<Partial<{ message: string; exception: any }>>();\r\n    /**\r\n     * If this callback is defined it will be called instead of the default _rebuild function\r\n     */\r\n    public onRebuildCallback: Nullable<\r\n        (internalTexture: InternalTexture) => {\r\n            proxy: Nullable<InternalTexture | Promise<InternalTexture>>;\r\n            isReady: boolean;\r\n            isAsync: boolean;\r\n        }\r\n    > = null;\r\n    /**\r\n     * Gets the width of the texture\r\n     */\r\n    public width: number = 0;\r\n    /**\r\n     * Gets the height of the texture\r\n     */\r\n    public height: number = 0;\r\n    /**\r\n     * Gets the depth of the texture\r\n     */\r\n    public depth: number = 0;\r\n    /**\r\n     * Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseWidth: number = 0;\r\n    /**\r\n     * Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseHeight: number = 0;\r\n    /**\r\n     * Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)\r\n     */\r\n    public baseDepth: number = 0;\r\n    /**\r\n     * Gets a boolean indicating if the texture is inverted on Y axis\r\n     */\r\n    public invertY: boolean = false;\r\n\r\n    // Private\r\n    /** @internal */\r\n    public _invertVScale = false;\r\n    /** @internal */\r\n    public _associatedChannel = -1;\r\n    /** @internal */\r\n    public _source = InternalTextureSource.Unknown;\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    /** @internal */\r\n    public _bufferView: Nullable<ArrayBufferView> = null;\r\n    /** @internal */\r\n    public _bufferViewArray: Nullable<ArrayBufferView[]> = null;\r\n    /** @internal */\r\n    public _bufferViewArrayArray: Nullable<ArrayBufferView[][]> = null;\r\n    /** @internal */\r\n    public _size: number = 0;\r\n    /** @internal */\r\n    public _extension: string = \"\";\r\n    /** @internal */\r\n    public _files: Nullable<string[]> = null;\r\n    /** @internal */\r\n    public _workingCanvas: Nullable<ICanvas> = null;\r\n    /** @internal */\r\n    public _workingContext: Nullable<ICanvasRenderingContext> = null;\r\n    /** @internal */\r\n    public _cachedCoordinatesMode: Nullable<number> = null;\r\n    /** @internal */\r\n    public _isDisabled: boolean = false;\r\n    /** @internal */\r\n    public _compression: Nullable<string> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomial: Nullable<SphericalPolynomial> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialPromise: Nullable<Promise<SphericalPolynomial>> = null;\r\n    /** @internal */\r\n    public _sphericalPolynomialComputed = false;\r\n    /** @internal */\r\n    public _lodGenerationScale: number = 0;\r\n    /** @internal */\r\n    public _lodGenerationOffset: number = 0;\r\n    /** @internal */\r\n    public _useSRGBBuffer: boolean = false;\r\n    /** @internal */\r\n    public _creationFlags: number = 0;\r\n    /** @internal */\r\n    public _originalFormat?: number;\r\n\r\n    // The following three fields helps sharing generated fixed LODs for texture filtering\r\n    // In environment not supporting the textureLOD extension like EDGE. They are for internal use only.\r\n    // They are at the level of the gl texture to benefit from the cache.\r\n    /** @internal */\r\n    public _lodTextureHigh: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureMid: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _lodTextureLow: Nullable<BaseTexture> = null;\r\n    /** @internal */\r\n    public _isRGBD: boolean = false;\r\n\r\n    /** @internal */\r\n    public _linearSpecularLOD: boolean = false;\r\n    /** @internal */\r\n    public _irradianceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _hardwareTexture: Nullable<HardwareTextureWrapper> = null;\r\n\r\n    /** @internal */\r\n    public _maxLodLevel: Nullable<number> = null;\r\n\r\n    /** @internal */\r\n    public _references: number = 1;\r\n\r\n    /** @internal */\r\n    public _gammaSpace: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _premulAlpha = false;\r\n\r\n    /** @internal */\r\n    public _dynamicTextureSource: Nullable<ImageSource> = null;\r\n\r\n    private _engine: AbstractEngine;\r\n    private _uniqueId: number;\r\n\r\n    /** @internal */\r\n    public static _Counter = 0;\r\n\r\n    /** Gets the unique id of the internal texture */\r\n    public get uniqueId() {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setUniqueId(id: number) {\r\n        this._uniqueId = id;\r\n    }\r\n\r\n    /**\r\n     * Gets the Engine the texture belongs to.\r\n     * @returns The babylon engine\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the data source type of the texture\r\n     */\r\n    public get source(): InternalTextureSource {\r\n        return this._source;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InternalTexture\r\n     * @param engine defines the engine to use\r\n     * @param source defines the type of data that will be used\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(engine: AbstractEngine, source: InternalTextureSource, delayAllocation = false) {\r\n        super();\r\n\r\n        this._engine = engine;\r\n        this._source = source;\r\n        this._uniqueId = InternalTexture._Counter++;\r\n\r\n        if (!delayAllocation) {\r\n            this._hardwareTexture = engine._createHardwareTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increments the number of references (ie. the number of Texture that point to it)\r\n     */\r\n    public incrementReferences(): void {\r\n        this._references++;\r\n    }\r\n\r\n    /**\r\n     * Change the size of the texture (not the size of the content)\r\n     * @param width defines the new width\r\n     * @param height defines the new height\r\n     * @param depth defines the new depth (1 by default)\r\n     */\r\n    public updateSize(width: int, height: int, depth: int = 1): void {\r\n        this._engine.updateTextureDimensions(this, width, height, depth);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n\r\n        this.baseWidth = width;\r\n        this.baseHeight = height;\r\n        this.baseDepth = depth;\r\n\r\n        this._size = width * height * depth;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.isReady = false;\r\n        this._cachedCoordinatesMode = null;\r\n        this._cachedWrapU = null;\r\n        this._cachedWrapV = null;\r\n        this._cachedWrapR = null;\r\n        this._cachedAnisotropicFilteringLevel = null;\r\n        if (this.onRebuildCallback) {\r\n            const data = this.onRebuildCallback(this);\r\n            const swapAndSetIsReady = (proxyInternalTexture: InternalTexture) => {\r\n                proxyInternalTexture._swapAndDie(this, false);\r\n                this.isReady = data.isReady;\r\n            };\r\n            if (data.isAsync) {\r\n                (data.proxy as Promise<InternalTexture>).then(swapAndSetIsReady);\r\n            } else {\r\n                swapAndSetIsReady(data.proxy as InternalTexture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let proxy: InternalTexture;\r\n        switch (this.source) {\r\n            case InternalTextureSource.Temp:\r\n                break;\r\n\r\n            case InternalTextureSource.Url:\r\n                proxy = this._engine.createTexture(\r\n                    this._originalUrl ?? this.url,\r\n                    !this.generateMipMaps,\r\n                    this.invertY,\r\n                    null,\r\n                    this.samplingMode,\r\n                    // Do not use Proxy here as it could be fully synchronous\r\n                    // and proxy would be undefined.\r\n                    (temp) => {\r\n                        temp._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this._buffer,\r\n                    undefined,\r\n                    this.format,\r\n                    this._extension,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    this._useSRGBBuffer\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.Raw:\r\n                proxy = this._engine.createRawTexture(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw3D:\r\n                proxy = this._engine.createRawTexture3D(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Raw2DArray:\r\n                proxy = this._engine.createRawTexture2DArray(\r\n                    this._bufferView,\r\n                    this.baseWidth,\r\n                    this.baseHeight,\r\n                    this.baseDepth,\r\n                    this.format,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression,\r\n                    this.type\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.Dynamic:\r\n                proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);\r\n                proxy._swapAndDie(this, false);\r\n                if (this._dynamicTextureSource) {\r\n                    this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, true);\r\n                }\r\n\r\n                // The engine will make sure to update content so no need to flag it as isReady = true\r\n                break;\r\n\r\n            case InternalTextureSource.Cube:\r\n                proxy = this._engine.createCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._files,\r\n                    !this.generateMipMaps,\r\n                    () => {\r\n                        proxy._swapAndDie(this, false);\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension,\r\n                    false,\r\n                    0,\r\n                    0,\r\n                    null,\r\n                    undefined,\r\n                    this._useSRGBBuffer,\r\n                    ArrayBuffer.isView(this._buffer) ? this._buffer : null\r\n                );\r\n                return;\r\n\r\n            case InternalTextureSource.CubeRaw:\r\n                proxy = this._engine.createRawCubeTexture(\r\n                    this._bufferViewArray!,\r\n                    this.width,\r\n                    this._originalFormat ?? this.format,\r\n                    this.type,\r\n                    this.generateMipMaps,\r\n                    this.invertY,\r\n                    this.samplingMode,\r\n                    this._compression\r\n                );\r\n                proxy._swapAndDie(this, false);\r\n                this.isReady = true;\r\n                break;\r\n\r\n            case InternalTextureSource.CubeRawRGBD:\r\n                // This case is being handeled by the environment texture tools and is not a part of the rebuild process.\r\n                // To use CubeRawRGBD use updateRGBDAsync on the cube texture.\r\n                return;\r\n\r\n            case InternalTextureSource.CubePrefiltered:\r\n                proxy = this._engine.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    null,\r\n                    this._lodGenerationScale,\r\n                    this._lodGenerationOffset,\r\n                    (proxy) => {\r\n                        if (proxy) {\r\n                            proxy._swapAndDie(this, false);\r\n                        }\r\n                        this.isReady = true;\r\n                    },\r\n                    null,\r\n                    this.format,\r\n                    this._extension\r\n                );\r\n                proxy._sphericalPolynomial = this._sphericalPolynomial;\r\n                return;\r\n\r\n            case InternalTextureSource.DepthStencil:\r\n            case InternalTextureSource.Depth: {\r\n                // Will be handled at the RenderTargetWrapper level\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture, swapAll = true): void {\r\n        // TODO what about refcount on target?\r\n\r\n        this._hardwareTexture?.setUsage(target._source, this.generateMipMaps, this.is2DArray, this.isCube, this.is3D, this.width, this.height, this.depth);\r\n\r\n        target._hardwareTexture = this._hardwareTexture;\r\n        if (swapAll) {\r\n            target._isRGBD = this._isRGBD;\r\n        }\r\n\r\n        if (this._lodTextureHigh) {\r\n            if (target._lodTextureHigh) {\r\n                target._lodTextureHigh.dispose();\r\n            }\r\n            target._lodTextureHigh = this._lodTextureHigh;\r\n        }\r\n\r\n        if (this._lodTextureMid) {\r\n            if (target._lodTextureMid) {\r\n                target._lodTextureMid.dispose();\r\n            }\r\n            target._lodTextureMid = this._lodTextureMid;\r\n        }\r\n\r\n        if (this._lodTextureLow) {\r\n            if (target._lodTextureLow) {\r\n                target._lodTextureLow.dispose();\r\n            }\r\n            target._lodTextureLow = this._lodTextureLow;\r\n        }\r\n\r\n        if (this._irradianceTexture) {\r\n            if (target._irradianceTexture) {\r\n                target._irradianceTexture.dispose();\r\n            }\r\n            target._irradianceTexture = this._irradianceTexture;\r\n        }\r\n\r\n        const cache = this._engine.getLoadedTexturesCache();\r\n        let index = cache.indexOf(this);\r\n        if (index !== -1) {\r\n            cache.splice(index, 1);\r\n        }\r\n\r\n        index = cache.indexOf(target);\r\n        if (index === -1) {\r\n            cache.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the current allocated resources\r\n     */\r\n    public dispose(): void {\r\n        this._references--;\r\n        this.onLoadedObservable.clear();\r\n        this.onErrorObservable.clear();\r\n        if (this._references === 0) {\r\n            this._engine._releaseTexture(this);\r\n            this._hardwareTexture = null;\r\n            this._dynamicTextureSource = null;\r\n        }\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { DataArray, FloatArray, IndicesArray, Nullable } from \"../types\";\r\nimport type { PerfCounter } from \"../Misc/perfCounter\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport type { ICanvas, IImage } from \"./ICanvas\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { EngineCapabilities } from \"./engineCapabilities\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { IShaderProcessor } from \"./Processors/iShaderProcessor\";\r\nimport type { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport type { IAudioEngineOptions } from \"../Audio/Interfaces/IAudioEngineOptions\";\r\nimport type { EngineFeatures } from \"./engineFeatures\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { IInternalTextureLoader } from \"../Materials/Textures/internalTextureLoader\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { VertexBuffer } from \"../Meshes/buffer\";\r\nimport type { IAudioEngine } from \"../Audio/Interfaces/IAudioEngine\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { PerformanceMonitor } from \"core/Misc/performanceMonitor\";\r\nimport type { ILoadingScreen } from \"../Loading/loadingScreen\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PerformanceConfigurator } from \"./performanceConfigurator\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { DepthCullingState } from \"../States/depthCullingState\";\r\nimport { StencilStateComposer } from \"../States/stencilStateComposer\";\r\nimport { StencilState } from \"../States/stencilState\";\r\nimport { AlphaState } from \"../States/alphaCullingState\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { IsDocumentAvailable, IsNavigatorAvailable, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { Constants } from \"./constants\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { EngineFunctionContext, _loadFile } from \"./abstractEngine.functions\";\r\n\r\n/**\r\n * Defines the interface used by objects working like Scene\r\n * @internal\r\n */\r\nexport interface ISceneLike {\r\n    /** Add pending data  (to load) */\r\n    addPendingData(data: any): void;\r\n    /** Remove pending data */\r\n    removePendingData(data: any): void;\r\n    /** Offline provider */\r\n    offlineProvider: IOfflineProvider;\r\n}\r\n\r\n/**\r\n * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)\r\n * @param func - the function to be called\r\n * @param requester - the object that will request the next frame. Falls back to window.\r\n * @returns frame number\r\n */\r\nexport function QueueNewFrame(func: () => void, requester?: any): number {\r\n    // Note that there is kind of a typing issue here, as `setTimeout` might return something else than a number (NodeJs returns a NodeJS.Timeout object).\r\n    // Also if the global `requestAnimationFrame`'s returnType is number, `requester.requestPostAnimationFrame` and `requester.requestAnimationFrame` types\r\n    // are `any`.\r\n\r\n    if (!IsWindowObjectExist()) {\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    } else {\r\n        const { requestAnimationFrame } = requester || window;\r\n        if (typeof requestAnimationFrame === \"function\") {\r\n            return requestAnimationFrame(func);\r\n        }\r\n    }\r\n\r\n    // fallback to the global `setTimeout`.\r\n    // In most cases (aka in the browser), `window` is the global object, so instead of calling `window.setTimeout` we could call the global `setTimeout`.\r\n    return setTimeout(func, 16) as unknown as number;\r\n}\r\n\r\n/** Interface defining initialization parameters for AbstractEngine class */\r\nexport interface AbstractEngineOptions {\r\n    /**\r\n     * Defines if the engine should no exceed a specified device ratio\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio\r\n     */\r\n    limitDeviceRatio?: number;\r\n    /**\r\n     * Defines if webaudio should be initialized as well\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     */\r\n    audioEngine?: boolean;\r\n    /**\r\n     * Specifies options for the audio engine\r\n     */\r\n    audioEngineOptions?: IAudioEngineOptions;\r\n\r\n    /**\r\n     * Defines if animations should run using a deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     */\r\n    deterministicLockstep?: boolean;\r\n    /** Defines the maximum steps to use with deterministic lock step mode */\r\n    lockstepMaxSteps?: number;\r\n    /** Defines the seconds between each deterministic lock step */\r\n    timeStep?: number;\r\n    /**\r\n     * Defines that engine should ignore context lost events\r\n     * If this event happens when this parameter is true, you will have to reload the page to restore rendering\r\n     */\r\n    doNotHandleContextLost?: boolean;\r\n    /**\r\n     * Defines that engine should ignore modifying touch action attribute and style\r\n     * If not handle, you might need to set it up on your side for expected touch devices behavior.\r\n     */\r\n    doNotHandleTouchAction?: boolean;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n\r\n    /**\r\n     * Defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n\r\n    /**\r\n     * Defines whether MSAA is enabled on the canvas.\r\n     */\r\n    antialias?: boolean;\r\n\r\n    /**\r\n     * Defines whether the stencil buffer should be enabled.\r\n     */\r\n    stencil?: boolean;\r\n\r\n    /**\r\n     * Defines whether the canvas should be created in \"premultiplied\" mode (if false, the canvas is created in the \"opaque\" mode) (true by default)\r\n     */\r\n    premultipliedAlpha?: boolean;\r\n    /**\r\n     * True if the more expensive but exact conversions should be used for transforming colors to and from linear space within shaders.\r\n     * Otherwise, the default is to use a cheaper approximation.\r\n     */\r\n    useExactSrgbConversions?: boolean;\r\n}\r\n\r\n/**\r\n * Information about the current host\r\n */\r\nexport interface HostInformation {\r\n    /**\r\n     * Defines if the current host is a mobile\r\n     */\r\n    isMobile: boolean;\r\n}\r\n\r\nexport type PrepareTextureProcessFunction = (\r\n    width: number,\r\n    height: number,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    extension: string,\r\n    texture: InternalTexture,\r\n    continuationCallback: () => void\r\n) => boolean;\r\n\r\nexport type PrepareTextureFunction = (\r\n    texture: InternalTexture,\r\n    extension: string,\r\n    scene: Nullable<ISceneLike>,\r\n    img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n    invertY: boolean,\r\n    noMipmap: boolean,\r\n    isCompressed: boolean,\r\n    processFunction: PrepareTextureProcessFunction,\r\n    samplingMode: number\r\n) => void;\r\n\r\n/**\r\n * The parent class for specialized engines (WebGL, WebGPU)\r\n */\r\nexport abstract class AbstractEngine {\r\n    /** @internal */\r\n    public static _TextureLoaders: IInternalTextureLoader[] = [];\r\n\r\n    // States\r\n    /** @internal */\r\n    protected _colorWrite = true;\r\n    /** @internal */\r\n    protected _colorWriteChanged = true;\r\n    /** @internal */\r\n    public _depthCullingState = new DepthCullingState();\r\n    /** @internal */\r\n    protected _stencilStateComposer = new StencilStateComposer();\r\n    /** @internal */\r\n    public _stencilState = new StencilState();\r\n    /** @internal */\r\n    public _alphaState = new AlphaState();\r\n    /** @internal */\r\n    public _alphaMode = Constants.ALPHA_ADD;\r\n    /** @internal */\r\n    public _alphaEquation = Constants.ALPHA_DISABLE;\r\n\r\n    protected _activeRequests: IFileRequest[] = [];\r\n\r\n    /** @internal */\r\n    public _badOS = false;\r\n    /** @internal */\r\n    public _badDesktopOS = false;\r\n    /** @internal */\r\n    public _videoTextureSupported: boolean;\r\n\r\n    protected _compatibilityMode = true;\r\n    /** @internal */\r\n    public _pointerLockRequested: boolean;\r\n    /** @internal */\r\n    public _loadingScreen: ILoadingScreen;\r\n    /** @internal */\r\n    public _renderingCanvas: Nullable<HTMLCanvasElement>;\r\n    /** @internal */\r\n    public _internalTexturesCache = new Array<InternalTexture>();\r\n    protected _currentEffect: Nullable<Effect>;\r\n    /** @internal */\r\n    protected _cachedVertexBuffers: any;\r\n    /** @internal */\r\n    protected _cachedIndexBuffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    protected _cachedEffectForVertexBuffers: Nullable<Effect>;\r\n    /** @internal */\r\n    public _currentRenderTarget: Nullable<RenderTargetWrapper> = null;\r\n    /** @internal */\r\n    public _caps: EngineCapabilities;\r\n    /** @internal */\r\n    protected _cachedViewport: Nullable<IViewportLike>;\r\n    /** @internal */\r\n    public _currentDrawContext: IDrawContext;\r\n\r\n    /** @internal */\r\n    protected _boundTexturesCache: { [key: string]: Nullable<InternalTexture> } = {};\r\n    /** @internal */\r\n    protected _activeChannel = 0;\r\n    /** @internal */\r\n    protected _currentTextureChannel = -1;\r\n    /** @internal */\r\n    protected _viewportCached = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    /** @internal */\r\n    protected _isWebGPU: boolean = false;\r\n\r\n    // Focus\r\n    /** @internal */\r\n    public _onFocus: () => void;\r\n    /** @internal */\r\n    public _onBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasPointerOut: (event: PointerEvent) => void;\r\n    /** @internal */\r\n    public _onCanvasBlur: () => void;\r\n    /** @internal */\r\n    public _onCanvasFocus: () => void;\r\n    /** @internal */\r\n    public _onCanvasContextMenu: (evt: Event) => void;\r\n    /** @internal */\r\n    public _onFullscreenChange: () => void;\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas loses focus\r\n     */\r\n    public onCanvasBlurObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable event triggered each time the canvas gains focus\r\n     */\r\n    public onCanvasFocusObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Event raised when a new scene is created\r\n     */\r\n    public onNewSceneAddedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * Observable event triggered each time the rendering canvas is resized\r\n     */\r\n    public onResizeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable event triggered each time the canvas receives pointerout event\r\n     */\r\n    public onCanvasPointerOutObservable = new Observable<PointerEvent>();\r\n\r\n    /**\r\n     * Turn this value on if you want to pause FPS computation when in background\r\n     */\r\n    public disablePerformanceMonitorInBackground = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that vertex array object must be disabled even if they are supported\r\n     */\r\n    public disableVertexArrayObjects = false;\r\n\r\n    /** @internal */\r\n    protected _frameId = 0;\r\n    /**\r\n     * Gets the current frame id\r\n     */\r\n    public get frameId(): number {\r\n        return this._frameId;\r\n    }\r\n    /**\r\n     * Gets a boolean indicating if the engine runs in WebGPU or not.\r\n     */\r\n    public get isWebGPU(): boolean {\r\n        return this._isWebGPU;\r\n    }\r\n\r\n    protected _shaderProcessor: Nullable<IShaderProcessor>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessor(shaderLanguage: ShaderLanguage): Nullable<IShaderProcessor> {\r\n        return this._shaderProcessor;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public abstract areAllEffectsReady(): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _setTexture(channel: number, texture: Nullable<ThinTexture>, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean, name?: string): boolean;\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param unused unused parameter\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public abstract setTexture(channel: number, unused: Nullable<WebGLUniformLocation>, texture: Nullable<ThinTexture>, name: string): void;\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public abstract bindSamplers(effect: Effect): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _deletePipelineContext(pipelineContext: IPipelineContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        rawVertexSourceCode: string,\r\n        rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        transformFeedbackVaryings: Nullable<string[]>,\r\n        key: string\r\n    ): void;\r\n\r\n    /** @internal */\r\n    protected _shaderPlatformName: string;\r\n    /**\r\n     * Gets the shader platform name used by the effects.\r\n     */\r\n    public get shaderPlatformName(): string {\r\n        return this._shaderPlatformName;\r\n    }\r\n\r\n    /**\r\n     * Gets information about the current host\r\n     */\r\n    public hostInformation: HostInformation = {\r\n        isMobile: false,\r\n    };\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine is currently rendering in fullscreen mode\r\n     */\r\n    public isFullscreen = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest\r\n     **/\r\n    public enableOfflineSupport = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)\r\n     **/\r\n    public disableManifestCheck = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean to enable/disable the context menu (right-click) from appearing on the main canvas\r\n     */\r\n    public disableContextMenu: boolean = true;\r\n\r\n    /**\r\n     * Gets or sets the current render pass id\r\n     */\r\n    public currentRenderPassId = Constants.RENDERPASS_MAIN;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the pointer is currently locked\r\n     */\r\n    public isPointerLock = false;\r\n\r\n    /**\r\n     * Gets the list of created postprocesses\r\n     */\r\n    public postProcesses: PostProcess[] = [];\r\n\r\n    /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */\r\n    public canvasTabIndex = 1;\r\n\r\n    /** @internal */\r\n    protected _onContextLost: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _onContextRestored: (evt: Event) => void;\r\n    /** @internal */\r\n    protected _contextWasLost = false;\r\n\r\n    private _emptyTexture: Nullable<InternalTexture>;\r\n    private _emptyCubeTexture: Nullable<InternalTexture>;\r\n    private _emptyTexture3D: Nullable<InternalTexture>;\r\n    private _emptyTexture2DArray: Nullable<InternalTexture>;\r\n\r\n    protected _clearEmptyResources(): void {\r\n        this._emptyTexture = null;\r\n        this._emptyCubeTexture = null;\r\n        this._emptyTexture3D = null;\r\n        this._emptyTexture2DArray = null;\r\n    }\r\n\r\n    public abstract wipeCaches(bruteForce?: boolean): void;\r\n\r\n    private _useReverseDepthBuffer = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.\r\n     * This can provide greater z depth for distant objects.\r\n     */\r\n    public get useReverseDepthBuffer(): boolean {\r\n        return this._useReverseDepthBuffer;\r\n    }\r\n\r\n    public set useReverseDepthBuffer(useReverse) {\r\n        if (useReverse === this._useReverseDepthBuffer) {\r\n            return;\r\n        }\r\n\r\n        this._useReverseDepthBuffer = useReverse;\r\n\r\n        if (useReverse) {\r\n            this._depthCullingState.depthFunc = Constants.GEQUAL;\r\n        } else {\r\n            this._depthCullingState.depthFunc = Constants.LEQUAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        if (enable !== this._colorWrite) {\r\n            this._colorWriteChanged = true;\r\n            this._colorWrite = enable;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets the depth culling state manager\r\n     */\r\n    public get depthCullingState(): DepthCullingState {\r\n        return this._depthCullingState;\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha state manager\r\n     */\r\n    public get alphaState(): AlphaState {\r\n        return this._alphaState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state manager\r\n     */\r\n    public get stencilState(): StencilState {\r\n        return this._stencilState;\r\n    }\r\n\r\n    /**\r\n     * Gets the stencil state composer\r\n     */\r\n    public get stencilStateComposer(): StencilStateComposer {\r\n        return this._stencilStateComposer;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\r\n     */\r\n    public readonly isNDCHalfZRange: boolean = false;\r\n\r\n    /**\r\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\r\n     */\r\n    public readonly hasOriginBottomLeft: boolean = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the exact sRGB conversions or faster approximations are used for converting to and from linear space.\r\n     */\r\n    public readonly useExactSrgbConversions: boolean;\r\n\r\n    /** @internal */\r\n    public _getGlobalDefines(defines?: { [key: string]: string }): string | undefined {\r\n        if (defines) {\r\n            if (this.isNDCHalfZRange) {\r\n                defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n            } else {\r\n                delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n            } else {\r\n                delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n            }\r\n            return;\r\n        } else {\r\n            let s = \"\";\r\n            if (this.isNDCHalfZRange) {\r\n                s += \"#define IS_NDC_HALF_ZRANGE\";\r\n            }\r\n            if (this.useReverseDepthBuffer) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n            }\r\n            if (this.useExactSrgbConversions) {\r\n                if (s) {\r\n                    s += \"\\n\";\r\n                }\r\n                s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n            }\r\n            return s;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderTargetWrapperCache = new Array<RenderTargetWrapper>();\r\n    /** @internal */\r\n    protected _compiledEffects: { [key: string]: Effect } = {};\r\n\r\n    private _rebuildInternalTextures(): void {\r\n        const currentState = this._internalTexturesCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const internalTexture of currentState) {\r\n            internalTexture._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildRenderTargetWrappers(): void {\r\n        const currentState = this._renderTargetWrapperCache.slice(); // Do a copy because the rebuild will add proxies\r\n\r\n        for (const renderTargetWrapper of currentState) {\r\n            renderTargetWrapper._rebuild();\r\n        }\r\n    }\r\n\r\n    private _rebuildEffects(): void {\r\n        for (const key in this._compiledEffects) {\r\n            const effect = <Effect>this._compiledEffects[key];\r\n\r\n            effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\r\n            effect._prepareEffect();\r\n        }\r\n\r\n        Effect.ResetCache();\r\n    }\r\n\r\n    protected _rebuildGraphicsResources(): void {\r\n        // Ensure webgl and engine states are matching\r\n        this.wipeCaches(true);\r\n\r\n        // Rebuild effects\r\n        this._rebuildEffects();\r\n        this._rebuildComputeEffects?.();\r\n\r\n        // Note:\r\n        //  The call to _rebuildBuffers must be made before the call to _rebuildInternalTextures because in the process of _rebuildBuffers the buffers used by the post process managers will be rebuilt\r\n        //  and we may need to use the post process manager of the scene during _rebuildInternalTextures (in WebGL1, non-POT textures are rescaled using a post process + post process manager of the scene)\r\n\r\n        // Rebuild buffers\r\n        this._rebuildBuffers();\r\n        // Rebuild textures\r\n        this._rebuildInternalTextures();\r\n        // Rebuild textures\r\n        this._rebuildTextures();\r\n        // Rebuild textures\r\n        this._rebuildRenderTargetWrappers();\r\n\r\n        // Reset engine states after all the buffer/textures/... have been rebuilt\r\n        this.wipeCaches(true);\r\n    }\r\n\r\n    protected _flagContextRestored(): void {\r\n        Logger.Warn(this.name + \" context successfully restored.\");\r\n        this.onContextRestoredObservable.notifyObservers(this);\r\n        this._contextWasLost = false;\r\n    }\r\n\r\n    protected _restoreEngineAfterContextLost(initEngine: () => void): void {\r\n        // Adding a timeout to avoid race condition at browser level\r\n        setTimeout(async () => {\r\n            this._clearEmptyResources();\r\n\r\n            const depthTest = this._depthCullingState.depthTest; // backup those values because the call to initEngine / wipeCaches will reset them\r\n            const depthFunc = this._depthCullingState.depthFunc;\r\n            const depthMask = this._depthCullingState.depthMask;\r\n            const stencilTest = this._stencilState.stencilTest;\r\n\r\n            // Rebuild context\r\n            await initEngine();\r\n            this._rebuildGraphicsResources();\r\n\r\n            this._depthCullingState.depthTest = depthTest;\r\n            this._depthCullingState.depthFunc = depthFunc;\r\n            this._depthCullingState.depthMask = depthMask;\r\n            this._stencilState.stencilTest = stencilTest;\r\n\r\n            this._flagContextRestored();\r\n        }, 0);\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isDisposed = false;\r\n\r\n    /** Gets a boolean indicating if the engine was disposed */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of created scenes\r\n     */\r\n    public scenes: Scene[] = [];\r\n\r\n    /** @internal */\r\n    public _virtualScenes = new Array<Scene>();\r\n\r\n    /** @internal */\r\n    public _features: EngineFeatures;\r\n\r\n    /**\r\n     * Enables or disables the snapshot rendering mode\r\n     * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\r\n     */\r\n    public get snapshotRendering(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set snapshotRendering(activate) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the snapshot rendering mode\r\n     */\r\n    public get snapshotRenderingMode(): number {\r\n        return Constants.SNAPSHOTRENDERING_STANDARD;\r\n    }\r\n\r\n    public set snapshotRenderingMode(mode: number) {}\r\n\r\n    /**\r\n     * Observable event triggered before each texture is initialized\r\n     */\r\n    public onBeforeTextureInitObservable = new Observable<Texture>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foreground\r\n     */\r\n    public renderEvenInBackground = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that cache can be kept between frames\r\n     */\r\n    public preventCacheWipeBetweenFrames = false;\r\n\r\n    /**\r\n     * Returns the string \"AbstractEngine\"\r\n     * @returns \"AbstractEngine\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AbstractEngine\";\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty texture\r\n     */\r\n    public get emptyTexture(): InternalTexture {\r\n        if (!this._emptyTexture) {\r\n            this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 3D texture\r\n     */\r\n    public get emptyTexture3D(): InternalTexture {\r\n        if (!this._emptyTexture3D) {\r\n            this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, Constants.TEXTUREFORMAT_RGBA, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n        }\r\n\r\n        return this._emptyTexture3D;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty 2D array texture\r\n     */\r\n    public get emptyTexture2DArray(): InternalTexture {\r\n        if (!this._emptyTexture2DArray) {\r\n            this._emptyTexture2DArray = this.createRawTexture2DArray(\r\n                new Uint8Array(4),\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyTexture2DArray;\r\n    }\r\n\r\n    /**\r\n     * Gets the default empty cube texture\r\n     */\r\n    public get emptyCubeTexture(): InternalTexture {\r\n        if (!this._emptyCubeTexture) {\r\n            const faceData = new Uint8Array(4);\r\n            const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];\r\n            this._emptyCubeTexture = this.createRawCubeTexture(\r\n                cubeData,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n        }\r\n\r\n        return this._emptyCubeTexture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _frameHandler: number = 0;\r\n\r\n    /** @internal */\r\n    protected _activeRenderLoops = new Array<() => void>();\r\n\r\n    /**\r\n     * Gets the list of current active render loop functions\r\n     * @returns a read only array with the current render loop functions\r\n     */\r\n    public get activeRenderLoops(): ReadonlyArray<() => void> {\r\n        return this._activeRenderLoops;\r\n    }\r\n\r\n    /**\r\n     * stop executing a render loop function and remove it from the execution array\r\n     * @param renderFunction defines the function to be removed. If not provided all functions will be removed.\r\n     */\r\n    public stopRenderLoop(renderFunction?: () => void): void {\r\n        if (!renderFunction) {\r\n            this._activeRenderLoops.length = 0;\r\n            this._cancelFrame();\r\n            return;\r\n        }\r\n\r\n        const index = this._activeRenderLoops.indexOf(renderFunction);\r\n\r\n        if (index >= 0) {\r\n            this._activeRenderLoops.splice(index, 1);\r\n            if (this._activeRenderLoops.length == 0) {\r\n                this._cancelFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _cancelFrame() {\r\n        if (this._frameHandler !== 0) {\r\n            const handlerToCancel = this._frameHandler;\r\n            this._frameHandler = 0;\r\n\r\n            if (!IsWindowObjectExist()) {\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            } else {\r\n                const { cancelAnimationFrame } = this.getHostWindow() || window;\r\n                if (typeof cancelAnimationFrame === \"function\") {\r\n                    return cancelAnimationFrame(handlerToCancel);\r\n                }\r\n            }\r\n            return clearTimeout(handlerToCancel);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _windowIsBackground = false;\r\n\r\n    /**\r\n     * Begin a new frame\r\n     */\r\n    public beginFrame(): void {\r\n        this.onBeginFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public endFrame(): void {\r\n        this._frameId++;\r\n\r\n        this.onEndFrameObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public abstract get performanceMonitor(): PerformanceMonitor;\r\n\r\n    /** @internal */\r\n    public _boundRenderFunction: any = () => this._renderLoop();\r\n\r\n    /** @internal */\r\n    public _renderLoop(): void {\r\n        // Reset the frame handler before rendering a frame to determine if a new frame has been queued.\r\n        this._frameHandler = 0;\r\n\r\n        if (!this._contextWasLost) {\r\n            let shouldRender = true;\r\n            if (this._isDisposed || (!this.renderEvenInBackground && this._windowIsBackground)) {\r\n                shouldRender = false;\r\n            }\r\n\r\n            if (shouldRender) {\r\n                // Start new frame\r\n                this.beginFrame();\r\n\r\n                // Child canvases\r\n                if (!this._renderViews()) {\r\n                    // Main frame\r\n                    this._renderFrame();\r\n                }\r\n\r\n                // Present\r\n                this.endFrame();\r\n            }\r\n        }\r\n\r\n        // The first condition prevents queuing another frame if we no longer have active render loops (e.g., if\r\n        // `stopRenderLoop` is called mid frame). The second condition prevents queuing another frame if one has\r\n        // already been queued (e.g., if `stopRenderLoop` and `runRenderLoop` is called mid frame).\r\n        if (this._activeRenderLoops.length > 0 && this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderFrame() {\r\n        for (let index = 0; index < this._activeRenderLoops.length; index++) {\r\n            const renderFunction = this._activeRenderLoops[index];\r\n\r\n            renderFunction();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _renderViews() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        return QueueNewFrame(bindedRenderFunction, requester);\r\n    }\r\n\r\n    /**\r\n     * Register and execute a render loop. The engine can have more than one render function\r\n     * @param renderFunction defines the function to continuously execute\r\n     */\r\n    public runRenderLoop(renderFunction: () => void): void {\r\n        if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._activeRenderLoops.push(renderFunction);\r\n\r\n        // On the first added function, start the render loop.\r\n        if (this._activeRenderLoops.length === 1 && this._frameHandler === 0) {\r\n            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth testing is enabled\r\n     * @returns the current state\r\n     */\r\n    public getDepthBuffer(): boolean {\r\n        return this._depthCullingState.depthTest;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._depthCullingState.depthTest = enable;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        const zOffset = this._depthCullingState.zOffset;\r\n        return this.useReverseDepthBuffer ? -zOffset : zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        const zOffsetUnits = this._depthCullingState.zOffsetUnits;\r\n        return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Gets host window\r\n     * @returns the host window object\r\n     */\r\n    public getHostWindow(): Nullable<Window> {\r\n        if (!IsWindowObjectExist()) {\r\n            return null;\r\n        }\r\n\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {\r\n            return this._renderingCanvas.ownerDocument.defaultView;\r\n        }\r\n\r\n        return window;\r\n    }\r\n\r\n    /**\r\n     * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\r\n     * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\r\n     * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\r\n     */\r\n    public get compatibilityMode() {\r\n        return this._compatibilityMode;\r\n    }\r\n\r\n    public set compatibilityMode(mode: boolean) {\r\n        // not supported in WebGL\r\n        this._compatibilityMode = true;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the engine is about to compile a shader\r\n     */\r\n    public onBeforeShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine has just compiled a shader\r\n     */\r\n    public onAfterShaderCompilationObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine begins a new frame\r\n     */\r\n    public onBeginFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Observable raised when the engine ends the current frame\r\n     */\r\n    public onEndFrameObservable = new Observable<AbstractEngine>();\r\n\r\n    protected _rebuildTextures(): void {\r\n        for (const scene of this.scenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n\r\n        for (const scene of this._virtualScenes) {\r\n            scene._rebuildTextures();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getRGBABufferInternalSizedFormat(type: number, format?: number, useSRGBBuffer?: boolean): number;\r\n\r\n    /** @internal */\r\n    public abstract _getUnpackAlignement(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number,\r\n        lod?: number\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate?: boolean, force?: boolean): boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex?: number,\r\n        lod?: number,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight?: boolean\r\n    ): void;\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public abstract readPixels(x: number, y: number, width: number, height: number, hasAlpha?: boolean, flushRenderer?: boolean): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * Force a WebGPU flush (ie. a flush of all waiting commands)\r\n     */\r\n    public abstract flushFramebuffer(): void;\r\n\r\n    /** @internal */\r\n    public abstract _currentFrameBufferIsDefaultFrameBuffer(): boolean;\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public abstract _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation?: boolean,\r\n        source?: InternalTextureSource\r\n    ): InternalTexture;\r\n\r\n    /** @internal */\r\n    public abstract applyStates(): void;\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines the lod level to bind to the frame buffer\r\n     * @param layer defines the 2d array index to bind to frame buffer to\r\n     */\r\n    public abstract bindFramebuffer(\r\n        texture: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel?: number,\r\n        layer?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public abstract updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV?: Nullable<number>, wrapR?: Nullable<number>): void;\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public abstract restoreDefaultFramebuffer(): void;\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public abstract unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n    /**Gets driver info if available */\r\n    public abstract extractDriverInfo(): string;\r\n\r\n    /**\r\n     * Bind a list of vertex buffers to the webGL context\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public abstract bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseRenderTargetWrapper(rtWrapper: RenderTargetWrapper): void {\r\n        const index = this._renderTargetWrapperCache.indexOf(rtWrapper);\r\n        if (index !== -1) {\r\n            this._renderTargetWrapperCache.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public abstract enableEffect(effect: Nullable<Effect | DrawWrapper>): void;\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public abstract setState(\r\n        culling: boolean,\r\n        zOffset?: number,\r\n        force?: boolean,\r\n        reverseSide?: boolean,\r\n        cullBackFaces?: boolean,\r\n        stencil?: IStencilState,\r\n        zOffsetUnits?: number\r\n    ): void;\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public abstract createMaterialContext(): IMaterialContext | undefined;\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public abstract createDrawContext(): IDrawContext | undefined;\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public abstract createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: EffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage?: ShaderLanguage\r\n    ): Effect;\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public abstract clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean): void;\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public abstract get needPOTTextures(): boolean;\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param _updatable defines if the index buffer must be updatable\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     * @returns a new buffer\r\n     */\r\n    public abstract createIndexBuffer(indices: IndicesArray, _updatable?: boolean, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public abstract drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;\r\n\r\n    /**\r\n     * Force the engine to release all cached effects.\r\n     * This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public abstract releaseEffects(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _viewport(x: number, y: number, width: number, height: number): void;\r\n\r\n    /**\r\n     * Gets the current viewport\r\n     */\r\n    public get currentViewport(): Nullable<IViewportLike> {\r\n        return this._cachedViewport;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        const width = requiredWidth || this.getRenderWidth();\r\n        const height = requiredHeight || this.getRenderHeight();\r\n        const x = viewport.x || 0;\r\n        const y = viewport.y || 0;\r\n\r\n        this._cachedViewport = viewport;\r\n\r\n        this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public abstract updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps?: boolean): void;\r\n\r\n    /**\r\n     * Sets an array of texture to the webGL context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param uniform defines the associated uniform location\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public abstract setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: ThinTexture[], name: string): void;\r\n\r\n    /** @internal */\r\n    public _transformTextureUrl: Nullable<(url: string) => string> = null;\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public abstract unbindInstanceAttributes(): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getUseSRGBBuffer(useSRGBBuffer: boolean, noMipmap: boolean): boolean;\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        return document.createElement(\"img\");\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the current engine\r\n     */\r\n    public get description(): string {\r\n        let description = this.name + this.version;\r\n\r\n        if (this._caps.parallelShaderCompile) {\r\n            description += \" - Parallel shader compilation\";\r\n        }\r\n\r\n        return description;\r\n    }\r\n\r\n    protected _createTextureBase(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        prepareTexture: PrepareTextureFunction,\r\n        prepareTextureProcess: PrepareTextureProcessFunction,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        if (texture !== fallback) {\r\n            texture.label = url.substring(0, 60); // default label, can be overriden by the caller\r\n        }\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        if (originalUrl !== url) {\r\n            texture._originalUrl = originalUrl;\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        let loader: Nullable<IInternalTextureLoader> = null;\r\n\r\n        // Remove query string\r\n        const queryStringIndex = extension.indexOf(\"?\");\r\n\r\n        if (queryStringIndex > -1) {\r\n            extension = extension.split(\"?\")[0];\r\n        }\r\n\r\n        for (const availableLoader of AbstractEngine._TextureLoaders) {\r\n            if (availableLoader.canLoad(extension, mimeType)) {\r\n                loader = availableLoader;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture && url !== EngineStore.FallbackTexture) {\r\n                    this._createTextureBase(\r\n                        EngineStore.FallbackTexture,\r\n                        noMipmap,\r\n                        texture.invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        null,\r\n                        onError,\r\n                        prepareTexture,\r\n                        prepareTextureProcess,\r\n                        buffer,\r\n                        texture\r\n                    );\r\n                }\r\n\r\n                message = (message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\");\r\n                texture.onErrorObservable.notifyObservers({ message, exception });\r\n                if (onError) {\r\n                    onError(message, exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this._createTextureBase(\r\n                    originalUrl,\r\n                    noMipmap,\r\n                    texture.invertY,\r\n                    scene,\r\n                    samplingMode,\r\n                    onLoad,\r\n                    onError,\r\n                    prepareTexture,\r\n                    prepareTextureProcess,\r\n                    buffer,\r\n                    texture,\r\n                    format,\r\n                    forcedExtension,\r\n                    mimeType,\r\n                    loaderOptions,\r\n                    useSRGBBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loader) {\r\n            const callback = (data: ArrayBufferView) => {\r\n                loader!.loadData(\r\n                    data,\r\n                    texture,\r\n                    (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, loadFailed) => {\r\n                        if (loadFailed) {\r\n                            onInternalError(\"TextureLoader failed to load data\");\r\n                        } else {\r\n                            prepareTexture(\r\n                                texture,\r\n                                extension,\r\n                                scene,\r\n                                { width, height },\r\n                                texture.invertY,\r\n                                !loadMipmap,\r\n                                isCompressed,\r\n                                () => {\r\n                                    done();\r\n                                    return false;\r\n                                },\r\n                                samplingMode\r\n                            );\r\n                        }\r\n                    },\r\n                    loaderOptions\r\n                );\r\n            };\r\n\r\n            if (!buffer) {\r\n                this._loadFile(\r\n                    url,\r\n                    (data) => callback(new Uint8Array(data as ArrayBuffer)),\r\n                    undefined,\r\n                    scene ? scene.offlineProvider : undefined,\r\n                    true,\r\n                    (request?: IWebRequest, exception?: any) => {\r\n                        onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                    }\r\n                );\r\n            } else {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    callback(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    callback(buffer);\r\n                } else {\r\n                    if (onError) {\r\n                        onError(\"Unable to load: only ArrayBuffer or ArrayBufferView is supported\", null);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n                if (fromBlob && !this._doNotHandleContextLost) {\r\n                    // We need to store the image if we need to rebuild the texture\r\n                    // in case of a webgl context lost\r\n                    texture._buffer = img;\r\n                }\r\n\r\n                prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcess, samplingMode);\r\n            };\r\n            // According to the WebGL spec section 6.10, ImageBitmaps must be inverted on creation.\r\n            // So, we pass imageOrientation to _FileToolsLoadImage() as it may create an ImageBitmap.\r\n\r\n            if (!fromData || isBase64) {\r\n                if (buffer && (typeof (<HTMLImageElement>buffer).decoding === \"string\" || (<ImageBitmap>buffer).close)) {\r\n                    onload(<HTMLImageElement>buffer);\r\n                } else {\r\n                    AbstractEngine._FileToolsLoadImage(\r\n                        url || \"\",\r\n                        onload,\r\n                        onInternalError,\r\n                        scene ? scene.offlineProvider : null,\r\n                        mimeType,\r\n                        texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined\r\n                    );\r\n                }\r\n            } else if (typeof buffer === \"string\" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {\r\n                AbstractEngine._FileToolsLoadImage(\r\n                    buffer,\r\n                    onload,\r\n                    onInternalError,\r\n                    scene ? scene.offlineProvider : null,\r\n                    mimeType,\r\n                    texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: \"flipY\" } : undefined\r\n                );\r\n            } else if (buffer) {\r\n                onload(buffer);\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public abstract createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext;\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public abstract inlineShaderCode(code: string): string;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     */\r\n    public abstract get supportsUniformBuffers(): boolean;\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public abstract get version(): number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseEffect(effect: Effect): void;\r\n\r\n    /**\r\n     * Bind a buffer to the current draw context\r\n     * @param buffer defines the buffer to bind\r\n     * @param _location not used in WebGPU\r\n     * @param name Name of the uniform variable to bind\r\n     */\r\n    public abstract bindUniformBufferBase(buffer: DataBuffer, _location: number, name: string): void;\r\n\r\n    /**\r\n     * Bind a specific block at a given index in a specific shader program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param blockName defines the block name\r\n     * @param index defines the index where to bind the block\r\n     */\r\n    public abstract bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n\r\n    /** @internal */\r\n    public _uniformBuffers = new Array<UniformBuffer>();\r\n    /** @internal */\r\n    public _storageBuffers = new Array<StorageBuffer>();\r\n    protected _rebuildBuffers(): void {\r\n        // Uniforms\r\n        for (const uniformBuffer of this._uniformBuffers) {\r\n            uniformBuffer._rebuildAfterContextLost();\r\n        }\r\n    }\r\n\r\n    protected _highPrecisionShadersAllowed = true;\r\n    /** @internal */\r\n    public get _shouldUseHighPrecisionShader(): boolean {\r\n        return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext>;\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {\r\n            return this._renderingCanvas.ownerDocument;\r\n        }\r\n\r\n        return IsDocumentAvailable() ? document : null;\r\n    }\r\n\r\n    // Lost context\r\n    /**\r\n     * Observable signaled when a context lost event is raised\r\n     */\r\n    public onContextLostObservable = new Observable<AbstractEngine>();\r\n    /**\r\n     * Observable signaled when a context restored event is raised\r\n     */\r\n    public onContextRestoredObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Gets the list of loaded textures\r\n     * @returns an array containing all loaded textures\r\n     */\r\n    public getLoadedTexturesCache(): InternalTexture[] {\r\n        return this._internalTexturesCache;\r\n    }\r\n\r\n    /**\r\n     * Clears the list of texture accessible through engine.\r\n     * This can help preventing texture load conflict due to name collision.\r\n     */\r\n    public clearInternalTexturesCache() {\r\n        this._internalTexturesCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseTexture(texture: InternalTexture): void;\r\n\r\n    /**\r\n     * Gets the object containing all engine capabilities\r\n     * @returns the EngineCapabilities object\r\n     */\r\n    public getCaps(): EngineCapabilities {\r\n        return this._caps;\r\n    }\r\n\r\n    /**\r\n     * Reset the texture cache to empty state\r\n     */\r\n    public resetTextureCache() {\r\n        for (const key in this._boundTexturesCache) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {\r\n                continue;\r\n            }\r\n            this._boundTexturesCache[key] = null;\r\n        }\r\n\r\n        this._currentTextureChannel = -1;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _name = \"\";\r\n\r\n    /**\r\n     * Gets or sets the name of the engine\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the current npm package of the sdk\r\n     */\r\n    // Not mixed with Version for tooling purpose.\r\n    public static get NpmPackage(): string {\r\n        return \"babylonjs@7.13.1\";\r\n    }\r\n\r\n    /**\r\n     * Returns the current version of the framework\r\n     */\r\n    public static get Version(): string {\r\n        return \"7.13.1\";\r\n    }\r\n\r\n    /**\r\n     * The time (in milliseconds elapsed since the current page has been loaded) when the engine was initialized\r\n     */\r\n    public readonly startTime: number;\r\n\r\n    /** @internal */\r\n    protected _audioContext: Nullable<AudioContext>;\r\n    /** @internal */\r\n    protected _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>;\r\n    /**\r\n     * Gets the HTML canvas attached with the current webGL context\r\n     * @returns a HTML canvas\r\n     */\r\n    public getRenderingCanvas(): Nullable<HTMLCanvasElement> {\r\n        return this._renderingCanvas;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio context specified in engine initialization options\r\n     * @returns an Audio Context\r\n     */\r\n    public getAudioContext(): Nullable<AudioContext> {\r\n        return this._audioContext;\r\n    }\r\n\r\n    /**\r\n     * Gets the audio destination specified in engine initialization options\r\n     * @returns an audio destination node\r\n     */\r\n    public getAudioDestination(): Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> {\r\n        return this._audioDestination;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the engine has been created with the premultipliedAlpha option on or not.\r\n     */\r\n    public premultipliedAlpha: boolean = true;\r\n\r\n    /**\r\n     * If set to true zooming in and out in the browser will rescale the hardware-scaling correctly.\r\n     */\r\n    public adaptToDeviceRatio: boolean = false;\r\n\r\n    /** @internal */\r\n    protected _lastDevicePixelRatio: number = 1.0;\r\n\r\n    /** @internal */\r\n    public _hardwareScalingLevel: number;\r\n\r\n    /**\r\n     * Defines the hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @param level defines the level to use\r\n     */\r\n    public setHardwareScalingLevel(level: number): void {\r\n        this._hardwareScalingLevel = level;\r\n        this.resize();\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return this._hardwareScalingLevel;\r\n    }\r\n\r\n    /** @internal */\r\n    public _doNotHandleContextLost = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#handling-webgl-context-lost\r\n     */\r\n    public get doNotHandleContextLost(): boolean {\r\n        return this._doNotHandleContextLost;\r\n    }\r\n\r\n    public set doNotHandleContextLost(value: boolean) {\r\n        this._doNotHandleContextLost = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _isStencilEnable: boolean;\r\n\r\n    /**\r\n     * Returns true if the stencil buffer has been enabled through the creation option of the context.\r\n     */\r\n    public get isStencilEnable(): boolean {\r\n        return this._isStencilEnable;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _creationOptions: AbstractEngineOptions;\r\n\r\n    /**\r\n     * Gets the options used for engine creation\r\n     * @returns EngineOptions object\r\n     */\r\n    public getCreationOptions() {\r\n        return this._creationOptions;\r\n    }\r\n\r\n    /**\r\n     * Creates a new engine\r\n     * @param antialias defines whether anti-aliasing should be enabled. If undefined, it means that the underlying engine is free to enable it or not\r\n     * @param options defines further options to be sent to the creation context\r\n     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    constructor(antialias: boolean | undefined, options: AbstractEngineOptions, adaptToDeviceRatio?: boolean) {\r\n        EngineStore.Instances.push(this);\r\n        this.startTime = PrecisionDate.Now;\r\n\r\n        this._stencilStateComposer.stencilGlobal = this._stencilState;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        if (IsNavigatorAvailable() && navigator.userAgent) {\r\n            // Detect if we are running on a faulty buggy OS.\r\n            this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);\r\n\r\n            // Detect if we are running on a faulty buggy desktop OS.\r\n            this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n        }\r\n\r\n        // Save this off for use in resize().\r\n        this.adaptToDeviceRatio = adaptToDeviceRatio ?? false;\r\n\r\n        options.antialias = antialias ?? options.antialias;\r\n        options.deterministicLockstep = options.deterministicLockstep ?? false;\r\n        options.lockstepMaxSteps = options.lockstepMaxSteps ?? 4;\r\n        options.timeStep = options.timeStep ?? 1 / 60;\r\n        options.audioEngine = options.audioEngine ?? true;\r\n        options.stencil = options.stencil ?? true;\r\n\r\n        this._audioContext = options.audioEngineOptions?.audioContext ?? null;\r\n        this._audioDestination = options.audioEngineOptions?.audioDestination ?? null;\r\n        this.premultipliedAlpha = options.premultipliedAlpha ?? true;\r\n        this._doNotHandleContextLost = !!options.doNotHandleContextLost;\r\n        this._isStencilEnable = options.stencil ? true : false;\r\n        this.useExactSrgbConversions = options.useExactSrgbConversions ?? false;\r\n\r\n        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n\r\n        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;\r\n        // Viewport\r\n        adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;\r\n        this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, devicePixelRatio) : 1.0;\r\n        this._lastDevicePixelRatio = devicePixelRatio;\r\n\r\n        this._creationOptions = options;\r\n    }\r\n\r\n    /**\r\n     * Resize the view according to the canvas' size\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     */\r\n    public resize(forceSetSize = false): void {\r\n        let width: number;\r\n        let height: number;\r\n\r\n        // Re-query hardware scaling level to handle zoomed-in resizing.\r\n        if (this.adaptToDeviceRatio) {\r\n            const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1.0 : 1.0;\r\n            const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;\r\n            this._lastDevicePixelRatio = devicePixelRatio;\r\n            this._hardwareScalingLevel *= changeRatio;\r\n        }\r\n\r\n        if (IsWindowObjectExist() && IsDocumentAvailable()) {\r\n            // make sure it is a Node object, and is a part of the document.\r\n            if (this._renderingCanvas) {\r\n                const boundingRect = this._renderingCanvas.getBoundingClientRect\r\n                    ? this._renderingCanvas.getBoundingClientRect()\r\n                    : {\r\n                          // fallback to last solution in case the function doesn't exist\r\n                          width: this._renderingCanvas.width * this._hardwareScalingLevel,\r\n                          height: this._renderingCanvas.height * this._hardwareScalingLevel,\r\n                      };\r\n                width = this._renderingCanvas.clientWidth || boundingRect.width || this._renderingCanvas.width || 100;\r\n                height = this._renderingCanvas.clientHeight || boundingRect.height || this._renderingCanvas.height || 100;\r\n            } else {\r\n                width = window.innerWidth;\r\n                height = window.innerHeight;\r\n            }\r\n        } else {\r\n            width = this._renderingCanvas ? this._renderingCanvas.width : 100;\r\n            height = this._renderingCanvas ? this._renderingCanvas.height : 100;\r\n        }\r\n\r\n        this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);\r\n    }\r\n\r\n    /**\r\n     * Force a specific size of the canvas\r\n     * @param width defines the new canvas' width\r\n     * @param height defines the new canvas' height\r\n     * @param forceSetSize true to force setting the sizes of the underlying canvas\r\n     * @returns true if the size was changed\r\n     */\r\n    public setSize(width: number, height: number, forceSetSize = false): boolean {\r\n        if (!this._renderingCanvas) {\r\n            return false;\r\n        }\r\n\r\n        width = width | 0;\r\n        height = height | 0;\r\n\r\n        if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {\r\n            return false;\r\n        }\r\n\r\n        this._renderingCanvas.width = width;\r\n        this._renderingCanvas.height = height;\r\n\r\n        if (this.scenes) {\r\n            for (let index = 0; index < this.scenes.length; index++) {\r\n                const scene = this.scenes[index];\r\n\r\n                for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\r\n                    const cam = scene.cameras[camIndex];\r\n\r\n                    cam._currentRenderId = 0;\r\n                }\r\n            }\r\n\r\n            if (this.onResizeObservable.hasObservers()) {\r\n                this.onResizeObservable.notifyObservers(this);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public abstract _releaseBuffer(buffer: DataBuffer): boolean;\r\n\r\n    /**\r\n     * Create a dynamic uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Create an uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param elements defines the content of the uniform buffer\r\n     * @param label defines a name for the buffer (for debugging purpose)\r\n     * @returns the webGL uniform buffer\r\n     */\r\n    public abstract createUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update an existing uniform buffer\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     * @param uniformBuffer defines the target uniform buffer\r\n     * @param elements defines the content to update\r\n     * @param offset defines the offset in the uniform buffer where update should start\r\n     * @param count defines the size of the data to update\r\n     */\r\n    public abstract updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public abstract createDynamicVertexBuffer(data: DataArray | number, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public abstract createVertexBuffer(data: DataArray | number, _updatable?: boolean, _label?: string): DataBuffer;\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public abstract updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number): void;\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public abstract createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode?: number,\r\n        onLoad?: Nullable<(texture: InternalTexture) => void>,\r\n        onError?: Nullable<(message: string, exception: any) => void>,\r\n        buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>,\r\n        fallback?: Nullable<InternalTexture>,\r\n        format?: Nullable<number>,\r\n        forcedExtension?: Nullable<string>,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture;\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a raw texture\r\n     * @param data defines the data to store in the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param format defines the format of the data\r\n     * @param generateMipMaps defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param compression defines the compression used (null by default)\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the raw texture inside an InternalTexture\r\n     */\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        type?: number,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw cube texture\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public createRawCubeTexture(\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number,\r\n        type: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw 3D texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the depth of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 3D texture (stored in an InternalTexture)\r\n     */\r\n    public createRawTexture3D(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Creates a new raw 2D array texture\r\n     * @param data defines the data used to create the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the format of the texture\r\n     * @param generateMipMaps defines if the engine must generate mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compressed used (can be null)\r\n     * @param textureType defines the compressed used (can be null)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n     */\r\n    public createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression?: Nullable<string>,\r\n        textureType?: number,\r\n        creationFlags?: number\r\n    ): InternalTexture {\r\n        throw _WarnImport(\"engine.rawTexture\");\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if back faces must be culled. If false, front faces are culled instead (true by default)\r\n     * If non null, this takes precedence over the value from the material\r\n     */\r\n    public cullBackFaces: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public abstract getRenderWidth(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public abstract getRenderHeight(useScreen?: boolean): number;\r\n\r\n    /**\r\n     * Shared initialization across engines types.\r\n     * @param canvas The canvas associated with this instance of the engine.\r\n     */\r\n    protected _sharedInit(canvas: HTMLCanvasElement) {\r\n        this._renderingCanvas = canvas;\r\n    }\r\n\r\n    private _checkForMobile: () => void;\r\n\r\n    protected _setupMobileChecks(): void {\r\n        if (!(navigator && navigator.userAgent)) {\r\n            return;\r\n        }\r\n\r\n        // Function to check if running on mobile device\r\n        this._checkForMobile = () => {\r\n            const currentUA = navigator.userAgent;\r\n            this.hostInformation.isMobile =\r\n                currentUA.indexOf(\"Mobile\") !== -1 ||\r\n                // Needed for iOS 13+ detection on iPad (inspired by solution from https://stackoverflow.com/questions/9038625/detect-if-device-is-ios)\r\n                (currentUA.indexOf(\"Mac\") !== -1 && IsDocumentAvailable() && \"ontouchend\" in document);\r\n        };\r\n\r\n        // Set initial isMobile value\r\n        this._checkForMobile();\r\n\r\n        // Set up event listener to check when window is resized (used to get emulator activation to work properly)\r\n        if (IsWindowObjectExist()) {\r\n            window.addEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    /** @internal */\r\n    public static _RenderPassIdCounter = 0;\r\n\r\n    /** @internal */\r\n    public _renderPassNames: string[] = [\"main\"];\r\n\r\n    /** @internal */\r\n    public abstract _createHardwareTexture(): HardwareTextureWrapper;\r\n\r\n    /**\r\n     * creates and returns a new video element\r\n     * @param constraints video constraints\r\n     * @returns video element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        return document.createElement(\"video\");\r\n    }\r\n\r\n    // FPS\r\n    protected _fps = 60;\r\n    protected _deltaTime = 0;\r\n\r\n    /** @internal */\r\n    public _drawCalls: PerfCounter;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _reportDrawCall(numDrawCalls = 1) {\r\n        this._drawCalls?.addCount(numDrawCalls, false);\r\n    }\r\n    /**\r\n     * Gets the current framerate\r\n     * @returns a number representing the framerate\r\n     */\r\n    public getFps(): number {\r\n        return this._fps;\r\n    }\r\n\r\n    /**\r\n     * Gets the time spent between current and previous frame\r\n     * @returns a number representing the delta time in ms\r\n     */\r\n    public getDeltaTime(): number {\r\n        return this._deltaTime;\r\n    }\r\n\r\n    // Deterministic lockstepMaxSteps\r\n    /** @internal */\r\n    public _deterministicLockstep: boolean = false;\r\n    /** @internal */\r\n    public _lockstepMaxSteps: number = 4;\r\n    /** @internal */\r\n    public _timeStep: number = 1 / 60;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Returns the time in ms between steps when using deterministic lock step.\r\n     * @returns time step in (ms)\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep * 1000;\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        throw new Error(\"createImageBitmapFromSource is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return createImageBitmap(image, options);\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     */\r\n    public resizeImageBitmap(image: HTMLImageElement | ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        throw new Error(\"resizeImageBitmap is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     */\r\n    public abstract getError(): number;\r\n\r\n    /**\r\n     * Get Font size information\r\n     * @param font font name\r\n     */\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        throw new Error(\"getFontOffset is not implemented\");\r\n    }\r\n\r\n    protected static _CreateCanvas(width: number, height: number): ICanvas {\r\n        if (typeof document === \"undefined\") {\r\n            return <ICanvas>(<any>new OffscreenCanvas(width, height));\r\n        }\r\n        const canvas = <ICanvas>(<any>document.createElement(\"canvas\"));\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create a canvas. This method is overridden by other engines\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        return AbstractEngine._CreateCanvas(width, height);\r\n    }\r\n\r\n    /**\r\n     * Loads an image as an HTMLImageElement.\r\n     * @param input url string, ArrayBuffer, or Blob to load\r\n     * @param onLoad callback called when the image successfully loads\r\n     * @param onError callback called when the image fails to load\r\n     * @param offlineProvider offline provider for caching\r\n     * @param mimeType optional mime type\r\n     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\r\n     * @returns the HTMLImageElement of the loaded image\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadImage(\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions\r\n    ): Nullable<HTMLImageElement> {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (data: any) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: IWebRequest, exception?: any) => void\r\n    ): IFileRequest {\r\n        const request = _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add(() => {\r\n            const index = this._activeRequests.indexOf(request);\r\n            if (index !== -1) {\r\n                this._activeRequests.splice(index, 1);\r\n            }\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        if (EngineFunctionContext.loadFile) {\r\n            return EngineFunctionContext.loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        }\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the engine is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<AbstractEngine>();\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.releaseEffects();\r\n\r\n        this._isDisposed = true;\r\n        this.stopRenderLoop();\r\n\r\n        // Empty texture\r\n        if (this._emptyTexture) {\r\n            this._releaseTexture(this._emptyTexture);\r\n            this._emptyTexture = null;\r\n        }\r\n        if (this._emptyCubeTexture) {\r\n            this._releaseTexture(this._emptyCubeTexture);\r\n            this._emptyCubeTexture = null;\r\n        }\r\n\r\n        this._renderingCanvas = null;\r\n\r\n        // Clear observables\r\n        if (this.onBeforeTextureInitObservable) {\r\n            this.onBeforeTextureInitObservable.clear();\r\n        }\r\n\r\n        // Release postProcesses\r\n        while (this.postProcesses.length) {\r\n            this.postProcesses[0].dispose();\r\n        }\r\n\r\n        // Release scenes\r\n        while (this.scenes.length) {\r\n            this.scenes[0].dispose();\r\n        }\r\n\r\n        while (this._virtualScenes.length) {\r\n            this._virtualScenes[0].dispose();\r\n        }\r\n\r\n        // Release effects\r\n        this.releaseComputeEffects?.();\r\n\r\n        Effect.ResetCache();\r\n\r\n        // Abort active requests\r\n        for (const request of this._activeRequests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._boundRenderFunction = null;\r\n\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.onResizeObservable.clear();\r\n        this.onCanvasBlurObservable.clear();\r\n        this.onCanvasFocusObservable.clear();\r\n        this.onCanvasPointerOutObservable.clear();\r\n        this.onNewSceneAddedObservable.clear();\r\n\r\n        if (IsWindowObjectExist()) {\r\n            window.removeEventListener(\"resize\", this._checkForMobile);\r\n        }\r\n\r\n        // Remove from Instances\r\n        const index = EngineStore.Instances.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            EngineStore.Instances.splice(index, 1);\r\n        }\r\n\r\n        // no more engines left in the engine store? Notify!\r\n        if (!EngineStore.Instances.length) {\r\n            EngineStore.OnEnginesDisposedObservable.notifyObservers(this);\r\n            EngineStore.OnEnginesDisposedObservable.clear();\r\n        }\r\n\r\n        // Observables\r\n        this.onBeginFrameObservable.clear();\r\n        this.onEndFrameObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Method called to create the default rescale post process on each engine.\r\n     */\r\n    public static _RescalePostProcessFactory: Nullable<(engine: AbstractEngine) => PostProcess> = null;\r\n\r\n    /**\r\n     * Method called to create the default loading screen.\r\n     * This can be overridden in your own app.\r\n     * @param canvas The rendering canvas element\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static DefaultLoadingScreenFactory(canvas: HTMLCanvasElement): ILoadingScreen {\r\n        throw _WarnImport(\"LoadingScreen\");\r\n    }\r\n\r\n    /**\r\n     * Gets the audio engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static audioEngine: Nullable<IAudioEngine>;\r\n\r\n    /**\r\n     * Default AudioEngine factory responsible of creating the Audio Engine.\r\n     * By default, this will create a BabylonJS Audio Engine if the workload has been embedded.\r\n     */\r\n    public static AudioEngineFactory: (\r\n        hostElement: Nullable<HTMLElement>,\r\n        audioContext: Nullable<AudioContext>,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n    ) => IAudioEngine;\r\n\r\n    /**\r\n     * Default offline support factory responsible of creating a tool used to store data locally.\r\n     * By default, this will create a Database object if the workload has been embedded.\r\n     */\r\n    public static OfflineProviderFactory: (urlToScene: string, callbackManifestChecked: (checked: boolean) => any, disableManifestCheck: boolean) => IOfflineProvider;\r\n}\r\n", "import { IsWindowObjectExist } from \"./domManagement\";\r\n\r\n/**\r\n * Class used to provide helper for timing\r\n */\r\nexport class TimingTools {\r\n    /**\r\n     * Polyfill for setImmediate\r\n     * @param action defines the action to execute after the current execution block\r\n     */\r\n    public static SetImmediate(action: () => void) {\r\n        if (IsWindowObjectExist() && window.setImmediate) {\r\n            window.setImmediate(action);\r\n        } else {\r\n            setTimeout(action, 1);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { WebRequest } from \"./webRequest\";\r\nimport { IsWindowObjectExist } from \"./domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"./fileRequest\";\r\nimport { Observable } from \"./observable\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport { RetryStrategy } from \"./retryStrategy\";\r\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error\";\r\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools\";\r\nimport { _functionContainer } from \"../Engines/Processors/shaderProcessor\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Logger } from \"./logger\";\r\nimport { TimingTools } from \"./timingTools\";\r\nimport type { INative } from \"../Engines/Native/nativeInterfaces\";\r\nimport { EngineFunctionContext } from \"core/Engines/abstractEngine.functions\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\r\ndeclare const _native: INative;\r\n\r\n/** @ignore */\r\nexport class LoadFileError extends RuntimeError {\r\n    public request?: WebRequest;\r\n    public file?: File;\r\n\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param object defines the optional web request\r\n     */\r\n    constructor(message: string, object?: WebRequest | File) {\r\n        super(message, ErrorCodes.LoadFileError);\r\n\r\n        this.name = \"LoadFileError\";\r\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\r\n\r\n        if (object instanceof WebRequest) {\r\n            this.request = object;\r\n        } else {\r\n            this.file = object;\r\n        }\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class RequestFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param request defines the optional web request\r\n     */\r\n    constructor(\r\n        message: string,\r\n        public request: WebRequest\r\n    ) {\r\n        super(message, ErrorCodes.RequestFileError);\r\n        this.name = \"RequestFileError\";\r\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class ReadFileError extends RuntimeError {\r\n    /**\r\n     * Creates a new ReadFileError\r\n     * @param message defines the message of the error\r\n     * @param file defines the optional file\r\n     */\r\n    constructor(\r\n        message: string,\r\n        public file: File\r\n    ) {\r\n        super(message, ErrorCodes.ReadFileError);\r\n        this.name = \"ReadFileError\";\r\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes unwanted characters from an url\r\n * @param url defines the url to clean\r\n * @returns the cleaned url\r\n */\r\nconst CleanUrl = (url: string): string => {\r\n    url = url.replace(/#/gm, \"%23\");\r\n    return url;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const FileToolsOptions: {\r\n    DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;\r\n    BaseUrl: string;\r\n    CorsBehavior: string | ((url: string | string[]) => string);\r\n    PreprocessUrl: (url: string) => string;\r\n    ScriptBaseUrl: string;\r\n    ScriptPreprocessUrl: (url: string) => string;\r\n    CleanUrl: (url: string) => string;\r\n} = {\r\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\r\n     * When defining this function, return the wait time before trying again or return -1 to\r\n     * stop retrying and error out.\r\n     */\r\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\r\n    BaseUrl: \"\",\r\n\r\n    /**\r\n     * Default behaviour for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\r\n    CorsBehavior: \"anonymous\",\r\n\r\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     * @param url\r\n     * @returns the processed url\r\n     */\r\n    PreprocessUrl: (url: string) => url,\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load scripts\r\n     * Used for both JS and WASM\r\n     */\r\n    ScriptBaseUrl: \"\",\r\n    /**\r\n     * Gets or sets a function used to pre-process script url before using them to load.\r\n     * Used for both JS and WASM\r\n     * @param url defines the url to process\r\n     * @returns the processed url\r\n     */\r\n    ScriptPreprocessUrl: (url: string) => url,\r\n\r\n    /**\r\n     * Gets or sets a function used to clean the url before using it to load assets\r\n     * @param url defines the url to clean\r\n     * @returns the cleaned url\r\n     */\r\n    CleanUrl,\r\n};\r\n\r\n/**\r\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n * @param url define the url we are trying\r\n * @param element define the dom element where to configure the cors policy\r\n * @internal\r\n */\r\nexport const SetCorsBehavior = (url: string | string[], element: { crossOrigin: string | null }): void => {\r\n    if (url && url.indexOf(\"data:\") === 0) {\r\n        return;\r\n    }\r\n\r\n    if (FileToolsOptions.CorsBehavior) {\r\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\r\n            element.crossOrigin = <string>FileToolsOptions.CorsBehavior;\r\n        } else {\r\n            const result = FileToolsOptions.CorsBehavior(url);\r\n            if (result) {\r\n                element.crossOrigin = result;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Loads an image as an HTMLImageElement.\r\n * @param input url string, ArrayBuffer, or Blob to load\r\n * @param onLoad callback called when the image successfully loads\r\n * @param onError callback called when the image fails to load\r\n * @param offlineProvider offline provider for caching\r\n * @param mimeType optional mime type\r\n * @param imageBitmapOptions\r\n * @returns the HTMLImageElement of the loaded image\r\n * @internal\r\n */\r\nexport const LoadImage = (\r\n    input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n    onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n    onError: (message?: string, exception?: any) => void,\r\n    offlineProvider: Nullable<IOfflineProvider>,\r\n    mimeType: string = \"\",\r\n    imageBitmapOptions?: ImageBitmapOptions\r\n): Nullable<HTMLImageElement> => {\r\n    const engine = EngineStore.LastCreatedEngine;\r\n    if (typeof HTMLImageElement === \"undefined\" && !engine?._features.forceBitmapOverHTMLImageElement) {\r\n        onError(\"LoadImage is only supported in web or BabylonNative environments.\");\r\n        return null;\r\n    }\r\n\r\n    let url: string;\r\n    let usingObjectURL = false;\r\n\r\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\r\n        if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\r\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\r\n            usingObjectURL = true;\r\n        } else {\r\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\r\n        }\r\n    } else if (input instanceof Blob) {\r\n        url = URL.createObjectURL(input);\r\n        usingObjectURL = true;\r\n    } else {\r\n        url = FileToolsOptions.CleanUrl(input);\r\n        url = FileToolsOptions.PreprocessUrl(input);\r\n    }\r\n\r\n    const onErrorHandler = (exception: any) => {\r\n        if (onError) {\r\n            const inputText = url || input.toString();\r\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\r\n        }\r\n    };\r\n\r\n    if (engine?._features.forceBitmapOverHTMLImageElement) {\r\n        LoadFile(\r\n            url,\r\n            (data) => {\r\n                engine!\r\n                    .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\r\n                    .then((imgBmp) => {\r\n                        onLoad(imgBmp);\r\n                        if (usingObjectURL) {\r\n                            URL.revokeObjectURL(url);\r\n                        }\r\n                    })\r\n                    .catch((reason) => {\r\n                        if (onError) {\r\n                            onError(\"Error while trying to load image: \" + input, reason);\r\n                        }\r\n                    });\r\n            },\r\n            undefined,\r\n            offlineProvider || undefined,\r\n            true,\r\n            (request, exception) => {\r\n                onErrorHandler(exception);\r\n            }\r\n        );\r\n\r\n        return null;\r\n    }\r\n\r\n    const img = new Image();\r\n    SetCorsBehavior(url, img);\r\n\r\n    const handlersList: { target: any; name: string; handler: any }[] = [];\r\n\r\n    const loadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.addEventListener(handler.name, handler.handler);\r\n        });\r\n    };\r\n\r\n    const unloadHandlersList = () => {\r\n        handlersList.forEach((handler) => {\r\n            handler.target.removeEventListener(handler.name, handler.handler);\r\n        });\r\n        handlersList.length = 0;\r\n    };\r\n\r\n    const loadHandler = () => {\r\n        unloadHandlersList();\r\n\r\n        onLoad(img);\r\n\r\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\r\n        // certain scenarios (e.g. when hosted in vscode).\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const errorHandler = (err: any) => {\r\n        unloadHandlersList();\r\n\r\n        onErrorHandler(err);\r\n\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n    };\r\n\r\n    const cspHandler = (err: any) => {\r\n        if (err.blockedURI !== img.src) {\r\n            return;\r\n        }\r\n\r\n        unloadHandlersList();\r\n        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\r\n\r\n        EngineStore.UseFallbackTexture = false;\r\n        onErrorHandler(cspException);\r\n        if (usingObjectURL && img.src) {\r\n            URL.revokeObjectURL(img.src);\r\n        }\r\n        img.src = \"\";\r\n    };\r\n\r\n    handlersList.push({ target: img, name: \"load\", handler: loadHandler });\r\n    handlersList.push({ target: img, name: \"error\", handler: errorHandler });\r\n    handlersList.push({ target: document, name: \"securitypolicyviolation\", handler: cspHandler });\r\n\r\n    loadHandlersList();\r\n\r\n    const fromBlob = url.substring(0, 5) === \"blob:\";\r\n    const fromData = url.substring(0, 5) === \"data:\";\r\n    const noOfflineSupport = () => {\r\n        if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {\r\n            img.src = url;\r\n        } else {\r\n            LoadFile(\r\n                url,\r\n                (data, _, contentType) => {\r\n                    const type = !mimeType && contentType ? contentType : mimeType;\r\n                    const blob = new Blob([data], { type });\r\n                    const url = URL.createObjectURL(blob);\r\n                    usingObjectURL = true;\r\n                    img.src = url;\r\n                },\r\n                undefined,\r\n                offlineProvider || undefined,\r\n                true,\r\n                (_request, exception) => {\r\n                    onErrorHandler(exception);\r\n                }\r\n            );\r\n        }\r\n    };\r\n\r\n    const loadFromOfflineSupport = () => {\r\n        if (offlineProvider) {\r\n            offlineProvider.loadImage(url, img);\r\n        }\r\n    };\r\n\r\n    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        if (url.indexOf(\"file:\") !== -1) {\r\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\r\n            if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\r\n                try {\r\n                    let blobURL;\r\n                    try {\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    } catch (ex) {\r\n                        // Chrome doesn't support oneTimeOnly parameter\r\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                    }\r\n                    img.src = blobURL;\r\n                    usingObjectURL = true;\r\n                } catch (e) {\r\n                    img.src = \"\";\r\n                }\r\n                return img;\r\n            }\r\n        }\r\n\r\n        noOfflineSupport();\r\n    }\r\n\r\n    return img;\r\n};\r\n\r\n/**\r\n * Reads a file from a File object\r\n * @param file defines the file to load\r\n * @param onSuccess defines the callback to call when data is loaded\r\n * @param onProgress defines the callback to call during loading process\r\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n * @param onError defines the callback to call when an error occurs\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const ReadFile = (\r\n    file: File,\r\n    onSuccess: (data: any) => void,\r\n    onProgress?: (ev: ProgressEvent) => any,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: ReadFileError) => void\r\n): IFileRequest => {\r\n    const reader = new FileReader();\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => reader.abort(),\r\n    };\r\n\r\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n    if (onError) {\r\n        reader.onerror = () => {\r\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\r\n        };\r\n    }\r\n    reader.onload = (e) => {\r\n        //target doesn't have result from ts 1.3\r\n        onSuccess((<any>e.target)[\"result\"]);\r\n    };\r\n    if (onProgress) {\r\n        reader.onprogress = onProgress;\r\n    }\r\n    if (!useArrayBuffer) {\r\n        // Asynchronous read\r\n        reader.readAsText(file);\r\n    } else {\r\n        reader.readAsArrayBuffer(file);\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Loads a file from a url, a data url, or a file url\r\n * @param fileOrUrl file, url, data url, or file url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened\r\n * @returns a file request object\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const LoadFile = (\r\n    fileOrUrl: File | string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string, contentType?: Nullable<string>) => void,\r\n    onProgress?: (ev: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    if ((fileOrUrl as File).name) {\r\n        return ReadFile(\r\n            fileOrUrl as File,\r\n            onSuccess,\r\n            onProgress,\r\n            useArrayBuffer,\r\n            onError\r\n                ? (error: ReadFileError) => {\r\n                      onError(undefined, error);\r\n                  }\r\n                : undefined\r\n        );\r\n    }\r\n\r\n    const url = fileOrUrl as string;\r\n\r\n    // If file and file input are set\r\n    if (url.indexOf(\"file:\") !== -1) {\r\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\r\n        if (fileName.indexOf(\"./\") === 0) {\r\n            fileName = fileName.substring(2);\r\n        }\r\n        const file = FilesInputStore.FilesToLoad[fileName];\r\n        if (file) {\r\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\r\n        }\r\n    }\r\n\r\n    // For a Base64 Data URL\r\n    const { match, type } = TestBase64DataUrl(url);\r\n    if (match) {\r\n        const fileRequest: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => () => {},\r\n        };\r\n\r\n        try {\r\n            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\r\n            onSuccess(data, undefined, type);\r\n        } catch (error) {\r\n            if (onError) {\r\n                onError(undefined, error);\r\n            } else {\r\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\r\n            }\r\n        }\r\n\r\n        TimingTools.SetImmediate(() => {\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n        });\r\n\r\n        return fileRequest;\r\n    }\r\n\r\n    return RequestFile(\r\n        url,\r\n        (data, request) => {\r\n            onSuccess(data, request?.responseURL, request?.getResponseHeader(\"content-type\"));\r\n        },\r\n        onProgress,\r\n        offlineProvider,\r\n        useArrayBuffer,\r\n        onError\r\n            ? (error) => {\r\n                  onError(error.request, new LoadFileError(error.message, error.request));\r\n              }\r\n            : undefined,\r\n        onOpened\r\n    );\r\n};\r\n\r\n/**\r\n * Loads a file from a url\r\n * @param url url to load\r\n * @param onSuccess callback called when the file successfully loads\r\n * @param onProgress callback called while file is loading (if the server supports this mode)\r\n * @param offlineProvider defines the offline provider for caching\r\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n * @param onError callback called when the file fails to load\r\n * @param onOpened callback called when the web request is opened\r\n * @returns a file request object\r\n * @internal\r\n */\r\nexport const RequestFile = (\r\n    url: string,\r\n    onSuccess?: (data: string | ArrayBuffer, request?: WebRequest) => void,\r\n    onProgress?: (event: ProgressEvent) => void,\r\n    offlineProvider?: IOfflineProvider,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (error: RequestFileError) => void,\r\n    onOpened?: (request: WebRequest) => void\r\n): IFileRequest => {\r\n    url = FileToolsOptions.CleanUrl(url);\r\n    url = FileToolsOptions.PreprocessUrl(url);\r\n\r\n    const loadUrl = FileToolsOptions.BaseUrl + url;\r\n\r\n    let aborted = false;\r\n    const fileRequest: IFileRequest = {\r\n        onCompleteObservable: new Observable<IFileRequest>(),\r\n        abort: () => (aborted = true),\r\n    };\r\n\r\n    const requestFile = () => {\r\n        let request: Nullable<WebRequest> = new WebRequest();\r\n        let retryHandle: Nullable<ReturnType<typeof setTimeout>> = null;\r\n        let onReadyStateChange: Nullable<() => void>;\r\n\r\n        const unbindEvents = () => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.removeEventListener(\"progress\", onProgress);\r\n            }\r\n            if (onReadyStateChange) {\r\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n            }\r\n            request.removeEventListener(\"loadend\", onLoadEnd!);\r\n        };\r\n\r\n        let onLoadEnd: Nullable<() => void> = () => {\r\n            unbindEvents();\r\n\r\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n            fileRequest.onCompleteObservable.clear();\r\n\r\n            onProgress = undefined;\r\n            onReadyStateChange = null;\r\n            onLoadEnd = null;\r\n            onError = undefined;\r\n            onOpened = undefined;\r\n            onSuccess = undefined;\r\n        };\r\n\r\n        fileRequest.abort = () => {\r\n            aborted = true;\r\n\r\n            if (onLoadEnd) {\r\n                onLoadEnd();\r\n            }\r\n\r\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\r\n                request.abort();\r\n            }\r\n\r\n            if (retryHandle !== null) {\r\n                clearTimeout(retryHandle);\r\n                retryHandle = null;\r\n            }\r\n\r\n            request = null;\r\n        };\r\n\r\n        const handleError = (error: any) => {\r\n            const message = error.message || \"Unknown error\";\r\n            if (onError && request) {\r\n                onError(new RequestFileError(message, request));\r\n            } else {\r\n                Logger.Error(message);\r\n            }\r\n        };\r\n\r\n        const retryLoop = (retryIndex: number) => {\r\n            if (!request) {\r\n                return;\r\n            }\r\n            request.open(\"GET\", loadUrl);\r\n\r\n            if (onOpened) {\r\n                try {\r\n                    onOpened(request);\r\n                } catch (e) {\r\n                    handleError(e);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (useArrayBuffer) {\r\n                request.responseType = \"arraybuffer\";\r\n            }\r\n\r\n            if (onProgress) {\r\n                request.addEventListener(\"progress\", onProgress);\r\n            }\r\n\r\n            if (onLoadEnd) {\r\n                request.addEventListener(\"loadend\", onLoadEnd);\r\n            }\r\n\r\n            onReadyStateChange = () => {\r\n                if (aborted || !request) {\r\n                    return;\r\n                }\r\n\r\n                // In case of undefined state in some browsers.\r\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\r\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\r\n                    if (onReadyStateChange) {\r\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n                    }\r\n\r\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\r\n                        try {\r\n                            if (onSuccess) {\r\n                                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\r\n                            }\r\n                        } catch (e) {\r\n                            handleError(e);\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\r\n                    if (retryStrategy) {\r\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\r\n                        if (waitTime !== -1) {\r\n                            // Prevent the request from completing for retry.\r\n                            unbindEvents();\r\n\r\n                            request = new WebRequest();\r\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\r\n                    if (onError) {\r\n                        onError(error);\r\n                    }\r\n                }\r\n            };\r\n\r\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\r\n\r\n            request.send();\r\n        };\r\n\r\n        retryLoop(0);\r\n    };\r\n\r\n    // Caching all files\r\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\r\n        const noOfflineSupport = (request?: any) => {\r\n            if (request && request.status > 400) {\r\n                if (onError) {\r\n                    onError(request);\r\n                }\r\n            } else {\r\n                requestFile();\r\n            }\r\n        };\r\n\r\n        const loadFromOfflineSupport = () => {\r\n            // TODO: database needs to support aborting and should return a IFileRequest\r\n\r\n            if (offlineProvider) {\r\n                offlineProvider.loadFile(\r\n                    FileToolsOptions.BaseUrl + url,\r\n                    (data) => {\r\n                        if (!aborted && onSuccess) {\r\n                            onSuccess(data);\r\n                        }\r\n\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                    },\r\n                    onProgress\r\n                        ? (event) => {\r\n                              if (!aborted && onProgress) {\r\n                                  onProgress(event);\r\n                              }\r\n                          }\r\n                        : undefined,\r\n                    noOfflineSupport,\r\n                    useArrayBuffer\r\n                );\r\n            }\r\n        };\r\n\r\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n    } else {\r\n        requestFile();\r\n    }\r\n\r\n    return fileRequest;\r\n};\r\n\r\n/**\r\n * Checks if the loaded document was accessed via `file:`-Protocol.\r\n * @returns boolean\r\n * @internal\r\n */\r\nexport const IsFileURL = (): boolean => {\r\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\r\n};\r\n\r\n/**\r\n * Test if the given uri is a valid base64 data url\r\n * @param uri The uri to test\r\n * @returns True if the uri is a base64 data url or false otherwise\r\n * @internal\r\n */\r\nexport const IsBase64DataUrl = (uri: string): boolean => {\r\n    return Base64DataUrlRegEx.test(uri);\r\n};\r\n\r\nexport const TestBase64DataUrl = (uri: string): { match: boolean; type: string } => {\r\n    const results = Base64DataUrlRegEx.exec(uri);\r\n    if (results === null || results.length === 0) {\r\n        return { match: false, type: \"\" };\r\n    } else {\r\n        const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\r\n        return { match: true, type };\r\n    }\r\n};\r\n\r\n/**\r\n * Decode the given base64 uri.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport function DecodeBase64UrlToBinary(uri: string): ArrayBuffer {\r\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\r\n}\r\n\r\n/**\r\n * Decode the given base64 uri into a UTF-8 encoded string.\r\n * @param uri The uri to decode\r\n * @returns The decoded base64 data.\r\n * @internal\r\n */\r\nexport const DecodeBase64UrlToString = (uri: string): string => {\r\n    return DecodeBase64ToString(uri.split(\",\")[1]);\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    AbstractEngine._FileToolsLoadImage = LoadImage;\r\n    EngineFunctionContext.loadFile = LoadFile;\r\n    _functionContainer.loadFile = LoadFile;\r\n};\r\n\r\ninitSideEffects();\r\n\r\n// deprecated\r\n\r\n/**\r\n * FileTools defined as any.\r\n * This should not be imported or used in future releases or in any module in the framework\r\n * @internal\r\n * @deprecated import the needed function from fileTools.ts\r\n */\r\nexport let FileTools: {\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer;\r\n    DecodeBase64UrlToString: (uri: string) => string;\r\n    DefaultRetryStrategy: any;\r\n    BaseUrl: any;\r\n    CorsBehavior: any;\r\n    PreprocessUrl: any;\r\n    IsBase64DataUrl: (uri: string) => boolean;\r\n    IsFileURL: () => boolean;\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | Blob | ArrayBufferView,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string | undefined,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>;\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest;\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest;\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void;\r\n};\r\n/**\r\n * @internal\r\n */\r\nexport const _injectLTSFileTools = (\r\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer,\r\n    DecodeBase64UrlToString: (uri: string) => string,\r\n    FileToolsOptions: { DefaultRetryStrategy: any; BaseUrl: any; CorsBehavior: any; PreprocessUrl: any; CleanUrl: any },\r\n    IsBase64DataUrl: (uri: string) => boolean,\r\n    IsFileURL: () => boolean,\r\n    LoadFile: (\r\n        fileOrUrl: string | File,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    LoadImage: (\r\n        input: string | ArrayBuffer | ArrayBufferView | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string | undefined, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions | undefined\r\n    ) => Nullable<HTMLImageElement>,\r\n    ReadFile: (\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: ReadFileError) => void) | undefined\r\n    ) => IFileRequest,\r\n    RequestFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void,\r\n        onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined,\r\n        offlineProvider?: IOfflineProvider | undefined,\r\n        useArrayBuffer?: boolean | undefined,\r\n        onError?: ((error: RequestFileError) => void) | undefined,\r\n        onOpened?: ((request: WebRequest) => void) | undefined\r\n    ) => IFileRequest,\r\n    SetCorsBehavior: (url: string | string[], element: { crossOrigin: string | null }) => void\r\n) => {\r\n    /**\r\n     * Backwards compatibility.\r\n     * @internal\r\n     * @deprecated\r\n     */\r\n    FileTools = {\r\n        DecodeBase64UrlToBinary,\r\n        DecodeBase64UrlToString,\r\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\r\n        BaseUrl: FileToolsOptions.BaseUrl,\r\n        CorsBehavior: FileToolsOptions.CorsBehavior,\r\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\r\n        IsBase64DataUrl,\r\n        IsFileURL,\r\n        LoadFile,\r\n        LoadImage,\r\n        ReadFile,\r\n        RequestFile,\r\n        SetCorsBehavior,\r\n    };\r\n\r\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.DefaultRetryStrategy;\r\n        },\r\n        set: function (this: null, value: (url: string, request: WebRequest, retryIndex: number) => number) {\r\n            FileToolsOptions.DefaultRetryStrategy = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"BaseUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.BaseUrl;\r\n        },\r\n        set: function (this: null, value: string) {\r\n            FileToolsOptions.BaseUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.PreprocessUrl;\r\n        },\r\n        set: function (this: null, value: (url: string) => string) {\r\n            FileToolsOptions.PreprocessUrl = value;\r\n        },\r\n    });\r\n\r\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\r\n        get: function (this: null) {\r\n            return FileToolsOptions.CorsBehavior;\r\n        },\r\n        set: function (this: null, value: string | ((url: string | string[]) => string)) {\r\n            FileToolsOptions.CorsBehavior = value;\r\n        },\r\n    });\r\n};\r\n\r\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\r\n", "/**\r\n * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n * Be aware Math.random() could cause collisions, but:\r\n * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n * @returns a pseudo random id\r\n */\r\nexport function RandomGUID(): string {\r\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16) | 0,\r\n            v = c === \"x\" ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n}\r\n/**\r\n * Class used to manipulate GUIDs\r\n */\r\nexport const GUID = {\r\n    /**\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a pseudo random id\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    RandomId: RandomGUID,\r\n};\r\n", "import { Logger } from \"./logger\";\r\nimport { GetClass } from \"./typeStore\";\r\n\r\n/**\r\n * Class used to enable instantiation of objects by class name\r\n */\r\nexport class InstantiationTools {\r\n    /**\r\n     * Use this object to register external classes like custom textures or material\r\n     * to allow the loaders to instantiate them\r\n     */\r\n    public static RegisteredExternalClasses: { [key: string]: Object } = {};\r\n\r\n    /**\r\n     * Tries to instantiate a new object from a given class name\r\n     * @param className defines the class name to instantiate\r\n     * @returns the new object or null if the system was not able to do the instantiation\r\n     */\r\n    public static Instantiate(className: string): any {\r\n        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {\r\n            return this.RegisteredExternalClasses[className];\r\n        }\r\n\r\n        const internalClass = GetClass(className);\r\n        if (internalClass) {\r\n            return internalClass;\r\n        }\r\n\r\n        Logger.Warn(className + \" not found, you may have missed an import.\");\r\n\r\n        const arr = className.split(\".\");\r\n\r\n        let fn: any = window || this;\r\n        for (let i = 0, len = arr.length; i < len; i++) {\r\n            fn = fn[arr[i]];\r\n        }\r\n\r\n        if (typeof fn !== \"function\") {\r\n            return null;\r\n        }\r\n\r\n        return fn;\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Function indicating if a number is an exponent of 2\r\n * @param value defines the value to test\r\n * @returns true if the value is an exponent of 2\r\n */\r\nexport function IsExponentOfTwo(value: number): boolean {\r\n    let count = 1;\r\n\r\n    do {\r\n        count *= 2;\r\n    } while (count < value);\r\n\r\n    return count === value;\r\n}\r\n\r\n/**\r\n * Interpolates between a and b via alpha\r\n * @param a The lower value (returned when alpha = 0)\r\n * @param b The upper value (returned when alpha = 1)\r\n * @param alpha The interpolation-factor\r\n * @returns The mixed value\r\n */\r\nexport function Mix(a: number, b: number, alpha: number): number {\r\n    return a * (1 - alpha) + b * alpha;\r\n}\r\n\r\n/**\r\n * Find the nearest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next nearest power of two.\r\n */\r\nexport function NearestPOT(x: number): number {\r\n    const c = CeilingPOT(x);\r\n    const f = FloorPOT(x);\r\n    return c - x > x - f ? f : c;\r\n}\r\n\r\n/**\r\n * Find the next highest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next highest power of two.\r\n */\r\nexport function CeilingPOT(x: number): number {\r\n    x--;\r\n    x |= x >> 1;\r\n    x |= x >> 2;\r\n    x |= x >> 4;\r\n    x |= x >> 8;\r\n    x |= x >> 16;\r\n    x++;\r\n    return x;\r\n}\r\n\r\n/**\r\n * Find the next lowest power of two.\r\n * @param x Number to start search from.\r\n * @returns Next lowest power of two.\r\n */\r\nexport function FloorPOT(x: number): number {\r\n    x = x | (x >> 1);\r\n    x = x | (x >> 2);\r\n    x = x | (x >> 4);\r\n    x = x | (x >> 8);\r\n    x = x | (x >> 16);\r\n    return x - (x >> 1);\r\n}\r\n\r\n/**\r\n * Get the closest exponent of two\r\n * @param value defines the value to approximate\r\n * @param max defines the maximum value to return\r\n * @param mode defines how to define the closest value\r\n * @returns closest exponent of two of the given value\r\n */\r\nexport function GetExponentOfTwo(value: number, max: number, mode = Constants.SCALEMODE_NEAREST): number {\r\n    let pot;\r\n\r\n    switch (mode) {\r\n        case Constants.SCALEMODE_FLOOR:\r\n            pot = FloorPOT(value);\r\n            break;\r\n        case Constants.SCALEMODE_NEAREST:\r\n            pot = NearestPOT(value);\r\n            break;\r\n        case Constants.SCALEMODE_CEILING:\r\n        default:\r\n            pot = CeilingPOT(value);\r\n            break;\r\n    }\r\n\r\n    return Math.min(pot, max);\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"./observable\";\r\nimport { GetDOMTextContent, IsNavigatorAvailable, IsWindowObjectExist } from \"./domManagement\";\r\nimport { Logger } from \"./logger\";\r\nimport { DeepCopier } from \"./deepCopier\";\r\nimport { PrecisionDate } from \"./precisionDate\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport { WebRequest } from \"./webRequest\";\r\nimport type { IFileRequest } from \"./fileRequest\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { ReadFileError } from \"./fileTools\";\r\nimport {\r\n    FileToolsOptions,\r\n    DecodeBase64UrlToBinary,\r\n    IsBase64DataUrl,\r\n    LoadFile as FileToolsLoadFile,\r\n    LoadImage as FileToolLoadImage,\r\n    ReadFile as FileToolsReadFile,\r\n    SetCorsBehavior,\r\n} from \"./fileTools\";\r\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport { TimingTools } from \"./timingTools\";\r\nimport { InstantiationTools } from \"./instantiationTools\";\r\nimport { RandomGUID } from \"./guid\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport { IsExponentOfTwo, Mix } from \"./tools.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\ndeclare function importScripts(...urls: string[]): void;\r\n\r\n/**\r\n * Class containing a set of static utilities functions\r\n */\r\nexport class Tools {\r\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\r\n    public static get BaseUrl() {\r\n        return FileToolsOptions.BaseUrl;\r\n    }\r\n\r\n    public static set BaseUrl(value: string) {\r\n        FileToolsOptions.BaseUrl = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the clean URL function to use to load assets\r\n     */\r\n    public static get CleanUrl() {\r\n        return FileToolsOptions.CleanUrl;\r\n    }\r\n\r\n    public static set CleanUrl(value: (url: string) => string) {\r\n        FileToolsOptions.CleanUrl = value;\r\n    }\r\n\r\n    /**\r\n     * This function checks whether a URL is absolute or not.\r\n     * It will also detect data and blob URLs\r\n     * @param url the url to check\r\n     * @returns is the url absolute or relative\r\n     */\r\n    public static IsAbsoluteUrl(url: string): boolean {\r\n        // See https://stackoverflow.com/a/38979205.\r\n\r\n        // URL is protocol-relative (= absolute)\r\n        if (url.indexOf(\"//\") === 0) {\r\n            return true;\r\n        }\r\n\r\n        // URL has no protocol (= relative)\r\n        if (url.indexOf(\"://\") === -1) {\r\n            return false;\r\n        }\r\n\r\n        // URL does not contain a dot, i.e. no TLD (= relative, possibly REST)\r\n        if (url.indexOf(\".\") === -1) {\r\n            return false;\r\n        }\r\n\r\n        // URL does not contain a single slash (= relative)\r\n        if (url.indexOf(\"/\") === -1) {\r\n            return false;\r\n        }\r\n\r\n        // The first colon comes after the first slash (= relative)\r\n        if (url.indexOf(\":\") > url.indexOf(\"/\")) {\r\n            return false;\r\n        }\r\n\r\n        // Protocol is defined before first dot (= absolute)\r\n        if (url.indexOf(\"://\") < url.indexOf(\".\")) {\r\n            return true;\r\n        }\r\n        if (url.indexOf(\"data:\") === 0 || url.indexOf(\"blob:\") === 0) {\r\n            return true;\r\n        }\r\n\r\n        // Anything else must be relative\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the base URL to use to load scripts\r\n     */\r\n    public static set ScriptBaseUrl(value: string) {\r\n        FileToolsOptions.ScriptBaseUrl = value;\r\n    }\r\n\r\n    public static get ScriptBaseUrl(): string {\r\n        return FileToolsOptions.ScriptBaseUrl;\r\n    }\r\n\r\n    /**\r\n     * Sets a preprocessing function to run on a source URL before importing it\r\n     * Note that this function will execute AFTER the base URL is appended to the URL\r\n     */\r\n    public static set ScriptPreprocessUrl(func: (source: string) => string) {\r\n        FileToolsOptions.ScriptPreprocessUrl = func;\r\n    }\r\n\r\n    public static get ScriptPreprocessUrl(): (source: string) => string {\r\n        return FileToolsOptions.ScriptPreprocessUrl;\r\n    }\r\n\r\n    /**\r\n     * Enable/Disable Custom HTTP Request Headers globally.\r\n     * default = false\r\n     * @see CustomRequestHeaders\r\n     */\r\n    public static UseCustomRequestHeaders = false;\r\n\r\n    /**\r\n     * Custom HTTP Request Headers to be sent with XMLHttpRequests\r\n     * i.e. when loading files, where the server/service expects an Authorization header\r\n     */\r\n    public static CustomRequestHeaders = WebRequest.CustomRequestHeaders;\r\n\r\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset\r\n     */\r\n    public static get DefaultRetryStrategy() {\r\n        return FileToolsOptions.DefaultRetryStrategy;\r\n    }\r\n\r\n    public static set DefaultRetryStrategy(strategy: (url: string, request: WebRequest, retryIndex: number) => number) {\r\n        FileToolsOptions.DefaultRetryStrategy = strategy;\r\n    }\r\n\r\n    /**\r\n     * Default behavior for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\r\n    public static get CorsBehavior(): string | ((url: string | string[]) => string) {\r\n        return FileToolsOptions.CorsBehavior;\r\n    }\r\n\r\n    public static set CorsBehavior(value: string | ((url: string | string[]) => string)) {\r\n        FileToolsOptions.CorsBehavior = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded\r\n     * @ignorenaming\r\n     */\r\n    public static get UseFallbackTexture() {\r\n        return EngineStore.UseFallbackTexture;\r\n    }\r\n\r\n    public static set UseFallbackTexture(value: boolean) {\r\n        EngineStore.UseFallbackTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Use this object to register external classes like custom textures or material\r\n     * to allow the loaders to instantiate them\r\n     */\r\n    public static get RegisteredExternalClasses() {\r\n        return InstantiationTools.RegisteredExternalClasses;\r\n    }\r\n\r\n    public static set RegisteredExternalClasses(classes: { [key: string]: Object }) {\r\n        InstantiationTools.RegisteredExternalClasses = classes;\r\n    }\r\n\r\n    /**\r\n     * Texture content used if a texture cannot loaded\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get fallbackTexture() {\r\n        return EngineStore.FallbackTexture;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set fallbackTexture(value: string) {\r\n        EngineStore.FallbackTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Read the content of a byte array at a specified coordinates (taking in account wrapping)\r\n     * @param u defines the coordinate on X axis\r\n     * @param v defines the coordinate on Y axis\r\n     * @param width defines the width of the source data\r\n     * @param height defines the height of the source data\r\n     * @param pixels defines the source byte array\r\n     * @param color defines the output color\r\n     */\r\n    public static FetchToRef(u: number, v: number, width: number, height: number, pixels: Uint8Array, color: IColor4Like): void {\r\n        const wrappedU = (Math.abs(u) * width) % width | 0;\r\n        const wrappedV = (Math.abs(v) * height) % height | 0;\r\n\r\n        const position = (wrappedU + wrappedV * width) * 4;\r\n        color.r = pixels[position] / 255;\r\n        color.g = pixels[position + 1] / 255;\r\n        color.b = pixels[position + 2] / 255;\r\n        color.a = pixels[position + 3] / 255;\r\n    }\r\n\r\n    /**\r\n     * Interpolates between a and b via alpha\r\n     * @param a The lower value (returned when alpha = 0)\r\n     * @param b The upper value (returned when alpha = 1)\r\n     * @param alpha The interpolation-factor\r\n     * @returns The mixed value\r\n     */\r\n    public static Mix(a: number, b: number, alpha: number): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Tries to instantiate a new object from a given class name\r\n     * @param className defines the class name to instantiate\r\n     * @returns the new object or null if the system was not able to do the instantiation\r\n     */\r\n    public static Instantiate(className: string): any {\r\n        return InstantiationTools.Instantiate(className);\r\n    }\r\n\r\n    /**\r\n     * Polyfill for setImmediate\r\n     * @param action defines the action to execute after the current execution block\r\n     */\r\n    public static SetImmediate(action: () => void) {\r\n        TimingTools.SetImmediate(action);\r\n    }\r\n\r\n    /**\r\n     * Function indicating if a number is an exponent of 2\r\n     * @param value defines the value to test\r\n     * @returns true if the value is an exponent of 2\r\n     */\r\n    public static IsExponentOfTwo(value: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the nearest 32-bit single precision float representation of a Number\r\n     * @param value A Number.  If the parameter is of a different type, it will get converted\r\n     * to a number or to NaN if it cannot be converted\r\n     * @returns number\r\n     */\r\n    public static FloatRound(value: number): number {\r\n        return Math.fround(value);\r\n    }\r\n\r\n    /**\r\n     * Extracts the filename from a path\r\n     * @param path defines the path to use\r\n     * @returns the filename\r\n     */\r\n    public static GetFilename(path: string): string {\r\n        const index = path.lastIndexOf(\"/\");\r\n        if (index < 0) {\r\n            return path;\r\n        }\r\n\r\n        return path.substring(index + 1);\r\n    }\r\n\r\n    /**\r\n     * Extracts the \"folder\" part of a path (everything before the filename).\r\n     * @param uri The URI to extract the info from\r\n     * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present\r\n     * @returns The \"folder\" part of the path\r\n     */\r\n    public static GetFolderPath(uri: string, returnUnchangedIfNoSlash = false): string {\r\n        const index = uri.lastIndexOf(\"/\");\r\n        if (index < 0) {\r\n            if (returnUnchangedIfNoSlash) {\r\n                return uri;\r\n            }\r\n            return \"\";\r\n        }\r\n\r\n        return uri.substring(0, index + 1);\r\n    }\r\n\r\n    /**\r\n     * Extracts text content from a DOM element hierarchy\r\n     * Back Compat only, please use GetDOMTextContent instead.\r\n     */\r\n    public static GetDOMTextContent = GetDOMTextContent;\r\n\r\n    /**\r\n     * Convert an angle in radians to degrees\r\n     * @param angle defines the angle to convert\r\n     * @returns the angle in degrees\r\n     */\r\n    public static ToDegrees(angle: number): number {\r\n        return (angle * 180) / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Convert an angle in degrees to radians\r\n     * @param angle defines the angle to convert\r\n     * @returns the angle in radians\r\n     */\r\n    public static ToRadians(angle: number): number {\r\n        return (angle * Math.PI) / 180;\r\n    }\r\n\r\n    /**\r\n     * Smooth angle changes (kind of low-pass filter), in particular for device orientation \"shaking\"\r\n     * Use trigonometric functions to avoid discontinuity (0/360, -180/180)\r\n     * @param previousAngle defines last angle value, in degrees\r\n     * @param newAngle defines new angle value, in degrees\r\n     * @param smoothFactor defines smoothing sensitivity; min 0: no smoothing, max 1: new data ignored\r\n     * @returns the angle in degrees\r\n     */\r\n    public static SmoothAngleChange(previousAngle: number, newAngle: number, smoothFactor = 0.9): number {\r\n        const previousAngleRad = this.ToRadians(previousAngle);\r\n        const newAngleRad = this.ToRadians(newAngle);\r\n        return this.ToDegrees(\r\n            Math.atan2(\r\n                (1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad),\r\n                (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns an array if obj is not an array\r\n     * @param obj defines the object to evaluate as an array\r\n     * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined\r\n     * @returns either obj directly if obj is an array or a new array containing obj\r\n     */\r\n    public static MakeArray(obj: any, allowsNullUndefined?: boolean): Nullable<Array<any>> {\r\n        if (allowsNullUndefined !== true && (obj === undefined || obj == null)) {\r\n            return null;\r\n        }\r\n\r\n        return Array.isArray(obj) ? obj : [obj];\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer prefix to use\r\n     * @param engine defines the engine we are finding the prefix for\r\n     * @returns \"pointer\" if touch is enabled. Else returns \"mouse\"\r\n     */\r\n    public static GetPointerPrefix(engine: AbstractEngine): string {\r\n        let eventPrefix = \"pointer\";\r\n\r\n        // Check if pointer events are supported\r\n        if (IsWindowObjectExist() && !window.PointerEvent) {\r\n            eventPrefix = \"mouse\";\r\n        }\r\n\r\n        // Special Fallback MacOS Safari...\r\n        if (\r\n            engine._badDesktopOS &&\r\n            !engine._badOS &&\r\n            // And not ipad pros who claim to be macs...\r\n            !(document && \"ontouchend\" in document)\r\n        ) {\r\n            eventPrefix = \"mouse\";\r\n        }\r\n\r\n        return eventPrefix;\r\n    }\r\n\r\n    /**\r\n     * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n     * @param url define the url we are trying\r\n     * @param element define the dom element where to configure the cors policy\r\n     * @param element.crossOrigin\r\n     */\r\n    public static SetCorsBehavior(url: string | string[], element: { crossOrigin: string | null }): void {\r\n        SetCorsBehavior(url, element);\r\n    }\r\n\r\n    /**\r\n     * Sets the referrerPolicy behavior on a dom element.\r\n     * @param referrerPolicy define the referrer policy to use\r\n     * @param element define the dom element where to configure the referrer policy\r\n     * @param element.referrerPolicy\r\n     */\r\n    public static SetReferrerPolicyBehavior(referrerPolicy: Nullable<ReferrerPolicy>, element: { referrerPolicy: string | null }): void {\r\n        element.referrerPolicy = referrerPolicy;\r\n    }\r\n\r\n    // External files\r\n\r\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     */\r\n    public static get PreprocessUrl() {\r\n        return FileToolsOptions.PreprocessUrl;\r\n    }\r\n\r\n    public static set PreprocessUrl(processor: (url: string) => string) {\r\n        FileToolsOptions.PreprocessUrl = processor;\r\n    }\r\n\r\n    /**\r\n     * Loads an image as an HTMLImageElement.\r\n     * @param input url string, ArrayBuffer, or Blob to load\r\n     * @param onLoad callback called when the image successfully loads\r\n     * @param onError callback called when the image fails to load\r\n     * @param offlineProvider offline provider for caching\r\n     * @param mimeType optional mime type\r\n     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\r\n     * @returns the HTMLImageElement of the loaded image\r\n     */\r\n    public static LoadImage(\r\n        input: string | ArrayBuffer | Blob,\r\n        onLoad: (img: HTMLImageElement | ImageBitmap) => void,\r\n        onError: (message?: string, exception?: any) => void,\r\n        offlineProvider: Nullable<IOfflineProvider>,\r\n        mimeType?: string,\r\n        imageBitmapOptions?: ImageBitmapOptions\r\n    ): Nullable<HTMLImageElement> {\r\n        return FileToolLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url string, ArrayBuffer, or Blob to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    public static LoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (data: any) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: any) => void\r\n    ): IFileRequest {\r\n        return FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n    }\r\n\r\n    // Note that this must come first since useArrayBuffer defaults to true below.\r\n    public static LoadFileAsync(url: string, useArrayBuffer?: true): Promise<ArrayBuffer>;\r\n    public static LoadFileAsync(url: string, useArrayBuffer?: false): Promise<string>;\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url the file url to load\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @returns a promise containing an ArrayBuffer corresponding to the loaded file\r\n     */\r\n    public static LoadFileAsync(url: string, useArrayBuffer = true): Promise<ArrayBuffer | string> {\r\n        return new Promise((resolve, reject) => {\r\n            FileToolsLoadFile(\r\n                url,\r\n                (data) => {\r\n                    resolve(data);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                useArrayBuffer,\r\n                (request, exception) => {\r\n                    reject(exception);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _DefaultCdnUrl = \"https://cdn.babylonjs.com\";\r\n\r\n    /**\r\n     * Get a script URL including preprocessing\r\n     * @param scriptUrl the script Url to process\r\n     * @param forceAbsoluteUrl force the script to be an absolute url (adding the current base url if necessary)\r\n     * @returns a modified URL to use\r\n     */\r\n    public static GetBabylonScriptURL(scriptUrl: Nullable<string>, forceAbsoluteUrl?: boolean): string {\r\n        if (!scriptUrl) {\r\n            return \"\";\r\n        }\r\n        // if the base URL was set, and the script Url is an absolute path change the default path\r\n        if (Tools.ScriptBaseUrl && scriptUrl.startsWith(Tools._DefaultCdnUrl)) {\r\n            // change the default host, which is https://cdn.babylonjs.com with the one defined\r\n            // make sure no trailing slash is present\r\n\r\n            const baseUrl = Tools.ScriptBaseUrl[Tools.ScriptBaseUrl.length - 1] === \"/\" ? Tools.ScriptBaseUrl.substring(0, Tools.ScriptBaseUrl.length - 1) : Tools.ScriptBaseUrl;\r\n            scriptUrl = scriptUrl.replace(Tools._DefaultCdnUrl, baseUrl);\r\n        }\r\n\r\n        // run the preprocessor\r\n        scriptUrl = Tools.ScriptPreprocessUrl(scriptUrl);\r\n\r\n        if (forceAbsoluteUrl) {\r\n            scriptUrl = Tools.GetAbsoluteUrl(scriptUrl);\r\n        }\r\n\r\n        return scriptUrl;\r\n    }\r\n\r\n    /**\r\n     * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the\r\n     * content of this file is added into a new script element, attached to the DOM (body element)\r\n     * @param scriptUrl defines the url of the script to load\r\n     * @param onSuccess defines the callback called when the script is loaded\r\n     * @param onError defines the callback to call if an error occurs\r\n     * @param scriptId defines the id of the script element\r\n     */\r\n    public static LoadBabylonScript(scriptUrl: string, onSuccess: () => void, onError?: (message?: string, exception?: any) => void, scriptId?: string) {\r\n        scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);\r\n        Tools.LoadScript(scriptUrl, onSuccess, onError);\r\n    }\r\n\r\n    /**\r\n     * Load an asynchronous script (identified by an url). When the url returns, the\r\n     * content of this file is added into a new script element, attached to the DOM (body element)\r\n     * @param scriptUrl defines the url of the script to laod\r\n     * @returns a promise request object\r\n     */\r\n    public static LoadBabylonScriptAsync(scriptUrl: string): Promise<void> {\r\n        scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);\r\n        return Tools.LoadScriptAsync(scriptUrl);\r\n    }\r\n\r\n    /**\r\n     * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the\r\n     * content of this file is added into a new script element, attached to the DOM (body element)\r\n     * @param scriptUrl defines the url of the script to load\r\n     * @param onSuccess defines the callback called when the script is loaded\r\n     * @param onError defines the callback to call if an error occurs\r\n     * @param scriptId defines the id of the script element\r\n     */\r\n    public static LoadScript(scriptUrl: string, onSuccess: () => void, onError?: (message?: string, exception?: any) => void, scriptId?: string) {\r\n        if (typeof importScripts === \"function\") {\r\n            try {\r\n                importScripts(scriptUrl);\r\n                onSuccess();\r\n            } catch (e) {\r\n                onError?.(`Unable to load script '${scriptUrl}' in worker`, e);\r\n            }\r\n            return;\r\n        } else if (!IsWindowObjectExist()) {\r\n            onError?.(`Cannot load script '${scriptUrl}' outside of a window or a worker`);\r\n            return;\r\n        }\r\n        const head = document.getElementsByTagName(\"head\")[0];\r\n        const script = document.createElement(\"script\");\r\n        script.setAttribute(\"type\", \"text/javascript\");\r\n        script.setAttribute(\"src\", scriptUrl);\r\n        if (scriptId) {\r\n            script.id = scriptId;\r\n        }\r\n\r\n        script.onload = () => {\r\n            if (onSuccess) {\r\n                onSuccess();\r\n            }\r\n        };\r\n\r\n        script.onerror = (e) => {\r\n            if (onError) {\r\n                onError(`Unable to load script '${scriptUrl}'`, e);\r\n            }\r\n        };\r\n\r\n        head.appendChild(script);\r\n    }\r\n\r\n    /**\r\n     * Load an asynchronous script (identified by an url). When the url returns, the\r\n     * content of this file is added into a new script element, attached to the DOM (body element)\r\n     * @param scriptUrl defines the url of the script to load\r\n     * @param scriptId defines the id of the script element\r\n     * @returns a promise request object\r\n     */\r\n    public static LoadScriptAsync(scriptUrl: string, scriptId?: string): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.LoadScript(\r\n                scriptUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                (message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                scriptId\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a blob\r\n     * @param fileToLoad defines the blob to use\r\n     * @param callback defines the callback to call when data is loaded\r\n     * @param progressCallback defines the callback to call during loading process\r\n     * @returns a file request object\r\n     */\r\n    public static ReadFileAsDataURL(fileToLoad: Blob, callback: (data: any) => void, progressCallback: (ev: ProgressEvent) => any): IFileRequest {\r\n        const reader = new FileReader();\r\n\r\n        const request: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => reader.abort(),\r\n        };\r\n\r\n        reader.onloadend = () => {\r\n            request.onCompleteObservable.notifyObservers(request);\r\n        };\r\n\r\n        reader.onload = (e) => {\r\n            //target doesn't have result from ts 1.3\r\n            callback((<any>e.target)[\"result\"]);\r\n        };\r\n\r\n        reader.onprogress = progressCallback;\r\n\r\n        reader.readAsDataURL(fileToLoad);\r\n\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Reads a file from a File object\r\n     * @param file defines the file to load\r\n     * @param onSuccess defines the callback to call when data is loaded\r\n     * @param onProgress defines the callback to call during loading process\r\n     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n     * @param onError defines the callback to call when an error occurs\r\n     * @returns a file request object\r\n     */\r\n    public static ReadFile(\r\n        file: File,\r\n        onSuccess: (data: any) => void,\r\n        onProgress?: (ev: ProgressEvent) => any,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (error: ReadFileError) => void\r\n    ): IFileRequest {\r\n        return FileToolsReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\r\n    }\r\n\r\n    /**\r\n     * Creates a data url from a given string content\r\n     * @param content defines the content to convert\r\n     * @returns the new data url link\r\n     */\r\n    public static FileAsURL(content: string): string {\r\n        const fileBlob = new Blob([content]);\r\n        const url = window.URL;\r\n        const link: string = url.createObjectURL(fileBlob);\r\n        return link;\r\n    }\r\n\r\n    /**\r\n     * Format the given number to a specific decimal format\r\n     * @param value defines the number to format\r\n     * @param decimals defines the number of decimals to use\r\n     * @returns the formatted string\r\n     */\r\n    public static Format(value: number, decimals = 2): string {\r\n        return value.toFixed(decimals);\r\n    }\r\n\r\n    /**\r\n     * Tries to copy an object by duplicating every property\r\n     * @param source defines the source object\r\n     * @param destination defines the target object\r\n     * @param doNotCopyList defines a list of properties to avoid\r\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\r\n     */\r\n    public static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void {\r\n        DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has no own property\r\n     * @param obj defines the object to test\r\n     * @returns true if object has no own property\r\n     */\r\n    public static IsEmpty(obj: any): boolean {\r\n        for (const i in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Function used to register events at window level\r\n     * @param windowElement defines the Window object to use\r\n     * @param events defines the events to register\r\n     */\r\n    public static RegisterTopRootEvents(windowElement: Window, events: { name: string; handler: Nullable<(e: FocusEvent) => any> }[]): void {\r\n        for (let index = 0; index < events.length; index++) {\r\n            const event = events[index];\r\n            windowElement.addEventListener(event.name, <any>event.handler, false);\r\n\r\n            try {\r\n                if (window.parent) {\r\n                    window.parent.addEventListener(event.name, <any>event.handler, false);\r\n                }\r\n            } catch (e) {\r\n                // Silently fails...\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function used to unregister events from window level\r\n     * @param windowElement defines the Window object to use\r\n     * @param events defines the events to unregister\r\n     */\r\n    public static UnregisterTopRootEvents(windowElement: Window, events: { name: string; handler: Nullable<(e: FocusEvent) => any> }[]): void {\r\n        for (let index = 0; index < events.length; index++) {\r\n            const event = events[index];\r\n            windowElement.removeEventListener(event.name, <any>event.handler);\r\n\r\n            try {\r\n                if (windowElement.parent) {\r\n                    windowElement.parent.removeEventListener(event.name, <any>event.handler);\r\n                }\r\n            } catch (e) {\r\n                // Silently fails...\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dumps the current bound framebuffer\r\n     * @param width defines the rendering width\r\n     * @param height defines the rendering height\r\n     * @param engine defines the hosting engine\r\n     * @param successCallback defines the callback triggered once the data are available\r\n     * @param mimeType defines the mime type of the result\r\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns a void promise\r\n     */\r\n    public static async DumpFramebuffer(\r\n        width: number,\r\n        height: number,\r\n        engine: AbstractEngine,\r\n        successCallback?: (data: string) => void,\r\n        mimeType = \"image/png\",\r\n        fileName?: string,\r\n        quality?: number\r\n    ) {\r\n        throw _WarnImport(\"DumpTools\");\r\n    }\r\n\r\n    /**\r\n     * Dumps an array buffer\r\n     * @param width defines the rendering width\r\n     * @param height defines the rendering height\r\n     * @param data the data array\r\n     * @param successCallback defines the callback triggered once the data are available\r\n     * @param mimeType defines the mime type of the result\r\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n     * @param invertY true to invert the picture in the Y dimension\r\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    public static DumpData(\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        successCallback?: (data: string | ArrayBuffer) => void,\r\n        mimeType = \"image/png\",\r\n        fileName?: string,\r\n        invertY = false,\r\n        toArrayBuffer = false,\r\n        quality?: number\r\n    ) {\r\n        throw _WarnImport(\"DumpTools\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Dumps an array buffer\r\n     * @param width defines the rendering width\r\n     * @param height defines the rendering height\r\n     * @param data the data array\r\n     * @param mimeType defines the mime type of the result\r\n     * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n     * @param invertY true to invert the picture in the Y dimension\r\n     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns a promise that resolve to the final data\r\n     */\r\n    public static DumpDataAsync(\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        mimeType = \"image/png\",\r\n        fileName?: string,\r\n        invertY = false,\r\n        toArrayBuffer = false,\r\n        quality?: number\r\n    ): Promise<string | ArrayBuffer> {\r\n        throw _WarnImport(\"DumpTools\");\r\n    }\r\n\r\n    private static _IsOffScreenCanvas(canvas: HTMLCanvasElement | OffscreenCanvas): canvas is OffscreenCanvas {\r\n        return (canvas as OffscreenCanvas).convertToBlob !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Converts the canvas data to blob.\r\n     * This acts as a polyfill for browsers not supporting the to blob function.\r\n     * @param canvas Defines the canvas to extract the data from (can be an offscreen canvas)\r\n     * @param successCallback Defines the callback triggered once the data are available\r\n     * @param mimeType Defines the mime type of the result\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    static ToBlob(canvas: HTMLCanvasElement | OffscreenCanvas, successCallback: (blob: Nullable<Blob>) => void, mimeType = \"image/png\", quality?: number): void {\r\n        // We need HTMLCanvasElement.toBlob for HD screenshots\r\n        if (!Tools._IsOffScreenCanvas(canvas) && !canvas.toBlob) {\r\n            //  low performance polyfill based on toDataURL (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob)\r\n            canvas.toBlob = function (callback, type, quality) {\r\n                setTimeout(() => {\r\n                    const binStr = atob(this.toDataURL(type, quality).split(\",\")[1]),\r\n                        len = binStr.length,\r\n                        arr = new Uint8Array(len);\r\n\r\n                    for (let i = 0; i < len; i++) {\r\n                        arr[i] = binStr.charCodeAt(i);\r\n                    }\r\n                    callback(new Blob([arr]));\r\n                });\r\n            };\r\n        }\r\n        if (Tools._IsOffScreenCanvas(canvas)) {\r\n            canvas\r\n                .convertToBlob({\r\n                    type: mimeType,\r\n                    quality,\r\n                })\r\n                .then((blob) => successCallback(blob));\r\n        } else {\r\n            canvas.toBlob(\r\n                function (blob) {\r\n                    successCallback(blob);\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Download a Blob object\r\n     * @param blob the Blob object\r\n     * @param fileName the file name to download\r\n     */\r\n    static DownloadBlob(blob: Blob, fileName?: string) {\r\n        //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.\r\n        if (\"download\" in document.createElement(\"a\")) {\r\n            if (!fileName) {\r\n                const date = new Date();\r\n                const stringDate =\r\n                    (date.getFullYear() + \"-\" + (date.getMonth() + 1)).slice(2) + \"-\" + date.getDate() + \"_\" + date.getHours() + \"-\" + (\"0\" + date.getMinutes()).slice(-2);\r\n                fileName = \"screenshot_\" + stringDate + \".png\";\r\n            }\r\n            Tools.Download(blob, fileName);\r\n        } else {\r\n            if (blob && typeof URL !== \"undefined\") {\r\n                const url = URL.createObjectURL(blob);\r\n\r\n                const newWindow = window.open(\"\");\r\n                if (!newWindow) {\r\n                    return;\r\n                }\r\n                const img = newWindow.document.createElement(\"img\");\r\n                img.onload = function () {\r\n                    // no longer need to read the blob so it's revoked\r\n                    URL.revokeObjectURL(url);\r\n                };\r\n                img.src = url;\r\n                newWindow.document.body.appendChild(img);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encodes the canvas data to base 64, or automatically downloads the result if `fileName` is defined.\r\n     * @param canvas The canvas to get the data from, which can be an offscreen canvas.\r\n     * @param successCallback The callback which is triggered once the data is available. If `fileName` is defined, the callback will be invoked after the download occurs, and the `data` argument will be an empty string.\r\n     * @param mimeType The mime type of the result.\r\n     * @param fileName The name of the file to download. If defined, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    static EncodeScreenshotCanvasData(\r\n        canvas: HTMLCanvasElement | OffscreenCanvas,\r\n        successCallback?: (data: string) => void,\r\n        mimeType = \"image/png\",\r\n        fileName?: string,\r\n        quality?: number\r\n    ): void {\r\n        if (typeof fileName === \"string\" || !successCallback) {\r\n            this.ToBlob(\r\n                canvas,\r\n                function (blob) {\r\n                    if (blob) {\r\n                        Tools.DownloadBlob(blob, fileName);\r\n                    }\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                },\r\n                mimeType,\r\n                quality\r\n            );\r\n        } else if (successCallback) {\r\n            if (Tools._IsOffScreenCanvas(canvas)) {\r\n                canvas\r\n                    .convertToBlob({\r\n                        type: mimeType,\r\n                        quality,\r\n                    })\r\n                    .then((blob) => {\r\n                        const reader = new FileReader();\r\n                        reader.readAsDataURL(blob);\r\n                        reader.onloadend = () => {\r\n                            const base64data = reader.result;\r\n                            successCallback(base64data as string);\r\n                        };\r\n                    });\r\n                return;\r\n            }\r\n            const base64Image = canvas.toDataURL(mimeType, quality);\r\n            successCallback(base64Image);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Downloads a blob in the browser\r\n     * @param blob defines the blob to download\r\n     * @param fileName defines the name of the downloaded file\r\n     */\r\n    public static Download(blob: Blob, fileName: string): void {\r\n        if (typeof URL === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const url = window.URL.createObjectURL(blob);\r\n        const a = document.createElement(\"a\");\r\n        document.body.appendChild(a);\r\n        a.style.display = \"none\";\r\n        a.href = url;\r\n        a.download = fileName;\r\n        a.addEventListener(\"click\", () => {\r\n            if (a.parentElement) {\r\n                a.parentElement.removeChild(a);\r\n            }\r\n        });\r\n        a.click();\r\n        window.URL.revokeObjectURL(url);\r\n    }\r\n\r\n    /**\r\n     * Will return the right value of the noPreventDefault variable\r\n     * Needed to keep backwards compatibility to the old API.\r\n     *\r\n     * @param args arguments passed to the attachControl function\r\n     * @returns the correct value for noPreventDefault\r\n     */\r\n    public static BackCompatCameraNoPreventDefault(args: IArguments): boolean {\r\n        // is it used correctly?\r\n        if (typeof args[0] === \"boolean\") {\r\n            return args[0];\r\n        } else if (typeof args[1] === \"boolean\") {\r\n            return args[1];\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CreateScreenshot(\r\n        engine: AbstractEngine,\r\n        camera: Camera,\r\n        size: IScreenshotSize | number,\r\n        successCallback?: (data: string) => void,\r\n        mimeType = \"image/png\",\r\n        forceDownload = false,\r\n        quality?: number\r\n    ): void {\r\n        throw _WarnImport(\"ScreenshotTools\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CreateScreenshotAsync(engine: AbstractEngine, camera: Camera, size: IScreenshotSize | number, mimeType = \"image/png\", quality?: number): Promise<string> {\r\n        throw _WarnImport(\"ScreenshotTools\");\r\n    }\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CreateScreenshotUsingRenderTarget(\r\n        engine: AbstractEngine,\r\n        camera: Camera,\r\n        size: IScreenshotSize | number,\r\n        successCallback?: (data: string) => void,\r\n        mimeType = \"image/png\",\r\n        samples = 1,\r\n        antialiasing = false,\r\n        fileName?: string,\r\n        renderSprites = false,\r\n        enableStencilBuffer = false,\r\n        useLayerMask = true,\r\n        quality?: number\r\n    ): void {\r\n        throw _WarnImport(\"ScreenshotTools\");\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static CreateScreenshotUsingRenderTargetAsync(\r\n        engine: AbstractEngine,\r\n        camera: Camera,\r\n        size: IScreenshotSize | number,\r\n        mimeType = \"image/png\",\r\n        samples = 1,\r\n        antialiasing = false,\r\n        fileName?: string,\r\n        renderSprites = false,\r\n        enableStencilBuffer = false,\r\n        useLayerMask = true,\r\n        quality?: number\r\n    ): Promise<string> {\r\n        throw _WarnImport(\"ScreenshotTools\");\r\n    }\r\n\r\n    /**\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a pseudo random id\r\n     */\r\n    public static RandomId(): string {\r\n        return RandomGUID();\r\n    }\r\n\r\n    /**\r\n     * Test if the given uri is a base64 string\r\n     * @deprecated Please use FileTools.IsBase64DataUrl instead.\r\n     * @param uri The uri to test\r\n     * @returns True if the uri is a base64 string or false otherwise\r\n     */\r\n    public static IsBase64(uri: string): boolean {\r\n        return IsBase64DataUrl(uri);\r\n    }\r\n\r\n    /**\r\n     * Decode the given base64 uri.\r\n     * @deprecated Please use FileTools.DecodeBase64UrlToBinary instead.\r\n     * @param uri The uri to decode\r\n     * @returns The decoded base64 data.\r\n     */\r\n    public static DecodeBase64(uri: string): ArrayBuffer {\r\n        return DecodeBase64UrlToBinary(uri);\r\n    }\r\n\r\n    // eslint-disable-next-line jsdoc/require-returns-check, jsdoc/require-param\r\n    /**\r\n     * @returns the absolute URL of a given (relative) url\r\n     */\r\n    public static GetAbsoluteUrl: (url: string) => string =\r\n        typeof document === \"object\"\r\n            ? (url) => {\r\n                  const a = document.createElement(\"a\");\r\n                  a.href = url;\r\n                  return a.href;\r\n              }\r\n            : typeof URL === \"function\" && typeof location === \"object\"\r\n              ? (url) => new URL(url, location.origin).href\r\n              : () => {\r\n                    throw new Error(\"Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.\");\r\n                };\r\n\r\n    // Logs\r\n    /**\r\n     * No log\r\n     */\r\n    public static readonly NoneLogLevel = Logger.NoneLogLevel;\r\n    /**\r\n     * Only message logs\r\n     */\r\n    public static readonly MessageLogLevel = Logger.MessageLogLevel;\r\n    /**\r\n     * Only warning logs\r\n     */\r\n    public static readonly WarningLogLevel = Logger.WarningLogLevel;\r\n    /**\r\n     * Only error logs\r\n     */\r\n    public static readonly ErrorLogLevel = Logger.ErrorLogLevel;\r\n    /**\r\n     * All logs\r\n     */\r\n    public static readonly AllLogLevel = Logger.AllLogLevel;\r\n\r\n    /**\r\n     * Gets a value indicating the number of loading errors\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get errorsCount(): number {\r\n        return Logger.errorsCount;\r\n    }\r\n\r\n    /**\r\n     * Callback called when a new log is added\r\n     */\r\n    public static OnNewCacheEntry: (entry: string) => void;\r\n\r\n    /**\r\n     * Log a message to the console\r\n     * @param message defines the message to log\r\n     */\r\n    public static Log(message: string): void {\r\n        Logger.Log(message);\r\n    }\r\n\r\n    /**\r\n     * Write a warning message to the console\r\n     * @param message defines the message to log\r\n     */\r\n    public static Warn(message: string): void {\r\n        Logger.Warn(message);\r\n    }\r\n\r\n    /**\r\n     * Write an error message to the console\r\n     * @param message defines the message to log\r\n     */\r\n    public static Error(message: string): void {\r\n        Logger.Error(message);\r\n    }\r\n\r\n    /**\r\n     * Gets current log cache (list of logs)\r\n     */\r\n    public static get LogCache(): string {\r\n        return Logger.LogCache;\r\n    }\r\n\r\n    /**\r\n     * Clears the log cache\r\n     */\r\n    public static ClearLogCache(): void {\r\n        Logger.ClearLogCache();\r\n    }\r\n\r\n    /**\r\n     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\r\n     */\r\n    public static set LogLevels(level: number) {\r\n        Logger.LogLevels = level;\r\n    }\r\n\r\n    /**\r\n     * Checks if the window object exists\r\n     * Back Compat only, please use IsWindowObjectExist instead.\r\n     */\r\n    public static IsWindowObjectExist = IsWindowObjectExist;\r\n\r\n    // Performances\r\n\r\n    /**\r\n     * No performance log\r\n     */\r\n    public static readonly PerformanceNoneLogLevel = 0;\r\n    /**\r\n     * Use user marks to log performance\r\n     */\r\n    public static readonly PerformanceUserMarkLogLevel = 1;\r\n    /**\r\n     * Log performance to the console\r\n     */\r\n    public static readonly PerformanceConsoleLogLevel = 2;\r\n\r\n    private static _Performance: Performance;\r\n\r\n    /**\r\n     * Sets the current performance log level\r\n     */\r\n    public static set PerformanceLogLevel(level: number) {\r\n        if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {\r\n            Tools.StartPerformanceCounter = Tools._StartUserMark;\r\n            Tools.EndPerformanceCounter = Tools._EndUserMark;\r\n            return;\r\n        }\r\n\r\n        if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {\r\n            Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;\r\n            Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;\r\n            return;\r\n        }\r\n\r\n        Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\r\n        Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private static _StartPerformanceCounterDisabled(counterName: string, condition?: boolean): void {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private static _EndPerformanceCounterDisabled(counterName: string, condition?: boolean): void {}\r\n\r\n    private static _StartUserMark(counterName: string, condition = true): void {\r\n        if (!Tools._Performance) {\r\n            if (!IsWindowObjectExist()) {\r\n                return;\r\n            }\r\n            Tools._Performance = window.performance;\r\n        }\r\n\r\n        if (!condition || !Tools._Performance.mark) {\r\n            return;\r\n        }\r\n        Tools._Performance.mark(counterName + \"-Begin\");\r\n    }\r\n\r\n    private static _EndUserMark(counterName: string, condition = true): void {\r\n        if (!condition || !Tools._Performance.mark) {\r\n            return;\r\n        }\r\n        Tools._Performance.mark(counterName + \"-End\");\r\n        Tools._Performance.measure(counterName, counterName + \"-Begin\", counterName + \"-End\");\r\n    }\r\n\r\n    private static _StartPerformanceConsole(counterName: string, condition = true): void {\r\n        if (!condition) {\r\n            return;\r\n        }\r\n\r\n        Tools._StartUserMark(counterName, condition);\r\n\r\n        if (console.time) {\r\n            console.time(counterName);\r\n        }\r\n    }\r\n\r\n    private static _EndPerformanceConsole(counterName: string, condition = true): void {\r\n        if (!condition) {\r\n            return;\r\n        }\r\n\r\n        Tools._EndUserMark(counterName, condition);\r\n\r\n        console.timeEnd(counterName);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter\r\n     */\r\n    public static StartPerformanceCounter: (counterName: string, condition?: boolean) => void = Tools._StartPerformanceCounterDisabled;\r\n\r\n    /**\r\n     * Ends a specific performance counter\r\n     */\r\n    public static EndPerformanceCounter: (counterName: string, condition?: boolean) => void = Tools._EndPerformanceCounterDisabled;\r\n\r\n    /**\r\n     * Gets either window.performance.now() if supported or Date.now() else\r\n     */\r\n    public static get Now(): number {\r\n        return PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * This method will return the name of the class used to create the instance of the given object.\r\n     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.\r\n     * @param object the object to get the class name from\r\n     * @param isType defines if the object is actually a type\r\n     * @returns the name of the class, will be \"object\" for a custom data type not using the @className decorator\r\n     */\r\n    public static GetClassName(object: any, isType = false): string {\r\n        let name = null;\r\n\r\n        if (!isType && object.getClassName) {\r\n            name = object.getClassName();\r\n        } else {\r\n            if (object instanceof Object) {\r\n                const classObj = isType ? object : Object.getPrototypeOf(object);\r\n                name = classObj.constructor[\"__bjsclassName__\"];\r\n            }\r\n            if (!name) {\r\n                name = typeof object;\r\n            }\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Gets the first element of an array satisfying a given predicate\r\n     * @param array defines the array to browse\r\n     * @param predicate defines the predicate to use\r\n     * @returns null if not found or the element\r\n     */\r\n    public static First<T>(array: Array<T>, predicate: (item: T) => boolean): Nullable<T> {\r\n        for (const el of array) {\r\n            if (predicate(el)) {\r\n                return el;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This method will return the name of the full name of the class, including its owning module (if any).\r\n     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).\r\n     * @param object the object to get the class name from\r\n     * @param isType defines if the object is actually a type\r\n     * @returns a string that can have two forms: \"moduleName.className\" if module was specified when the class' Name was registered or \"className\" if there was not module specified.\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static getFullClassName(object: any, isType = false): Nullable<string> {\r\n        let className = null;\r\n        let moduleName = null;\r\n\r\n        if (!isType && object.getClassName) {\r\n            className = object.getClassName();\r\n        } else {\r\n            if (object instanceof Object) {\r\n                const classObj = isType ? object : Object.getPrototypeOf(object);\r\n                className = classObj.constructor[\"__bjsclassName__\"];\r\n                moduleName = classObj.constructor[\"__bjsmoduleName__\"];\r\n            }\r\n            if (!className) {\r\n                className = typeof object;\r\n            }\r\n        }\r\n\r\n        if (!className) {\r\n            return null;\r\n        }\r\n\r\n        return (moduleName != null ? moduleName + \".\" : \"\") + className;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves after the given amount of time.\r\n     * @param delay Number of milliseconds to delay\r\n     * @returns Promise that resolves after the given amount of time\r\n     */\r\n    public static DelayAsync(delay: number): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                resolve();\r\n            }, delay);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Utility function to detect if the current user agent is Safari\r\n     * @returns whether or not the current user agent is safari\r\n     */\r\n    public static IsSafari(): boolean {\r\n        if (!IsNavigatorAvailable()) {\r\n            return false;\r\n        }\r\n\r\n        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n    }\r\n}\r\n\r\n/**\r\n * Use this className as a decorator on a given class definition to add it a name and optionally its module.\r\n * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.\r\n * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified\r\n * @param name The name of the class, case should be preserved\r\n * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.\r\n * @returns a decorator function to apply on the class definition.\r\n */\r\nexport function className(name: string, module?: string): (target: Object) => void {\r\n    return (target: Object) => {\r\n        (<any>target)[\"__bjsclassName__\"] = name;\r\n        (<any>target)[\"__bjsmoduleName__\"] = module != null ? module : null;\r\n    };\r\n}\r\n\r\n/**\r\n * An implementation of a loop for asynchronous functions.\r\n */\r\nexport class AsyncLoop {\r\n    /**\r\n     * Defines the current index of the loop.\r\n     */\r\n    public index: number;\r\n    private _done: boolean;\r\n    private _fn: (asyncLoop: AsyncLoop) => void;\r\n    private _successCallback: () => void;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param iterations the number of iterations.\r\n     * @param func the function to run each iteration\r\n     * @param successCallback the callback that will be called upon successful execution\r\n     * @param offset starting offset.\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the number of iterations for the loop\r\n         */\r\n        public iterations: number,\r\n        func: (asyncLoop: AsyncLoop) => void,\r\n        successCallback: () => void,\r\n        offset = 0\r\n    ) {\r\n        this.index = offset - 1;\r\n        this._done = false;\r\n        this._fn = func;\r\n        this._successCallback = successCallback;\r\n    }\r\n\r\n    /**\r\n     * Execute the next iteration. Must be called after the last iteration was finished.\r\n     */\r\n    public executeNext(): void {\r\n        if (!this._done) {\r\n            if (this.index + 1 < this.iterations) {\r\n                ++this.index;\r\n                this._fn(this);\r\n            } else {\r\n                this.breakLoop();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Break the loop and run the success callback.\r\n     */\r\n    public breakLoop(): void {\r\n        this._done = true;\r\n        this._successCallback();\r\n    }\r\n\r\n    /**\r\n     * Create and run an async loop.\r\n     * @param iterations the number of iterations.\r\n     * @param fn the function to run each iteration\r\n     * @param successCallback the callback that will be called upon successful execution\r\n     * @param offset starting offset.\r\n     * @returns the created async loop object\r\n     */\r\n    public static Run(iterations: number, fn: (asyncLoop: AsyncLoop) => void, successCallback: () => void, offset = 0): AsyncLoop {\r\n        const loop = new AsyncLoop(iterations, fn, successCallback, offset);\r\n\r\n        loop.executeNext();\r\n\r\n        return loop;\r\n    }\r\n\r\n    /**\r\n     * A for-loop that will run a given number of iterations synchronous and the rest async.\r\n     * @param iterations total number of iterations\r\n     * @param syncedIterations number of synchronous iterations in each async iteration.\r\n     * @param fn the function to call each iteration.\r\n     * @param callback a success call back that will be called when iterating stops.\r\n     * @param breakFunction a break condition (optional)\r\n     * @param timeout timeout settings for the setTimeout function. default - 0.\r\n     * @returns the created async loop object\r\n     */\r\n    public static SyncAsyncForLoop(\r\n        iterations: number,\r\n        syncedIterations: number,\r\n        fn: (iteration: number) => void,\r\n        callback: () => void,\r\n        breakFunction?: () => boolean,\r\n        timeout = 0\r\n    ): AsyncLoop {\r\n        return AsyncLoop.Run(\r\n            Math.ceil(iterations / syncedIterations),\r\n            (loop: AsyncLoop) => {\r\n                if (breakFunction && breakFunction()) {\r\n                    loop.breakLoop();\r\n                } else {\r\n                    setTimeout(() => {\r\n                        for (let i = 0; i < syncedIterations; ++i) {\r\n                            const iteration = loop.index * syncedIterations + i;\r\n                            if (iteration >= iterations) {\r\n                                break;\r\n                            }\r\n                            fn(iteration);\r\n                            if (breakFunction && breakFunction()) {\r\n                                loop.breakLoop();\r\n                                break;\r\n                            }\r\n                        }\r\n                        loop.executeNext();\r\n                    }, timeout);\r\n                }\r\n            },\r\n            callback\r\n        );\r\n    }\r\n}\r\n\r\nTools.Mix = Mix;\r\nTools.IsExponentOfTwo = IsExponentOfTwo;\r\n\r\n// Will only be define if Tools is imported freeing up some space when only engine is required\r\nEngineStore.FallbackTexture =\r\n    \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\";\r\n", "/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n", "import { AndOrNotEvaluator } from \"./andOrNotEvaluator\";\r\n\r\n/**\r\n * Class used to store custom tags\r\n */\r\nexport class Tags {\r\n    /**\r\n     * Adds support for tags on the given object\r\n     * @param obj defines the object to use\r\n     */\r\n    public static EnableFor(obj: any): void {\r\n        obj._tags = obj._tags || {};\r\n\r\n        obj.hasTags = () => {\r\n            return Tags.HasTags(obj);\r\n        };\r\n\r\n        obj.addTags = (tagsString: string) => {\r\n            return Tags.AddTagsTo(obj, tagsString);\r\n        };\r\n\r\n        obj.removeTags = (tagsString: string) => {\r\n            return Tags.RemoveTagsFrom(obj, tagsString);\r\n        };\r\n\r\n        obj.matchesTagsQuery = (tagsQuery: string) => {\r\n            return Tags.MatchesQuery(obj, tagsQuery);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes tags support\r\n     * @param obj defines the object to use\r\n     */\r\n    public static DisableFor(obj: any): void {\r\n        delete obj._tags;\r\n        delete obj.hasTags;\r\n        delete obj.addTags;\r\n        delete obj.removeTags;\r\n        delete obj.matchesTagsQuery;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given object has tags\r\n     * @param obj defines the object to use\r\n     * @returns a boolean\r\n     */\r\n    public static HasTags(obj: any): boolean {\r\n        if (!obj._tags) {\r\n            return false;\r\n        }\r\n\r\n        const tags = obj._tags;\r\n        for (const i in tags) {\r\n            if (Object.prototype.hasOwnProperty.call(tags, i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the tags available on a given object\r\n     * @param obj defines the object to use\r\n     * @param asString defines if the tags must be returned as a string instead of an array of strings\r\n     * @returns the tags\r\n     */\r\n    public static GetTags(obj: any, asString: boolean = true): any {\r\n        if (!obj._tags) {\r\n            return null;\r\n        }\r\n        if (asString) {\r\n            const tagsArray = [];\r\n            for (const tag in obj._tags) {\r\n                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {\r\n                    tagsArray.push(tag);\r\n                }\r\n            }\r\n            return tagsArray.join(\" \");\r\n        } else {\r\n            return obj._tags;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds tags to an object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.\r\n     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces\r\n     */\r\n    public static AddTagsTo(obj: any, tagsString: string): void {\r\n        if (!tagsString) {\r\n            return;\r\n        }\r\n\r\n        if (typeof tagsString !== \"string\") {\r\n            return;\r\n        }\r\n\r\n        const tags = tagsString.split(\" \");\r\n        tags.forEach(function (tag) {\r\n            Tags._AddTagTo(obj, tag);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _AddTagTo(obj: any, tag: string): void {\r\n        tag = tag.trim();\r\n\r\n        if (tag === \"\" || tag === \"true\" || tag === \"false\") {\r\n            return;\r\n        }\r\n\r\n        if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\r\n            return;\r\n        }\r\n\r\n        Tags.EnableFor(obj);\r\n        obj._tags[tag] = true;\r\n    }\r\n\r\n    /**\r\n     * Removes specific tags from a specific object\r\n     * @param obj defines the object to use\r\n     * @param tagsString defines the tags to remove\r\n     */\r\n    public static RemoveTagsFrom(obj: any, tagsString: string) {\r\n        if (!Tags.HasTags(obj)) {\r\n            return;\r\n        }\r\n        const tags = tagsString.split(\" \");\r\n        for (const t in tags) {\r\n            Tags._RemoveTagFrom(obj, tags[t]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveTagFrom(obj: any, tag: string): void {\r\n        delete obj._tags[tag];\r\n    }\r\n\r\n    /**\r\n     * Defines if tags hosted on an object match a given query\r\n     * @param obj defines the object to use\r\n     * @param tagsQuery defines the tag query\r\n     * @returns a boolean\r\n     */\r\n    public static MatchesQuery(obj: any, tagsQuery: string): boolean {\r\n        if (tagsQuery === undefined) {\r\n            return true;\r\n        }\r\n\r\n        if (tagsQuery === \"\") {\r\n            return Tags.HasTags(obj);\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);\r\n    }\r\n}\r\n", "import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n", "/**\r\n * Interface for the size containing width and height\r\n */\r\nexport interface ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Size containing width and height\r\n */\r\nexport class Size implements ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    public width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    public height: number;\r\n\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    public constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    public toString(): string {\r\n        return `{W: ${this.width}, H: ${this.height}}`;\r\n    }\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Size\";\r\n    }\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.width | 0;\r\n        hash = (hash * 397) ^ (this.height | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    public copyFrom(src: Size) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    public copyFromFloats(width: number, height: number): Size {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    public set(width: number, height: number): Size {\r\n        return this.copyFromFloats(width, height);\r\n    }\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public multiplyByFloats(w: number, h: number): Size {\r\n        return new Size(this.width * w, this.height * h);\r\n    }\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    public clone(): Size {\r\n        return new Size(this.width, this.height);\r\n    }\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    public equals(other: Size): boolean {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    /**\r\n     * The surface of the Size : width * height (float).\r\n     */\r\n    public get surface(): number {\r\n        return this.width * this.height;\r\n    }\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    public static Zero(): Size {\r\n        return new Size(0.0, 0.0);\r\n    }\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    public add(otherSize: Size): Size {\r\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    public subtract(otherSize: Size): Size {\r\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Scales the width and height\r\n     * @param scale the scale to multiply the width and height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public scale(scale: number): Size {\r\n        return new Size(this.width * scale, this.height * scale);\r\n    }\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    public static Lerp(start: Size, end: Size, amount: number): Size {\r\n        const w = start.width + (end.width - start.width) * amount;\r\n        const h = start.height + (end.height - start.height) * amount;\r\n\r\n        return new Size(w, h);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<AbstractEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?.shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in AbstractEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n", "import type { DrawWrapper } from \"./drawWrapper\";\r\nimport type { Effect } from \"./effect\";\r\n\r\n/**\r\n * Detect if the effect is a DrawWrapper\r\n * @param effect defines the entity to test\r\n * @returns if the entity is a DrawWrapper\r\n */\r\nexport function IsWrapper(effect: Effect | DrawWrapper): effect is DrawWrapper {\r\n    return (effect as Effect).getPipelineContext === undefined;\r\n}\r\n", "import { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { IShaderProcessor } from \"../Processors/iShaderProcessor\";\r\n\r\nconst varyingRegex = /(flat\\s)?\\s*varying\\s*.*/;\r\n\r\n/** @internal */\r\nexport class WebGL2ShaderProcessor implements IShaderProcessor {\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    public attributeProcessor(attribute: string) {\r\n        return attribute.replace(\"attribute\", \"in\");\r\n    }\r\n\r\n    public varyingCheck(varying: string, _isFragment: boolean) {\r\n        return varyingRegex.test(varying);\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean) {\r\n        return varying.replace(\"varying\", isFragment ? \"in\" : \"out\");\r\n    }\r\n\r\n    public postProcessor(code: string, defines: string[], isFragment: boolean) {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n        } else {\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGLDataBuffer extends DataBuffer {\r\n    private _buffer: Nullable<WebGLBuffer>;\r\n\r\n    public constructor(resource: WebGLBuffer) {\r\n        super();\r\n        this._buffer = resource;\r\n    }\r\n\r\n    public override get underlyingResource(): any {\r\n        return this._buffer;\r\n    }\r\n}\r\n", "import type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/** @internal */\r\nexport class WebGLHardwareTexture implements HardwareTextureWrapper {\r\n    private _webGLTexture: WebGLTexture;\r\n    private _context: WebGLRenderingContext;\r\n\r\n    // There can be multiple buffers for a single WebGL texture because different layers of a 2DArrayTexture / 3DTexture\r\n    // or different faces of a cube texture can be bound to different render targets at the same time.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private _MSAARenderBuffers: Nullable<WebGLRenderbuffer[]> = null;\r\n\r\n    public get underlyingResource(): Nullable<WebGLTexture> {\r\n        return this._webGLTexture;\r\n    }\r\n\r\n    constructor(existingTexture: Nullable<WebGLTexture> = null, context: WebGLRenderingContext) {\r\n        this._context = context as WebGLRenderingContext;\r\n        if (!existingTexture) {\r\n            existingTexture = context.createTexture();\r\n            if (!existingTexture) {\r\n                throw new Error(\"Unable to create webGL texture\");\r\n            }\r\n        }\r\n        this.set(existingTexture);\r\n    }\r\n\r\n    public setUsage(): void {}\r\n\r\n    public set(hardwareTexture: WebGLTexture) {\r\n        this._webGLTexture = hardwareTexture;\r\n    }\r\n\r\n    public reset() {\r\n        this._webGLTexture = null as any;\r\n        this._MSAARenderBuffers = null;\r\n    }\r\n\r\n    public addMSAARenderBuffer(buffer: WebGLRenderbuffer) {\r\n        if (!this._MSAARenderBuffers) {\r\n            this._MSAARenderBuffers = [];\r\n        }\r\n        this._MSAARenderBuffers.push(buffer);\r\n    }\r\n\r\n    public releaseMSAARenderBuffers() {\r\n        if (this._MSAARenderBuffers) {\r\n            for (const buffer of this._MSAARenderBuffers) {\r\n                this._context.deleteRenderbuffer(buffer);\r\n            }\r\n            this._MSAARenderBuffers = null;\r\n        }\r\n    }\r\n\r\n    public getMSAARenderBuffer(index = 0) {\r\n        return this._MSAARenderBuffers?.[index] ?? null;\r\n    }\r\n\r\n    public release() {\r\n        this.releaseMSAARenderBuffers();\r\n\r\n        if (this._webGLTexture) {\r\n            this._context.deleteTexture(this._webGLTexture);\r\n        }\r\n        this.reset();\r\n    }\r\n}\r\n", "import { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IShaderProcessor } from \"../Processors/iShaderProcessor\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\n\r\n/** @internal */\r\nexport class WebGLShaderProcessor implements IShaderProcessor {\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    public postProcessor(\r\n        code: string,\r\n        defines: string[],\r\n        isFragment: boolean,\r\n        processingContext: Nullable<ShaderProcessingContext>,\r\n        parameters: { [key: string]: number | string | boolean | undefined }\r\n    ) {\r\n        // Remove extensions\r\n        if (parameters.drawBuffersExtensionDisabled) {\r\n            // even if enclosed in #if/#endif, IE11 does parse the #extension declaration, so we need to remove it altogether\r\n            const regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;\r\n            code = code.replace(regex, \"\");\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { IEffectCreationOptions, IShaderPath } from \"../Materials/effect\";\r\nimport type { ShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport type { Nullable, DataArray, IndicesArray, FloatArray, DeepImmutable } from \"../types\";\r\nimport type { IColor4Like } from \"../Maths/math.like\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { WebGLPipelineContext } from \"./WebGL/webGLPipelineContext\";\r\nimport type { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { InstancingAttributeInfo } from \"./instancingAttributeInfo\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { IEffectFallbacks } from \"../Materials/iEffectFallbacks\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"./ICanvas\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { InternalTextureCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"./WebGL/webGLRenderTargetWrapper\";\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport {\r\n    createPipelineContext,\r\n    createRawShaderProgram,\r\n    createShaderProgram,\r\n    _finalizePipelineContext,\r\n    _preparePipelineContext,\r\n    _setProgram,\r\n    _executeWhenRenderingStateIsCompiled,\r\n    getStateObject,\r\n    _createShaderProgram,\r\n    deleteStateObject,\r\n} from \"./thinEngine.functions\";\r\n\r\nimport type { AbstractEngineOptions, ISceneLike, PrepareTextureFunction, PrepareTextureProcessFunction } from \"./abstractEngine\";\r\nimport type { PerformanceMonitor } from \"../Misc/performanceMonitor\";\r\nimport { IsWrapper } from \"../Materials/drawWrapper.functions\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { WebGLShaderProcessor } from \"./WebGL/webGLShaderProcessors\";\r\nimport { WebGL2ShaderProcessor } from \"./WebGL/webGL2ShaderProcessors\";\r\nimport { WebGLDataBuffer } from \"../Meshes/WebGL/webGLDataBuffer\";\r\nimport { CeilingPOT, FloorPOT, GetExponentOfTwo, NearestPOT } from \"../Misc/tools.functions\";\r\nimport { AbstractEngine, QueueNewFrame } from \"./abstractEngine\";\r\nimport { Constants } from \"./constants\";\r\nimport { WebGLHardwareTexture } from \"./WebGL/webGLHardwareTexture\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { _ConcatenateShader, _getGlobalDefines } from \"./abstractEngine.functions\";\r\nimport { resetCachedPipeline } from \"core/Materials/effect.functions\";\r\n\r\n/**\r\n * Keeps track of all the buffer info used in engine.\r\n */\r\nclass BufferPointer {\r\n    public active: boolean;\r\n    public index: number;\r\n    public size: number;\r\n    public type: number;\r\n    public normalized: boolean;\r\n    public stride: number;\r\n    public offset: number;\r\n    public buffer: WebGLBuffer;\r\n}\r\n\r\n/** Interface defining initialization parameters for Engine class */\r\nexport interface EngineOptions extends AbstractEngineOptions, WebGLContextAttributes {\r\n    /**\r\n     * Defines if webgl2 should be turned off even if supported\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2\r\n     */\r\n    disableWebGL2Support?: boolean;\r\n\r\n    /**\r\n     * Defines that engine should compile shaders with high precision floats (if supported). True by default\r\n     */\r\n    useHighPrecisionFloats?: boolean;\r\n    /**\r\n     * Make the canvas XR Compatible for XR sessions\r\n     */\r\n    xrCompatible?: boolean;\r\n\r\n    /**\r\n     * Will prevent the system from falling back to software implementation if a hardware device cannot be created\r\n     */\r\n    failIfMajorPerformanceCaveat?: boolean;\r\n\r\n    /**\r\n     * If sRGB Buffer support is not set during construction, use this value to force a specific state\r\n     * This is added due to an issue when processing textures in chrome/edge/firefox\r\n     * This will not influence NativeEngine and WebGPUEngine which set the behavior to true during construction.\r\n     */\r\n    forceSRGBBufferSupportState?: boolean;\r\n\r\n    /**\r\n     * Defines if the gl context should be released.\r\n     * It's false by default for backward compatibility, but you should probably pass true (see https://registry.khronos.org/webgl/extensions/WEBGL_lose_context/)\r\n     */\r\n    loseContextOnDispose?: boolean;\r\n}\r\n\r\n/**\r\n * The base engine class (root of all engines)\r\n */\r\nexport class ThinEngine extends AbstractEngine {\r\n    private static _TempClearColorUint32 = new Uint32Array(4);\r\n    private static _TempClearColorInt32 = new Int32Array(4);\r\n\r\n    /** Use this array to turn off some WebGL2 features on known buggy browsers version */\r\n    public static ExceptionList = [\r\n        { key: \"Chrome/63.0\", capture: \"63\\\\.0\\\\.3239\\\\.(\\\\d+)\", captureConstraint: 108, targets: [\"uniformBuffer\"] },\r\n        { key: \"Firefox/58\", capture: null, captureConstraint: null, targets: [\"uniformBuffer\"] },\r\n        { key: \"Firefox/59\", capture: null, captureConstraint: null, targets: [\"uniformBuffer\"] },\r\n        { key: \"Chrome/72.+?Mobile\", capture: null, captureConstraint: null, targets: [\"vao\"] },\r\n        { key: \"Chrome/73.+?Mobile\", capture: null, captureConstraint: null, targets: [\"vao\"] },\r\n        { key: \"Chrome/74.+?Mobile\", capture: null, captureConstraint: null, targets: [\"vao\"] },\r\n        { key: \"Mac OS.+Chrome/71\", capture: null, captureConstraint: null, targets: [\"vao\"] },\r\n        { key: \"Mac OS.+Chrome/72\", capture: null, captureConstraint: null, targets: [\"vao\"] },\r\n        { key: \"Mac OS.+Chrome\", capture: null, captureConstraint: null, targets: [\"uniformBuffer\"] },\r\n        { key: \"Chrome/12\\\\d\\\\..+?Mobile\", capture: null, captureConstraint: null, targets: [\"uniformBuffer\"] },\r\n        // desktop osx safari 15.4\r\n        { key: \".*AppleWebKit.*(15.4).*Safari\", capture: null, captureConstraint: null, targets: [\"antialias\", \"maxMSAASamples\"] },\r\n        // mobile browsers using safari 15.4 on ios\r\n        { key: \".*(15.4).*AppleWebKit.*Safari\", capture: null, captureConstraint: null, targets: [\"antialias\", \"maxMSAASamples\"] },\r\n    ];\r\n\r\n    /** @internal */\r\n    protected override _name = \"WebGL\";\r\n\r\n    /**\r\n     * Gets or sets the name of the engine\r\n     */\r\n    public override get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    public override set name(value: string) {\r\n        this._name = value;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the engine\r\n     */\r\n    public get version(): number {\r\n        return this._webGLVersion;\r\n    }\r\n\r\n    // Updatable statics so stick with vars here\r\n\r\n    /**\r\n     * Gets or sets the epsilon value used by collision engine\r\n     */\r\n    public static CollisionsEpsilon = 0.001;\r\n\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return Effect.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(value: string) {\r\n        Effect.ShadersRepository = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required\r\n     */\r\n    public forcePOTTextures = false;\r\n\r\n    /** Gets or sets a boolean indicating if the engine should validate programs after compilation */\r\n    public validateShaderPrograms = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported\r\n     */\r\n    public disableUniformBuffers = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine supports uniform buffers\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n     */\r\n    public get supportsUniformBuffers(): boolean {\r\n        return this.webGLVersion > 1 && !this.disableUniformBuffers;\r\n    }\r\n\r\n    // Private Members\r\n\r\n    /** @internal */\r\n    public _gl: WebGL2RenderingContext;\r\n    /** @internal */\r\n    public _webGLVersion = 1.0;\r\n\r\n    /** @internal */\r\n    public _glSRGBExtensionValues: {\r\n        SRGB: typeof WebGL2RenderingContext.SRGB;\r\n        SRGB8: typeof WebGL2RenderingContext.SRGB8 | EXT_sRGB[\"SRGB_ALPHA_EXT\"];\r\n        SRGB8_ALPHA8: typeof WebGL2RenderingContext.SRGB8_ALPHA8 | EXT_sRGB[\"SRGB_ALPHA_EXT\"];\r\n    };\r\n\r\n    /**\r\n     * Gets a boolean indicating that only power of 2 textures are supported\r\n     * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\r\n     */\r\n    public get needPOTTextures(): boolean {\r\n        return this._webGLVersion < 2 || this.forcePOTTextures;\r\n    }\r\n\r\n    private _glVersion: string;\r\n    private _glRenderer: string;\r\n    private _glVendor: string;\r\n\r\n    // Cache\r\n\r\n    /** @internal */\r\n    public _currentMaterialContext: IMaterialContext;\r\n    /** @internal */\r\n    protected _currentProgram: Nullable<WebGLProgram>;\r\n    private _vertexAttribArraysEnabled: boolean[] = [];\r\n    private _cachedVertexArrayObject: Nullable<WebGLVertexArrayObject>;\r\n\r\n    private _uintIndicesCurrentlySet = false;\r\n    protected _currentBoundBuffer = new Array<Nullable<DataBuffer>>();\r\n    /** @internal */\r\n    public _currentFramebuffer: Nullable<WebGLFramebuffer> = null;\r\n    /** @internal */\r\n    public _dummyFramebuffer: Nullable<WebGLFramebuffer> = null;\r\n    private _currentBufferPointers = new Array<BufferPointer>();\r\n    private _currentInstanceLocations = new Array<number>();\r\n    private _currentInstanceBuffers = new Array<DataBuffer>();\r\n    private _textureUnits: Int32Array;\r\n\r\n    /** @internal */\r\n    public _workingCanvas: Nullable<ICanvas>;\r\n    /** @internal */\r\n    public _workingContext: Nullable<ICanvasRenderingContext>;\r\n\r\n    private _vaoRecordInProgress = false;\r\n    private _mustWipeVertexAttributes = false;\r\n\r\n    private _nextFreeTextureSlots = new Array<number>();\r\n    private _maxSimultaneousTextures = 0;\r\n    private _maxMSAASamplesOverride: Nullable<number> = null;\r\n\r\n    protected get _supportsHardwareTextureRescaling() {\r\n        return false;\r\n    }\r\n\r\n    protected _framebufferDimensionsObject: Nullable<{ framebufferWidth: number; framebufferHeight: number }>;\r\n\r\n    /**\r\n     * sets the object from which width and height will be taken from when getting render width and height\r\n     * Will fallback to the gl object\r\n     * @param dimensions the framebuffer width and height that will be used.\r\n     */\r\n    public set framebufferDimensionsObject(dimensions: Nullable<{ framebufferWidth: number; framebufferHeight: number }>) {\r\n        this._framebufferDimensionsObject = dimensions;\r\n    }\r\n\r\n    /**\r\n     * Creates a new snapshot at the next frame using the current snapshotRenderingMode\r\n     */\r\n    public snapshotRenderingReset(): void {\r\n        this.snapshotRendering = false;\r\n    }\r\n\r\n    /**\r\n     * Creates a new engine\r\n     * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context\r\n     * @param antialias defines whether anti-aliasing should be enabled (default value is \"undefined\", meaning that the browser may or may not enable it)\r\n     * @param options defines further options to be sent to the getContext() function\r\n     * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    constructor(\r\n        canvasOrContext: Nullable<HTMLCanvasElement | OffscreenCanvas | WebGLRenderingContext | WebGL2RenderingContext>,\r\n        antialias?: boolean,\r\n        options?: EngineOptions,\r\n        adaptToDeviceRatio?: boolean\r\n    ) {\r\n        options = options || {};\r\n        super(antialias ?? options.antialias, options, adaptToDeviceRatio);\r\n\r\n        if (!canvasOrContext) {\r\n            return;\r\n        }\r\n\r\n        let canvas: Nullable<HTMLCanvasElement> = null;\r\n        if ((canvasOrContext as any).getContext) {\r\n            canvas = <HTMLCanvasElement>canvasOrContext;\r\n            this._renderingCanvas = canvas;\r\n\r\n            if (options.preserveDrawingBuffer === undefined) {\r\n                options.preserveDrawingBuffer = false;\r\n            }\r\n\r\n            if (options.xrCompatible === undefined) {\r\n                options.xrCompatible = false;\r\n            }\r\n\r\n            // Exceptions\r\n            if (navigator && navigator.userAgent) {\r\n                this._setupMobileChecks();\r\n\r\n                const ua = navigator.userAgent;\r\n                for (const exception of ThinEngine.ExceptionList) {\r\n                    const key = exception.key;\r\n                    const targets = exception.targets;\r\n                    const check = new RegExp(key);\r\n\r\n                    if (check.test(ua)) {\r\n                        if (exception.capture && exception.captureConstraint) {\r\n                            const capture = exception.capture;\r\n                            const constraint = exception.captureConstraint;\r\n\r\n                            const regex = new RegExp(capture);\r\n                            const matches = regex.exec(ua);\r\n\r\n                            if (matches && matches.length > 0) {\r\n                                const capturedValue = parseInt(matches[matches.length - 1]);\r\n                                if (capturedValue >= constraint) {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        for (const target of targets) {\r\n                            switch (target) {\r\n                                case \"uniformBuffer\":\r\n                                    this.disableUniformBuffers = true;\r\n                                    break;\r\n                                case \"vao\":\r\n                                    this.disableVertexArrayObjects = true;\r\n                                    break;\r\n                                case \"antialias\":\r\n                                    options.antialias = false;\r\n                                    break;\r\n                                case \"maxMSAASamples\":\r\n                                    this._maxMSAASamplesOverride = 1;\r\n                                    break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Context lost\r\n            if (!this._doNotHandleContextLost) {\r\n                this._onContextLost = (evt: Event) => {\r\n                    evt.preventDefault();\r\n                    this._contextWasLost = true;\r\n                    Logger.Warn(\"WebGL context lost.\");\r\n\r\n                    this.onContextLostObservable.notifyObservers(this);\r\n                };\r\n\r\n                this._onContextRestored = () => {\r\n                    this._restoreEngineAfterContextLost(() => this._initGLContext());\r\n                };\r\n\r\n                canvas.addEventListener(\"webglcontextlost\", this._onContextLost, false);\r\n                canvas.addEventListener(\"webglcontextrestored\", this._onContextRestored, false);\r\n\r\n                options.powerPreference = options.powerPreference || \"high-performance\";\r\n            }\r\n\r\n            if (this._badDesktopOS) {\r\n                options.xrCompatible = false;\r\n            }\r\n\r\n            // GL\r\n            if (!options.disableWebGL2Support) {\r\n                try {\r\n                    this._gl = <any>(canvas.getContext(\"webgl2\", options) || canvas.getContext(\"experimental-webgl2\", options));\r\n                    if (this._gl) {\r\n                        this._webGLVersion = 2.0;\r\n                        this._shaderPlatformName = \"WEBGL2\";\r\n\r\n                        // Prevent weird browsers to lie (yeah that happens!)\r\n                        if (!this._gl.deleteQuery) {\r\n                            this._webGLVersion = 1.0;\r\n                            this._shaderPlatformName = \"WEBGL1\";\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // Do nothing\r\n                }\r\n            }\r\n\r\n            if (!this._gl) {\r\n                if (!canvas) {\r\n                    throw new Error(\"The provided canvas is null or undefined.\");\r\n                }\r\n                try {\r\n                    this._gl = <WebGL2RenderingContext>(canvas.getContext(\"webgl\", options) || canvas.getContext(\"experimental-webgl\", options));\r\n                } catch (e) {\r\n                    throw new Error(\"WebGL not supported\");\r\n                }\r\n            }\r\n\r\n            if (!this._gl) {\r\n                throw new Error(\"WebGL not supported\");\r\n            }\r\n        } else {\r\n            this._gl = <WebGL2RenderingContext>canvasOrContext;\r\n            this._renderingCanvas = this._gl.canvas as HTMLCanvasElement;\r\n\r\n            if ((this._gl as any).renderbufferStorageMultisample) {\r\n                this._webGLVersion = 2.0;\r\n                this._shaderPlatformName = \"WEBGL2\";\r\n            } else {\r\n                this._shaderPlatformName = \"WEBGL1\";\r\n            }\r\n\r\n            const attributes = this._gl.getContextAttributes();\r\n            if (attributes) {\r\n                options.stencil = attributes.stencil;\r\n            }\r\n        }\r\n\r\n        // Ensures a consistent color space unpacking of textures cross browser.\r\n        this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);\r\n\r\n        if (options.useHighPrecisionFloats !== undefined) {\r\n            this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;\r\n        }\r\n\r\n        this.resize();\r\n\r\n        this._initGLContext();\r\n        this._initFeatures();\r\n\r\n        // Prepare buffer pointers\r\n        for (let i = 0; i < this._caps.maxVertexAttribs; i++) {\r\n            this._currentBufferPointers[i] = new BufferPointer();\r\n        }\r\n\r\n        // Shader processor\r\n        this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();\r\n\r\n        // Starting with iOS 14, we can trust the browser\r\n        // let matches = navigator.userAgent.match(/Version\\/(\\d+)/);\r\n\r\n        // if (matches && matches.length === 2) {\r\n        //     if (parseInt(matches[1]) >= 14) {\r\n        //         this._badOS = false;\r\n        //     }\r\n        // }\r\n\r\n        const versionToLog = `Babylon.js v${ThinEngine.Version}`;\r\n        Logger.Log(versionToLog + ` - ${this.description}`);\r\n\r\n        // Check setAttribute in case of workers\r\n        if (this._renderingCanvas && this._renderingCanvas.setAttribute) {\r\n            this._renderingCanvas.setAttribute(\"data-engine\", versionToLog);\r\n        }\r\n        const stateObject = getStateObject(this._gl);\r\n        // update state object with the current engine state\r\n        stateObject.validateShaderPrograms = this.validateShaderPrograms;\r\n        stateObject.parallelShaderCompile = this._caps.parallelShaderCompile;\r\n    }\r\n\r\n    protected override _clearEmptyResources(): void {\r\n        this._dummyFramebuffer = null;\r\n        super._clearEmptyResources();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderProcessingContext(shaderLanguage: ShaderLanguage): Nullable<ShaderProcessingContext> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        for (const key in this._compiledEffects) {\r\n            const effect = <Effect>this._compiledEffects[key];\r\n\r\n            if (!effect.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _initGLContext(): void {\r\n        // Caps\r\n        this._caps = {\r\n            maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),\r\n            maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),\r\n            maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\r\n            maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),\r\n            maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,\r\n            maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),\r\n            maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),\r\n            maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),\r\n            maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),\r\n            maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),\r\n            maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),\r\n            parallelShaderCompile: this._gl.getExtension(\"KHR_parallel_shader_compile\") || undefined,\r\n            standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension(\"OES_standard_derivatives\") !== null,\r\n            maxAnisotropy: 1,\r\n            astc: this._gl.getExtension(\"WEBGL_compressed_texture_astc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_astc\"),\r\n            bptc: this._gl.getExtension(\"EXT_texture_compression_bptc\") || this._gl.getExtension(\"WEBKIT_EXT_texture_compression_bptc\"),\r\n            s3tc: this._gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\"),\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            s3tc_srgb: this._gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc_srgb\"),\r\n            pvrtc: this._gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\r\n            etc1: this._gl.getExtension(\"WEBGL_compressed_texture_etc1\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_etc1\"),\r\n            etc2:\r\n                this._gl.getExtension(\"WEBGL_compressed_texture_etc\") ||\r\n                this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_etc\") ||\r\n                this._gl.getExtension(\"WEBGL_compressed_texture_es3_0\"), // also a requirement of OpenGL ES 3\r\n            textureAnisotropicFilterExtension:\r\n                this._gl.getExtension(\"EXT_texture_filter_anisotropic\") ||\r\n                this._gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\") ||\r\n                this._gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\"),\r\n            uintIndices: this._webGLVersion > 1 || this._gl.getExtension(\"OES_element_index_uint\") !== null,\r\n            fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension(\"EXT_frag_depth\") !== null,\r\n            highPrecisionShaderSupported: false,\r\n            timerQuery: this._gl.getExtension(\"EXT_disjoint_timer_query_webgl2\") || this._gl.getExtension(\"EXT_disjoint_timer_query\"),\r\n            supportOcclusionQuery: this._webGLVersion > 1,\r\n            canUseTimestampForTimerQuery: false,\r\n            drawBuffersExtension: false,\r\n            maxMSAASamples: 1,\r\n            colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension(\"EXT_color_buffer_float\")),\r\n            supportFloatTexturesResolve: false,\r\n            rg11b10ufColorRenderable: false,\r\n            colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension(\"EXT_color_buffer_half_float\")),\r\n            textureFloat: this._webGLVersion > 1 || this._gl.getExtension(\"OES_texture_float\") ? true : false,\r\n            textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension(\"OES_texture_half_float\") ? true : false,\r\n            textureHalfFloatRender: false,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: false,\r\n            textureHalfFloatLinearFiltering: false,\r\n            vertexArrayObject: false,\r\n            instancedArrays: false,\r\n            textureLOD: this._webGLVersion > 1 || this._gl.getExtension(\"EXT_shader_texture_lod\") ? true : false,\r\n            texelFetch: this._webGLVersion !== 1,\r\n            blendMinMax: false,\r\n            multiview: this._gl.getExtension(\"OVR_multiview2\"),\r\n            oculusMultiview: this._gl.getExtension(\"OCULUS_multiview\"),\r\n            depthTextureExtension: false,\r\n            canUseGLInstanceID: this._webGLVersion > 1,\r\n            canUseGLVertexID: this._webGLVersion > 1,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: false,\r\n            supportTransformFeedbacks: this._webGLVersion > 1,\r\n            textureMaxLevel: this._webGLVersion > 1,\r\n            texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,\r\n            disableMorphTargetTexture: false,\r\n        };\r\n\r\n        this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat;\r\n        this._caps.rg11b10ufColorRenderable = this._caps.colorBufferFloat;\r\n\r\n        // Infos\r\n        this._glVersion = this._gl.getParameter(this._gl.VERSION);\r\n\r\n        const rendererInfo: any = this._gl.getExtension(\"WEBGL_debug_renderer_info\");\r\n        if (rendererInfo != null) {\r\n            this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);\r\n            this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);\r\n        }\r\n\r\n        if (!this._glVendor) {\r\n            this._glVendor = this._gl.getParameter(this._gl.VENDOR) || \"Unknown vendor\";\r\n        }\r\n\r\n        if (!this._glRenderer) {\r\n            this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || \"Unknown renderer\";\r\n        }\r\n\r\n        // Constants\r\n        if (this._gl.HALF_FLOAT_OES !== 0x8d61) {\r\n            this._gl.HALF_FLOAT_OES = 0x8d61; // Half floating-point type (16-bit).\r\n        }\r\n        if (this._gl.RGBA16F !== 0x881a) {\r\n            this._gl.RGBA16F = 0x881a; // RGBA 16-bit floating-point color-renderable internal sized format.\r\n        }\r\n        if (this._gl.RGBA32F !== 0x8814) {\r\n            this._gl.RGBA32F = 0x8814; // RGBA 32-bit floating-point color-renderable internal sized format.\r\n        }\r\n        if (this._gl.DEPTH24_STENCIL8 !== 35056) {\r\n            this._gl.DEPTH24_STENCIL8 = 35056;\r\n        }\r\n\r\n        // Extensions\r\n        if (this._caps.timerQuery) {\r\n            if (this._webGLVersion === 1) {\r\n                this._gl.getQuery = (<any>this._caps.timerQuery).getQueryEXT.bind(this._caps.timerQuery);\r\n            }\r\n            // WebGLQuery casted to number to avoid TS error\r\n            this._caps.canUseTimestampForTimerQuery = ((this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) as number) ?? 0) > 0;\r\n        }\r\n\r\n        this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension\r\n            ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)\r\n            : 0;\r\n        this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension(\"OES_texture_float_linear\") ? true : false;\r\n        this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;\r\n        this._caps.textureHalfFloatLinearFiltering =\r\n            this._webGLVersion > 1 || (this._caps.textureHalfFloat && this._gl.getExtension(\"OES_texture_half_float_linear\")) ? true : false;\r\n\r\n        // Compressed formats\r\n        if (this._caps.astc) {\r\n            this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;\r\n        }\r\n        if (this._caps.bptc) {\r\n            this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;\r\n        }\r\n        if (this._caps.s3tc_srgb) {\r\n            this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;\r\n            this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\r\n            this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\r\n        }\r\n        if (this._caps.etc2) {\r\n            this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;\r\n            this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;\r\n        }\r\n\r\n        // Checks if some of the format renders first to allow the use of webgl inspector.\r\n        if (this._webGLVersion > 1) {\r\n            if (this._gl.HALF_FLOAT_OES !== 0x140b) {\r\n                this._gl.HALF_FLOAT_OES = 0x140b;\r\n            }\r\n        }\r\n        this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();\r\n        // Draw buffers\r\n        if (this._webGLVersion > 1) {\r\n            this._caps.drawBuffersExtension = true;\r\n            this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);\r\n        } else {\r\n            const drawBuffersExtension = this._gl.getExtension(\"WEBGL_draw_buffers\");\r\n\r\n            if (drawBuffersExtension !== null) {\r\n                this._caps.drawBuffersExtension = true;\r\n                this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);\r\n                (this._gl.DRAW_FRAMEBUFFER as any) = this._gl.FRAMEBUFFER;\r\n\r\n                for (let i = 0; i < 16; i++) {\r\n                    (<any>this._gl)[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"] = (<any>drawBuffersExtension)[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n                }\r\n            }\r\n        }\r\n\r\n        // Depth Texture\r\n        if (this._webGLVersion > 1) {\r\n            this._caps.depthTextureExtension = true;\r\n        } else {\r\n            const depthTextureExtension = this._gl.getExtension(\"WEBGL_depth_texture\");\r\n\r\n            if (depthTextureExtension != null) {\r\n                this._caps.depthTextureExtension = true;\r\n                this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;\r\n            }\r\n        }\r\n\r\n        // Vertex array object\r\n        if (this.disableVertexArrayObjects) {\r\n            this._caps.vertexArrayObject = false;\r\n        } else if (this._webGLVersion > 1) {\r\n            this._caps.vertexArrayObject = true;\r\n        } else {\r\n            const vertexArrayObjectExtension = this._gl.getExtension(\"OES_vertex_array_object\");\r\n\r\n            if (vertexArrayObjectExtension != null) {\r\n                this._caps.vertexArrayObject = true;\r\n                this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);\r\n                this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);\r\n                this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);\r\n            }\r\n        }\r\n\r\n        // Instances count\r\n        if (this._webGLVersion > 1) {\r\n            this._caps.instancedArrays = true;\r\n        } else {\r\n            const instanceExtension = <ANGLE_instanced_arrays>this._gl.getExtension(\"ANGLE_instanced_arrays\");\r\n\r\n            if (instanceExtension != null) {\r\n                this._caps.instancedArrays = true;\r\n                this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);\r\n                this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);\r\n                this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);\r\n            } else {\r\n                this._caps.instancedArrays = false;\r\n            }\r\n        }\r\n\r\n        if (this._gl.getShaderPrecisionFormat) {\r\n            const vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);\r\n            const fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);\r\n\r\n            if (vertexhighp && fragmenthighp) {\r\n                this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;\r\n            }\r\n        }\r\n\r\n        if (this._webGLVersion > 1) {\r\n            this._caps.blendMinMax = true;\r\n        } else {\r\n            const blendMinMaxExtension = this._gl.getExtension(\"EXT_blend_minmax\");\r\n            if (blendMinMaxExtension != null) {\r\n                this._caps.blendMinMax = true;\r\n                this._gl.MAX = blendMinMaxExtension.MAX_EXT as typeof WebGL2RenderingContext.MAX;\r\n                this._gl.MIN = blendMinMaxExtension.MIN_EXT as typeof WebGL2RenderingContext.MIN;\r\n            }\r\n        }\r\n\r\n        // sRGB buffers\r\n        // only run this if not already set to true (in the constructor, for example)\r\n        if (!this._caps.supportSRGBBuffers) {\r\n            if (this._webGLVersion > 1) {\r\n                this._caps.supportSRGBBuffers = true;\r\n                this._glSRGBExtensionValues = {\r\n                    SRGB: WebGL2RenderingContext.SRGB,\r\n                    SRGB8: WebGL2RenderingContext.SRGB8,\r\n                    SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8,\r\n                };\r\n            } else {\r\n                const sRGBExtension = this._gl.getExtension(\"EXT_sRGB\");\r\n\r\n                if (sRGBExtension != null) {\r\n                    this._caps.supportSRGBBuffers = true;\r\n                    this._glSRGBExtensionValues = {\r\n                        SRGB: sRGBExtension.SRGB_EXT as typeof WebGL2RenderingContext.SRGB | EXT_sRGB[\"SRGB_EXT\"],\r\n                        SRGB8: sRGBExtension.SRGB_ALPHA_EXT as typeof WebGL2RenderingContext.SRGB8 | EXT_sRGB[\"SRGB_ALPHA_EXT\"],\r\n                        SRGB8_ALPHA8: sRGBExtension.SRGB_ALPHA_EXT as typeof WebGL2RenderingContext.SRGB8_ALPHA8 | EXT_sRGB[\"SRGB8_ALPHA8_EXT\"],\r\n                    };\r\n                }\r\n            }\r\n            // take into account the forced state that was provided in options\r\n            // When the issue in angle/chrome is fixed the flag should be taken into account only when it is explicitly defined\r\n            this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && (this._creationOptions as EngineOptions).forceSRGBBufferSupportState);\r\n        }\r\n\r\n        // Depth buffer\r\n        this._depthCullingState.depthTest = true;\r\n        this._depthCullingState.depthFunc = this._gl.LEQUAL;\r\n        this._depthCullingState.depthMask = true;\r\n\r\n        // Texture maps\r\n        this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;\r\n        for (let slot = 0; slot < this._maxSimultaneousTextures; slot++) {\r\n            this._nextFreeTextureSlots.push(slot);\r\n        }\r\n\r\n        if (this._glRenderer === \"Mali-G72\") {\r\n            // Overcome a bug when using a texture to store morph targets on Mali-G72\r\n            this._caps.disableMorphTargetTexture = true;\r\n        }\r\n    }\r\n\r\n    protected _initFeatures(): void {\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: typeof HTMLImageElement === \"undefined\",\r\n            supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,\r\n            supportDepthStencilTexture: this._webGLVersion !== 1,\r\n            supportShadowSamplers: this._webGLVersion !== 1,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: this._webGLVersion !== 1,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: this._webGLVersion !== 1,\r\n            basisNeedsPOT: this._webGLVersion === 1,\r\n            support3DTextures: this._webGLVersion !== 1,\r\n            needTypeSuffixInShaderConstants: this._webGLVersion !== 1,\r\n            supportMSAA: this._webGLVersion !== 1,\r\n            supportSSAO2: this._webGLVersion !== 1,\r\n            supportExtendedTextureFormats: this._webGLVersion !== 1,\r\n            supportSwitchCaseInShader: this._webGLVersion !== 1,\r\n            supportSyncTextureRead: true,\r\n            needsInvertingBitmap: true,\r\n            useUBOBindingCache: true,\r\n            needShaderCodeInlining: false,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: false,\r\n            supportSpriteInstancing: true,\r\n            forceVertexBufferStrideAndOffsetMultiple4Bytes: false,\r\n            _checkNonFloatVertexBuffersDontRecreatePipelineContext: false,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets version of the current webGL context\r\n     * Keep it for back compat - use version instead\r\n     */\r\n    public get webGLVersion(): number {\r\n        return this._webGLVersion;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"Engine\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ThinEngine\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _prepareWorkingCanvas(): void {\r\n        if (this._workingCanvas) {\r\n            return;\r\n        }\r\n\r\n        this._workingCanvas = this.createCanvas(1, 1);\r\n        const context = this._workingCanvas.getContext(\"2d\");\r\n\r\n        if (context) {\r\n            this._workingContext = context;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current engine context\r\n     * @returns an object containing the vendor, the renderer and the version of the current engine context\r\n     */\r\n    public getInfo() {\r\n        return this.getGlInfo();\r\n    }\r\n\r\n    /**\r\n     * Gets an object containing information about the current webGL context\r\n     * @returns an object containing the vendor, the renderer and the version of the current webGL context\r\n     */\r\n    public getGlInfo() {\r\n        return {\r\n            vendor: this._glVendor,\r\n            renderer: this._glRenderer,\r\n            version: this._glVersion,\r\n        };\r\n    }\r\n\r\n    /**Gets driver info if available */\r\n    public extractDriverInfo() {\r\n        const glInfo = this.getGlInfo();\r\n        if (glInfo && glInfo.renderer) {\r\n            return glInfo.renderer;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        const useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;\r\n        this.stencilStateComposer.useStencilGlobalOnly = true; // make sure the stencil mask is coming from the global stencil and not from a material (effect) which would currently be in effect\r\n\r\n        this.applyStates();\r\n\r\n        this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;\r\n\r\n        let mode = 0;\r\n        if (backBuffer && color) {\r\n            let setBackBufferColor = true;\r\n            if (this._currentRenderTarget) {\r\n                const textureFormat = this._currentRenderTarget.texture?.format;\r\n                if (\r\n                    textureFormat === Constants.TEXTUREFORMAT_RED_INTEGER ||\r\n                    textureFormat === Constants.TEXTUREFORMAT_RG_INTEGER ||\r\n                    textureFormat === Constants.TEXTUREFORMAT_RGB_INTEGER ||\r\n                    textureFormat === Constants.TEXTUREFORMAT_RGBA_INTEGER\r\n                ) {\r\n                    const textureType = this._currentRenderTarget.texture?.type;\r\n                    if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER || textureType === Constants.TEXTURETYPE_UNSIGNED_SHORT) {\r\n                        ThinEngine._TempClearColorUint32[0] = color.r * 255;\r\n                        ThinEngine._TempClearColorUint32[1] = color.g * 255;\r\n                        ThinEngine._TempClearColorUint32[2] = color.b * 255;\r\n                        ThinEngine._TempClearColorUint32[3] = color.a * 255;\r\n                        this._gl.clearBufferuiv(this._gl.COLOR, 0, ThinEngine._TempClearColorUint32);\r\n                        setBackBufferColor = false;\r\n                    } else {\r\n                        ThinEngine._TempClearColorInt32[0] = color.r * 255;\r\n                        ThinEngine._TempClearColorInt32[1] = color.g * 255;\r\n                        ThinEngine._TempClearColorInt32[2] = color.b * 255;\r\n                        ThinEngine._TempClearColorInt32[3] = color.a * 255;\r\n                        this._gl.clearBufferiv(this._gl.COLOR, 0, ThinEngine._TempClearColorInt32);\r\n                        setBackBufferColor = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (setBackBufferColor) {\r\n                this._gl.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);\r\n                mode |= this._gl.COLOR_BUFFER_BIT;\r\n            }\r\n        }\r\n\r\n        if (depth) {\r\n            if (this.useReverseDepthBuffer) {\r\n                this._depthCullingState.depthFunc = this._gl.GEQUAL;\r\n                this._gl.clearDepth(0.0);\r\n            } else {\r\n                this._gl.clearDepth(1.0);\r\n            }\r\n            mode |= this._gl.DEPTH_BUFFER_BIT;\r\n        }\r\n        if (stencil) {\r\n            this._gl.clearStencil(0);\r\n            mode |= this._gl.STENCIL_BUFFER_BIT;\r\n        }\r\n        this._gl.clear(mode);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _viewport(x: number, y: number, width: number, height: number): void {\r\n        if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {\r\n            this._viewportCached.x = x;\r\n            this._viewportCached.y = y;\r\n            this._viewportCached.z = width;\r\n            this._viewportCached.w = height;\r\n\r\n            this._gl.viewport(x, y, width, height);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * End the current frame\r\n     */\r\n    public override endFrame(): void {\r\n        super.endFrame();\r\n        // Force a flush in case we are using a bad OS.\r\n        if (this._badOS) {\r\n            this.flushFramebuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the performance monitor attached to this engine\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\r\n     */\r\n    public get performanceMonitor(): PerformanceMonitor {\r\n        throw new Error(\"Not Supported by ThinEngine\");\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param rtWrapper The render target wrapper to render to\r\n     * @param faceIndex The face of the texture to render to in case of cube texture and if the render target wrapper is not a multi render target\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel Defines the lod level to bind to the frame buffer\r\n     * @param layer Defines the 2d array index to bind to the frame buffer if the render target wrapper is not a multi render target\r\n     */\r\n    public bindFramebuffer(\r\n        rtWrapper: RenderTargetWrapper,\r\n        faceIndex: number = 0,\r\n        requiredWidth?: number,\r\n        requiredHeight?: number,\r\n        forceFullscreenViewport?: boolean,\r\n        lodLevel = 0,\r\n        layer = 0\r\n    ): void {\r\n        const webglRTWrapper = rtWrapper as WebGLRenderTargetWrapper;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = rtWrapper;\r\n        this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);\r\n\r\n        const gl = this._gl;\r\n        if (!rtWrapper.isMulti) {\r\n            if (rtWrapper.is2DArray || rtWrapper.is3D) {\r\n                gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, rtWrapper.texture!._hardwareTexture?.underlyingResource, lodLevel, layer);\r\n            } else if (rtWrapper.isCube) {\r\n                gl.framebufferTexture2D(\r\n                    gl.FRAMEBUFFER,\r\n                    gl.COLOR_ATTACHMENT0,\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    rtWrapper.texture!._hardwareTexture?.underlyingResource,\r\n                    lodLevel\r\n                );\r\n            } else if (webglRTWrapper._currentLOD !== lodLevel) {\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rtWrapper.texture!._hardwareTexture?.underlyingResource, lodLevel);\r\n                webglRTWrapper._currentLOD = lodLevel;\r\n            }\r\n        }\r\n\r\n        const depthStencilTexture = rtWrapper._depthStencilTexture;\r\n        if (depthStencilTexture) {\r\n            if (rtWrapper.is3D) {\r\n                if (\r\n                    rtWrapper.texture!.width !== depthStencilTexture.width ||\r\n                    rtWrapper.texture!.height !== depthStencilTexture.height ||\r\n                    rtWrapper.texture!.depth !== depthStencilTexture.depth\r\n                ) {\r\n                    Logger.Warn(\"Depth/Stencil attachment for 3D target must have same dimensions as color attachment\");\r\n                }\r\n            }\r\n            const attachment = rtWrapper._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\r\n            if (rtWrapper.is2DArray || rtWrapper.is3D) {\r\n                gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel, layer);\r\n            } else if (rtWrapper.isCube) {\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel);\r\n            } else {\r\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthStencilTexture._hardwareTexture?.underlyingResource, lodLevel);\r\n            }\r\n        }\r\n\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        } else {\r\n            if (!requiredWidth) {\r\n                requiredWidth = rtWrapper.width;\r\n                if (lodLevel) {\r\n                    requiredWidth = requiredWidth / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n            if (!requiredHeight) {\r\n                requiredHeight = rtWrapper.height;\r\n                if (lodLevel) {\r\n                    requiredHeight = requiredHeight / Math.pow(2, lodLevel);\r\n                }\r\n            }\r\n\r\n            this._viewport(0, 0, requiredWidth, requiredHeight);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines culling state: true to enable culling, false to disable it\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\r\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\r\n     * @param stencil stencil states to set\r\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        // Culling\r\n        if (this._depthCullingState.cull !== culling || force) {\r\n            this._depthCullingState.cull = culling;\r\n        }\r\n\r\n        // Cull face\r\n        const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? this._gl.BACK : this._gl.FRONT;\r\n        if (this._depthCullingState.cullFace !== cullFace || force) {\r\n            this._depthCullingState.cullFace = cullFace;\r\n        }\r\n\r\n        // Z offset\r\n        this.setZOffset(zOffset);\r\n        this.setZOffsetUnits(zOffsetUnits);\r\n\r\n        // Front face\r\n        const frontFace = reverseSide ? this._gl.CW : this._gl.CCW;\r\n        if (this._depthCullingState.frontFace !== frontFace || force) {\r\n            this._depthCullingState.frontFace = frontFace;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = stencil;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>) {\r\n        if (this._currentFramebuffer !== framebuffer) {\r\n            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);\r\n            this._currentFramebuffer = framebuffer;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _currentFrameBufferIsDefaultFrameBuffer() {\r\n        return this._currentFramebuffer === null;\r\n    }\r\n\r\n    /**\r\n     * Generates the mipmaps for a texture\r\n     * @param texture texture to generate the mipmaps for\r\n     */\r\n    public generateMipmaps(texture: InternalTexture): void {\r\n        const target = this._getTextureTarget(texture);\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._gl.generateMipmap(target);\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param texture defines the render target wrapper to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        const webglRTWrapper = texture as WebGLRenderTargetWrapper;\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        // If MSAA, we need to bitblt back to main texture\r\n        const gl = this._gl;\r\n        if (webglRTWrapper._MSAAFramebuffer) {\r\n            if (texture.isMulti) {\r\n                // This texture is part of a MRT texture, we need to treat all attachments\r\n                this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);\r\n                return;\r\n            }\r\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);\r\n            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);\r\n            gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\r\n        }\r\n\r\n        if (texture.texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this.generateMipmaps(texture.texture);\r\n        }\r\n\r\n        if (onBeforeUnbind) {\r\n            if (webglRTWrapper._MSAAFramebuffer) {\r\n                // Bind the correct framebuffer\r\n                this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);\r\n            }\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    /**\r\n     * Force a webGL flush (ie. a flush of all waiting webGL commands)\r\n     */\r\n    public flushFramebuffer(): void {\r\n        this._gl.flush();\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target and bind the default framebuffer\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        } else {\r\n            this._bindUnboundFramebuffer(null);\r\n        }\r\n        if (this._cachedViewport) {\r\n            this.setViewport(this._cachedViewport);\r\n        }\r\n\r\n        this.wipeCaches();\r\n    }\r\n\r\n    // VBOs\r\n\r\n    /** @internal */\r\n    protected _resetVertexBufferBinding(): void {\r\n        this.bindArrayBuffer(null);\r\n        this._cachedVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param data the data or size for the vertex buffer\r\n     * @param _updatable whether the buffer should be created as updatable\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public createVertexBuffer(data: DataArray | number, _updatable?: boolean, _label?: string): DataBuffer {\r\n        return this._createVertexBuffer(data, this._gl.STATIC_DRAW);\r\n    }\r\n\r\n    private _createVertexBuffer(data: DataArray | number, usage: number): DataBuffer {\r\n        const vbo = this._gl.createBuffer();\r\n\r\n        if (!vbo) {\r\n            throw new Error(\"Unable to create vertex buffer\");\r\n        }\r\n\r\n        const dataBuffer = new WebGLDataBuffer(vbo);\r\n        this.bindArrayBuffer(dataBuffer);\r\n\r\n        if (typeof data !== \"number\") {\r\n            if (data instanceof Array) {\r\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);\r\n                dataBuffer.capacity = data.length * 4;\r\n            } else {\r\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, <ArrayBuffer>data, usage);\r\n                dataBuffer.capacity = data.byteLength;\r\n            }\r\n        } else {\r\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Uint8Array(data), usage);\r\n            dataBuffer.capacity = data;\r\n        }\r\n\r\n        this._resetVertexBufferBinding();\r\n\r\n        dataBuffer.references = 1;\r\n        return dataBuffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param data the data for the dynamic vertex buffer\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public createDynamicVertexBuffer(data: DataArray | number, _label?: string): DataBuffer {\r\n        return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);\r\n    }\r\n\r\n    protected _resetIndexBufferBinding(): void {\r\n        this.bindIndexBuffer(null);\r\n        this._cachedIndexBuffer = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param updatable defines if the index buffer must be updatable\r\n     * @param _label defines the label of the buffer (for debug purpose)\r\n     * @returns a new webGL buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray, updatable?: boolean, _label?: string): DataBuffer {\r\n        const vbo = this._gl.createBuffer();\r\n        const dataBuffer = new WebGLDataBuffer(vbo!);\r\n\r\n        if (!vbo) {\r\n            throw new Error(\"Unable to create index buffer\");\r\n        }\r\n\r\n        this.bindIndexBuffer(dataBuffer);\r\n\r\n        const data = this._normalizeIndexData(indices);\r\n        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);\r\n        this._resetIndexBufferBinding();\r\n        dataBuffer.references = 1;\r\n        dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        return dataBuffer;\r\n    }\r\n\r\n    protected _normalizeIndexData(indices: IndicesArray): Uint16Array | Uint32Array {\r\n        const bytesPerElement = (indices as Exclude<IndicesArray, number[]>).BYTES_PER_ELEMENT;\r\n        if (bytesPerElement === 2) {\r\n            return indices as Uint16Array;\r\n        }\r\n\r\n        // Check 32 bit support\r\n        if (this._caps.uintIndices) {\r\n            if (indices instanceof Uint32Array) {\r\n                return indices;\r\n            } else {\r\n                // number[] or Int32Array, check if 32 bit is necessary\r\n                for (let index = 0; index < indices.length; index++) {\r\n                    if (indices[index] >= 65535) {\r\n                        return new Uint32Array(indices);\r\n                    }\r\n                }\r\n\r\n                return new Uint16Array(indices);\r\n            }\r\n        }\r\n\r\n        // No 32 bit support, force conversion to 16 bit (values greater 16 bit are lost)\r\n        return new Uint16Array(indices);\r\n    }\r\n\r\n    /**\r\n     * Bind a webGL buffer to the webGL context\r\n     * @param buffer defines the buffer to bind\r\n     */\r\n    public bindArrayBuffer(buffer: Nullable<DataBuffer>): void {\r\n        if (!this._vaoRecordInProgress) {\r\n            this._unbindVertexArrayObject();\r\n        }\r\n        this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);\r\n    }\r\n\r\n    /**\r\n     * Bind a specific block at a given index in a specific shader program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param blockName defines the block name\r\n     * @param index defines the index where to bind the block\r\n     */\r\n    public bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n        const program = (pipelineContext as WebGLPipelineContext).program!;\r\n\r\n        const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\r\n\r\n        this._gl.uniformBlockBinding(program, uniformLocation, index);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected bindIndexBuffer(buffer: Nullable<DataBuffer>): void {\r\n        if (!this._vaoRecordInProgress) {\r\n            this._unbindVertexArrayObject();\r\n        }\r\n        this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);\r\n    }\r\n\r\n    private _bindBuffer(buffer: Nullable<DataBuffer>, target: number): void {\r\n        if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {\r\n            this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);\r\n            this._currentBoundBuffer[target] = buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * update the bound buffer with the given data\r\n     * @param data defines the data to update\r\n     */\r\n    public updateArrayBuffer(data: Float32Array): void {\r\n        this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\r\n    }\r\n\r\n    private _vertexAttribPointer(buffer: DataBuffer, indx: number, size: number, type: number, normalized: boolean, stride: number, offset: number): void {\r\n        const pointer = this._currentBufferPointers[indx];\r\n        if (!pointer) {\r\n            return;\r\n        }\r\n\r\n        let changed = false;\r\n        if (!pointer.active) {\r\n            changed = true;\r\n            pointer.active = true;\r\n            pointer.index = indx;\r\n            pointer.size = size;\r\n            pointer.type = type;\r\n            pointer.normalized = normalized;\r\n            pointer.stride = stride;\r\n            pointer.offset = offset;\r\n            pointer.buffer = buffer;\r\n        } else {\r\n            if (pointer.buffer !== buffer) {\r\n                pointer.buffer = buffer;\r\n                changed = true;\r\n            }\r\n            if (pointer.size !== size) {\r\n                pointer.size = size;\r\n                changed = true;\r\n            }\r\n            if (pointer.type !== type) {\r\n                pointer.type = type;\r\n                changed = true;\r\n            }\r\n            if (pointer.normalized !== normalized) {\r\n                pointer.normalized = normalized;\r\n                changed = true;\r\n            }\r\n            if (pointer.stride !== stride) {\r\n                pointer.stride = stride;\r\n                changed = true;\r\n            }\r\n            if (pointer.offset !== offset) {\r\n                pointer.offset = offset;\r\n                changed = true;\r\n            }\r\n        }\r\n\r\n        if (changed || this._vaoRecordInProgress) {\r\n            this.bindArrayBuffer(buffer);\r\n            if (type === this._gl.UNSIGNED_INT || type === this._gl.INT) {\r\n                this._gl.vertexAttribIPointer(indx, size, type, stride, offset);\r\n            } else {\r\n                this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindIndexBufferWithCache(indexBuffer: Nullable<DataBuffer>): void {\r\n        if (indexBuffer == null) {\r\n            return;\r\n        }\r\n        if (this._cachedIndexBuffer !== indexBuffer) {\r\n            this._cachedIndexBuffer = indexBuffer;\r\n            this.bindIndexBuffer(indexBuffer);\r\n            this._uintIndicesCurrentlySet = indexBuffer.is32Bits;\r\n        }\r\n    }\r\n\r\n    private _bindVertexBuffersAttributes(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        const attributes = effect.getAttributesNames();\r\n\r\n        if (!this._vaoRecordInProgress) {\r\n            this._unbindVertexArrayObject();\r\n        }\r\n\r\n        this.unbindAllAttributes();\r\n\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const order = effect.getAttributeLocation(index);\r\n\r\n            if (order >= 0) {\r\n                const ai = attributes[index];\r\n                let vertexBuffer: Nullable<VertexBuffer> = null;\r\n\r\n                if (overrideVertexBuffers) {\r\n                    vertexBuffer = overrideVertexBuffers[ai];\r\n                }\r\n\r\n                if (!vertexBuffer) {\r\n                    vertexBuffer = vertexBuffers[ai];\r\n                }\r\n\r\n                if (!vertexBuffer) {\r\n                    continue;\r\n                }\r\n\r\n                this._gl.enableVertexAttribArray(order);\r\n                if (!this._vaoRecordInProgress) {\r\n                    this._vertexAttribArraysEnabled[order] = true;\r\n                }\r\n\r\n                const buffer = vertexBuffer.getBuffer();\r\n                if (buffer) {\r\n                    this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);\r\n\r\n                    if (vertexBuffer.getIsInstanced()) {\r\n                        this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());\r\n                        if (!this._vaoRecordInProgress) {\r\n                            this._currentInstanceLocations.push(order);\r\n                            this._currentInstanceBuffers.push(buffer);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Records a vertex array object\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects\r\n     * @param vertexBuffers defines the list of vertex buffers to store\r\n     * @param indexBuffer defines the index buffer to store\r\n     * @param effect defines the effect to store\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     * @returns the new vertex array object\r\n     */\r\n    public recordVertexArrayObject(\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): WebGLVertexArrayObject {\r\n        const vao = this._gl.createVertexArray();\r\n\r\n        if (!vao) {\r\n            throw new Error(\"Unable to create VAO\");\r\n        }\r\n\r\n        this._vaoRecordInProgress = true;\r\n\r\n        this._gl.bindVertexArray(vao);\r\n\r\n        this._mustWipeVertexAttributes = true;\r\n        this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);\r\n\r\n        this.bindIndexBuffer(indexBuffer);\r\n\r\n        this._vaoRecordInProgress = false;\r\n        this._gl.bindVertexArray(null);\r\n\r\n        return vao;\r\n    }\r\n\r\n    /**\r\n     * Bind a specific vertex array object\r\n     * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects\r\n     * @param vertexArrayObject defines the vertex array object to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     */\r\n    public bindVertexArrayObject(vertexArrayObject: WebGLVertexArrayObject, indexBuffer: Nullable<DataBuffer>): void {\r\n        if (this._cachedVertexArrayObject !== vertexArrayObject) {\r\n            this._cachedVertexArrayObject = vertexArrayObject;\r\n\r\n            this._gl.bindVertexArray(vertexArrayObject);\r\n            this._cachedVertexBuffers = null;\r\n            this._cachedIndexBuffer = null;\r\n\r\n            this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;\r\n            this._mustWipeVertexAttributes = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind webGl buffers directly to the webGL context\r\n     * @param vertexBuffer defines the vertex buffer to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer\r\n     * @param vertexStrideSize defines the vertex stride of the vertex buffer\r\n     * @param effect defines the effect associated with the vertex buffer\r\n     */\r\n    public bindBuffersDirectly(vertexBuffer: DataBuffer, indexBuffer: DataBuffer, vertexDeclaration: number[], vertexStrideSize: number, effect: Effect): void {\r\n        if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {\r\n            this._cachedVertexBuffers = vertexBuffer;\r\n            this._cachedEffectForVertexBuffers = effect;\r\n\r\n            const attributesCount = effect.getAttributesCount();\r\n\r\n            this._unbindVertexArrayObject();\r\n            this.unbindAllAttributes();\r\n\r\n            let offset = 0;\r\n            for (let index = 0; index < attributesCount; index++) {\r\n                if (index < vertexDeclaration.length) {\r\n                    const order = effect.getAttributeLocation(index);\r\n\r\n                    if (order >= 0) {\r\n                        this._gl.enableVertexAttribArray(order);\r\n                        this._vertexAttribArraysEnabled[order] = true;\r\n                        this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);\r\n                    }\r\n\r\n                    offset += vertexDeclaration[index] * 4;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._bindIndexBufferWithCache(indexBuffer);\r\n    }\r\n\r\n    private _unbindVertexArrayObject(): void {\r\n        if (!this._cachedVertexArrayObject) {\r\n            return;\r\n        }\r\n\r\n        this._cachedVertexArrayObject = null;\r\n        this._gl.bindVertexArray(null);\r\n    }\r\n\r\n    /**\r\n     * Bind a list of vertex buffers to the webGL context\r\n     * @param vertexBuffers defines the list of vertex buffers to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param effect defines the effect associated with the vertex buffers\r\n     * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\r\n     */\r\n    public bindBuffers(\r\n        vertexBuffers: { [key: string]: Nullable<VertexBuffer> },\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {\r\n            this._cachedVertexBuffers = vertexBuffers;\r\n            this._cachedEffectForVertexBuffers = effect;\r\n\r\n            this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._bindIndexBufferWithCache(indexBuffer);\r\n    }\r\n\r\n    /**\r\n     * Unbind all instance attributes\r\n     */\r\n    public unbindInstanceAttributes() {\r\n        let boundBuffer;\r\n        for (let i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {\r\n            const instancesBuffer = this._currentInstanceBuffers[i];\r\n            if (boundBuffer != instancesBuffer && instancesBuffer.references) {\r\n                boundBuffer = instancesBuffer;\r\n                this.bindArrayBuffer(instancesBuffer);\r\n            }\r\n            const offsetLocation = this._currentInstanceLocations[i];\r\n            this._gl.vertexAttribDivisor(offsetLocation, 0);\r\n        }\r\n        this._currentInstanceBuffers.length = 0;\r\n        this._currentInstanceLocations.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Release and free the memory of a vertex array object\r\n     * @param vao defines the vertex array object to delete\r\n     */\r\n    public releaseVertexArrayObject(vao: WebGLVertexArrayObject) {\r\n        this._gl.deleteVertexArray(vao);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseBuffer(buffer: DataBuffer): boolean {\r\n        buffer.references--;\r\n\r\n        if (buffer.references === 0) {\r\n            this._deleteBuffer(buffer);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: DataBuffer): void {\r\n        this._gl.deleteBuffer(buffer.underlyingResource);\r\n    }\r\n\r\n    /**\r\n     * Update the content of a webGL buffer used with instantiation and bind it to the webGL context\r\n     * @param instancesBuffer defines the webGL buffer to update and bind\r\n     * @param data defines the data to store in the buffer\r\n     * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer\r\n     */\r\n    public updateAndBindInstancesBuffer(instancesBuffer: DataBuffer, data: Float32Array, offsetLocations: number[] | InstancingAttributeInfo[]): void {\r\n        this.bindArrayBuffer(instancesBuffer);\r\n        if (data) {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\r\n        }\r\n\r\n        if ((<any>offsetLocations[0]).index !== undefined) {\r\n            this.bindInstancesBuffer(instancesBuffer, offsetLocations as any, true);\r\n        } else {\r\n            for (let index = 0; index < 4; index++) {\r\n                const offsetLocation = <number>offsetLocations[index];\r\n\r\n                if (!this._vertexAttribArraysEnabled[offsetLocation]) {\r\n                    this._gl.enableVertexAttribArray(offsetLocation);\r\n                    this._vertexAttribArraysEnabled[offsetLocation] = true;\r\n                }\r\n\r\n                this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);\r\n                this._gl.vertexAttribDivisor(offsetLocation, 1);\r\n                this._currentInstanceLocations.push(offsetLocation);\r\n                this._currentInstanceBuffers.push(instancesBuffer);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind the content of a webGL buffer used with instantiation\r\n     * @param instancesBuffer defines the webGL buffer to bind\r\n     * @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer\r\n     * @param computeStride defines Whether to compute the strides from the info or use the default 0\r\n     */\r\n    public bindInstancesBuffer(instancesBuffer: DataBuffer, attributesInfo: InstancingAttributeInfo[], computeStride = true): void {\r\n        this.bindArrayBuffer(instancesBuffer);\r\n\r\n        let stride = 0;\r\n        if (computeStride) {\r\n            for (let i = 0; i < attributesInfo.length; i++) {\r\n                const ai = attributesInfo[i];\r\n                stride += ai.attributeSize * 4;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < attributesInfo.length; i++) {\r\n            const ai = attributesInfo[i];\r\n            if (ai.index === undefined) {\r\n                ai.index = this._currentEffect!.getAttributeLocationByName(ai.attributeName);\r\n            }\r\n\r\n            if (ai.index < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (!this._vertexAttribArraysEnabled[ai.index]) {\r\n                this._gl.enableVertexAttribArray(ai.index);\r\n                this._vertexAttribArraysEnabled[ai.index] = true;\r\n            }\r\n\r\n            this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);\r\n            this._gl.vertexAttribDivisor(ai.index, ai.divisor === undefined ? 1 : ai.divisor);\r\n            this._currentInstanceLocations.push(ai.index);\r\n            this._currentInstanceBuffers.push(instancesBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable the instance attribute corresponding to the name in parameter\r\n     * @param name defines the name of the attribute to disable\r\n     */\r\n    public disableInstanceAttributeByName(name: string) {\r\n        if (!this._currentEffect) {\r\n            return;\r\n        }\r\n\r\n        const attributeLocation = this._currentEffect.getAttributeLocationByName(name);\r\n        this.disableInstanceAttribute(attributeLocation);\r\n    }\r\n\r\n    /**\r\n     * Disable the instance attribute corresponding to the location in parameter\r\n     * @param attributeLocation defines the attribute location of the attribute to disable\r\n     */\r\n    public disableInstanceAttribute(attributeLocation: number) {\r\n        let shouldClean = false;\r\n        let index: number;\r\n        while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {\r\n            this._currentInstanceLocations.splice(index, 1);\r\n            this._currentInstanceBuffers.splice(index, 1);\r\n\r\n            shouldClean = true;\r\n            index = this._currentInstanceLocations.indexOf(attributeLocation);\r\n        }\r\n\r\n        if (shouldClean) {\r\n            this._gl.vertexAttribDivisor(attributeLocation, 0);\r\n            this.disableAttributeByIndex(attributeLocation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable the attribute corresponding to the location in parameter\r\n     * @param attributeLocation defines the attribute location of the attribute to disable\r\n     */\r\n    public disableAttributeByIndex(attributeLocation: number) {\r\n        this._gl.disableVertexAttribArray(attributeLocation);\r\n        this._vertexAttribArraysEnabled[attributeLocation] = false;\r\n        this._currentBufferPointers[attributeLocation].active = false;\r\n    }\r\n\r\n    /**\r\n     * Send a draw order\r\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n        this.drawElementsType(useTriangles ? Constants.MATERIAL_TriangleFillMode : Constants.MATERIAL_WireFrameFillMode, indexStart, indexCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of points\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawPointClouds(verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        this.drawArraysType(Constants.MATERIAL_PointFillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawUnIndexed(useTriangles: boolean, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        this.drawArraysType(useTriangles ? Constants.MATERIAL_TriangleFillMode : Constants.MATERIAL_WireFrameFillMode, verticesStart, verticesCount, instancesCount);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this.applyStates();\r\n\r\n        this._reportDrawCall();\r\n\r\n        // Render\r\n\r\n        const drawMode = this._drawMode(fillMode);\r\n        const indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\r\n        const mult = this._uintIndicesCurrentlySet ? 4 : 2;\r\n        if (instancesCount) {\r\n            this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);\r\n        } else {\r\n            this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this.applyStates();\r\n\r\n        this._reportDrawCall();\r\n\r\n        const drawMode = this._drawMode(fillMode);\r\n        if (instancesCount) {\r\n            this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);\r\n        } else {\r\n            this._gl.drawArrays(drawMode, verticesStart, verticesCount);\r\n        }\r\n    }\r\n\r\n    private _drawMode(fillMode: number): number {\r\n        switch (fillMode) {\r\n            // Triangle views\r\n            case Constants.MATERIAL_TriangleFillMode:\r\n                return this._gl.TRIANGLES;\r\n            case Constants.MATERIAL_PointFillMode:\r\n                return this._gl.POINTS;\r\n            case Constants.MATERIAL_WireFrameFillMode:\r\n                return this._gl.LINES;\r\n            // Draw modes\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n                return this._gl.POINTS;\r\n            case Constants.MATERIAL_LineListDrawMode:\r\n                return this._gl.LINES;\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n                return this._gl.LINE_LOOP;\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n                return this._gl.LINE_STRIP;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                return this._gl.TRIANGLE_STRIP;\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return this._gl.TRIANGLE_FAN;\r\n            default:\r\n                return this._gl.TRIANGLES;\r\n        }\r\n    }\r\n\r\n    // Shaders\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseEffect(effect: Effect): void {\r\n        if (this._compiledEffects[effect._key]) {\r\n            delete this._compiledEffects[effect._key];\r\n        }\r\n        const pipelineContext = effect.getPipelineContext();\r\n        if (pipelineContext) {\r\n            this._deletePipelineContext(pipelineContext);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n        if (webGLPipelineContext && webGLPipelineContext.program) {\r\n            webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;\r\n            resetCachedPipeline(webGLPipelineContext);\r\n            this._gl.deleteProgram(webGLPipelineContext.program);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _getGlobalDefines(defines?: { [key: string]: string }): string | undefined {\r\n        return _getGlobalDefines(defines, this.isNDCHalfZRange, this.useReverseDepthBuffer, this.useExactSrgbConversions);\r\n    }\r\n\r\n    /**\r\n     * Create a new effect (used to store vertex/fragment shaders)\r\n     * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\r\n     * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\r\n     * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\r\n     * @param samplers defines an array of string used to represent textures\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @returns the new Effect\r\n     */\r\n    public createEffect(\r\n        baseName: string | (IShaderPath & { vertexToken?: string; fragmentToken?: string }),\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | ThinEngine,\r\n        samplers?: string[],\r\n        defines?: string,\r\n        fallbacks?: IEffectFallbacks,\r\n        onCompiled?: Nullable<(effect: Effect) => void>,\r\n        onError?: Nullable<(effect: Effect, errors: string) => void>,\r\n        indexParameters?: any,\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ): Effect {\r\n        const vertex = typeof baseName === \"string\" ? baseName : baseName.vertexToken || baseName.vertexSource || baseName.vertexElement || baseName.vertex;\r\n        const fragment = typeof baseName === \"string\" ? baseName : baseName.fragmentToken || baseName.fragmentSource || baseName.fragmentElement || baseName.fragment;\r\n        const globalDefines = this._getGlobalDefines()!;\r\n\r\n        let fullDefines = defines ?? (<IEffectCreationOptions>attributesNamesOrOptions).defines ?? \"\";\r\n\r\n        if (globalDefines) {\r\n            fullDefines += globalDefines;\r\n        }\r\n\r\n        const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\r\n        if (this._compiledEffects[name]) {\r\n            const compiledEffect = <Effect>this._compiledEffects[name];\r\n            if (onCompiled && compiledEffect.isReady()) {\r\n                onCompiled(compiledEffect);\r\n            }\r\n\r\n            return compiledEffect;\r\n        }\r\n        if (this._gl) {\r\n            getStateObject(this._gl);\r\n        }\r\n        const effect = new Effect(\r\n            baseName,\r\n            attributesNamesOrOptions,\r\n            uniformsNamesOrEngine,\r\n            samplers,\r\n            this,\r\n            defines,\r\n            fallbacks,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters,\r\n            name,\r\n            (<IEffectCreationOptions>attributesNamesOrOptions).shaderLanguage ?? shaderLanguage\r\n        );\r\n        this._compiledEffects[name] = effect;\r\n\r\n        return effect;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected static _ConcatenateShader = _ConcatenateShader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderSource(shader: WebGLShader): Nullable<string> {\r\n        return this._gl.getShaderSource(shader);\r\n    }\r\n\r\n    /**\r\n     * Directly creates a webGL program\r\n     * @param pipelineContext  defines the pipeline context to attach to\r\n     * @param vertexCode defines the vertex shader code to use\r\n     * @param fragmentCode defines the fragment shader code to use\r\n     * @param context defines the webGL context to use (if not set, the current one will be used)\r\n     * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n     * @returns the new webGL program\r\n     */\r\n    public createRawShaderProgram(\r\n        pipelineContext: IPipelineContext,\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        context?: WebGLRenderingContext,\r\n        transformFeedbackVaryings: Nullable<string[]> = null\r\n    ): WebGLProgram {\r\n        const stateObject = getStateObject(this._gl);\r\n        stateObject._contextWasLost = this._contextWasLost;\r\n        stateObject.validateShaderPrograms = this.validateShaderPrograms;\r\n        return createRawShaderProgram(pipelineContext, vertexCode, fragmentCode, context || this._gl, transformFeedbackVaryings);\r\n    }\r\n\r\n    /**\r\n     * Creates a webGL program\r\n     * @param pipelineContext  defines the pipeline context to attach to\r\n     * @param vertexCode  defines the vertex shader code to use\r\n     * @param fragmentCode defines the fragment shader code to use\r\n     * @param defines defines the string containing the defines to use to compile the shaders\r\n     * @param context defines the webGL context to use (if not set, the current one will be used)\r\n     * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n     * @returns the new webGL program\r\n     */\r\n    public createShaderProgram(\r\n        pipelineContext: IPipelineContext,\r\n        vertexCode: string,\r\n        fragmentCode: string,\r\n        defines: Nullable<string>,\r\n        context?: WebGLRenderingContext,\r\n        transformFeedbackVaryings: Nullable<string[]> = null\r\n    ): WebGLProgram {\r\n        const stateObject = getStateObject(this._gl);\r\n        // assure the state object is correct\r\n        stateObject._contextWasLost = this._contextWasLost;\r\n        stateObject.validateShaderPrograms = this.validateShaderPrograms;\r\n        return createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context || this._gl, transformFeedbackVaryings);\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        // no inlining needed in the WebGL engine\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Creates a new pipeline context\r\n     * @param shaderProcessingContext defines the shader processing context used during the processing if available\r\n     * @returns the new pipeline\r\n     */\r\n    public createPipelineContext(shaderProcessingContext: Nullable<ShaderProcessingContext>): IPipelineContext {\r\n        if (this._gl) {\r\n            const stateObject = getStateObject(this._gl);\r\n            stateObject.parallelShaderCompile = this._caps.parallelShaderCompile;\r\n        }\r\n        const context = createPipelineContext(this._gl, shaderProcessingContext) as WebGLPipelineContext;\r\n        context.engine = this;\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Creates a new material context\r\n     * @returns the new context\r\n     */\r\n    public createMaterialContext(): IMaterialContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Creates a new draw context\r\n     * @returns the new context\r\n     */\r\n    public createDrawContext(): IDrawContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    protected _finalizePipelineContext(pipelineContext: WebGLPipelineContext) {\r\n        return _finalizePipelineContext(pipelineContext, this._gl, this.validateShaderPrograms);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        _rawVertexSourceCode: string,\r\n        _rawFragmentSourceCode: string,\r\n        rebuildRebind: any,\r\n        defines: Nullable<string>,\r\n        transformFeedbackVaryings: Nullable<string[]>,\r\n        _key: string\r\n    ) {\r\n        const stateObject = getStateObject(this._gl);\r\n        stateObject._contextWasLost = this._contextWasLost;\r\n        stateObject.validateShaderPrograms = this.validateShaderPrograms;\r\n        stateObject._createShaderProgramInjection = this._createShaderProgram.bind(this);\r\n        stateObject.createRawShaderProgramInjection = this.createRawShaderProgram.bind(this);\r\n        stateObject.createShaderProgramInjection = this.createShaderProgram.bind(this);\r\n        stateObject.loadFileInjection = this._loadFile.bind(this);\r\n        return _preparePipelineContext(\r\n            pipelineContext as WebGLPipelineContext,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            createAsRaw,\r\n            _rawVertexSourceCode,\r\n            _rawFragmentSourceCode,\r\n            rebuildRebind,\r\n            defines,\r\n            transformFeedbackVaryings,\r\n            _key\r\n        );\r\n    }\r\n\r\n    protected _createShaderProgram(\r\n        pipelineContext: WebGLPipelineContext,\r\n        vertexShader: WebGLShader,\r\n        fragmentShader: WebGLShader,\r\n        context: WebGLRenderingContext,\r\n        transformFeedbackVaryings: Nullable<string[]> = null\r\n    ): WebGLProgram {\r\n        return _createShaderProgram(pipelineContext as WebGLPipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isRenderingStateCompiled(pipelineContext: IPipelineContext): boolean {\r\n        const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n        if (this._isDisposed || webGLPipelineContext._isDisposed) {\r\n            return false;\r\n        }\r\n        if (this._gl.getProgramParameter(webGLPipelineContext.program!, this._caps.parallelShaderCompile!.COMPLETION_STATUS_KHR)) {\r\n            this._finalizePipelineContext(webGLPipelineContext);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        _executeWhenRenderingStateIsCompiled(pipelineContext as WebGLPipelineContext, action);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param uniformsNames defines the list of uniform names\r\n     * @returns an array of webGL uniform locations\r\n     */\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[] {\r\n        const results = new Array<Nullable<WebGLUniformLocation>>();\r\n        const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n\r\n        for (let index = 0; index < uniformsNames.length; index++) {\r\n            results.push(this._gl.getUniformLocation(webGLPipelineContext.program!, uniformsNames[index]));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active attributes for a given webGL program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const results = [];\r\n        const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n\r\n        for (let index = 0; index < attributesNames.length; index++) {\r\n            try {\r\n                results.push(this._gl.getAttribLocation(webGLPipelineContext.program!, attributesNames[index]));\r\n            } catch (e) {\r\n                results.push(-1);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, making it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Nullable<Effect | DrawWrapper>): void {\r\n        effect = effect !== null && IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\r\n\r\n        if (!effect || effect === this._currentEffect) {\r\n            return;\r\n        }\r\n\r\n        this._stencilStateComposer.stencilMaterial = undefined;\r\n\r\n        effect = effect as Effect;\r\n\r\n        // Use program\r\n        this.bindSamplers(effect);\r\n\r\n        this._currentEffect = effect;\r\n\r\n        if (effect.onBind) {\r\n            effect.onBind(effect);\r\n        }\r\n        if (effect._onBindObservable) {\r\n            effect._onBindObservable.notifyObservers(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (int)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the int number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setInt(uniform: Nullable<WebGLUniformLocation>, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform1i(uniform, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a int2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setInt2(uniform: Nullable<WebGLUniformLocation>, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2i(uniform, x, y);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a int3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setInt3(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3i(uniform, x, y, z);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a int4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setInt4(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4i(uniform, x, y, z, w);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setIntArray(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform1iv(uniform, array);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setIntArray2(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): boolean {\r\n        if (!uniform || array.length % 2 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2iv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setIntArray3(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): boolean {\r\n        if (!uniform || array.length % 3 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3iv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setIntArray4(uniform: Nullable<WebGLUniformLocation>, array: Int32Array): boolean {\r\n        if (!uniform || array.length % 4 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4iv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (unsigned int)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the unsigned int number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setUInt(uniform: Nullable<WebGLUniformLocation>, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform1ui(uniform, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a unsigned int2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setUInt2(uniform: Nullable<WebGLUniformLocation>, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2ui(uniform, x, y);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a unsigned int3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setUInt3(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3ui(uniform, x, y, z);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a unsigned int4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setUInt4(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4ui(uniform, x, y, z, w);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of unsigned int32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of unsigned int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setUIntArray(uniform: Nullable<WebGLUniformLocation>, array: Uint32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform1uiv(uniform, array);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of unsigned int32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of unsigned int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setUIntArray2(uniform: Nullable<WebGLUniformLocation>, array: Uint32Array): boolean {\r\n        if (!uniform || array.length % 2 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2uiv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of unsigned int32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of unsigned int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setUIntArray3(uniform: Nullable<WebGLUniformLocation>, array: Uint32Array): boolean {\r\n        if (!uniform || array.length % 3 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3uiv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of unsigned int32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of unsigned int32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setUIntArray4(uniform: Nullable<WebGLUniformLocation>, array: Uint32Array): boolean {\r\n        if (!uniform || array.length % 4 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4uiv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setArray(uniform: Nullable<WebGLUniformLocation>, array: FloatArray): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        if (array.length < 1) {\r\n            return false;\r\n        }\r\n        this._gl.uniform1fv(uniform, array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setArray2(uniform: Nullable<WebGLUniformLocation>, array: FloatArray): boolean {\r\n        if (!uniform || array.length % 2 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2fv(uniform, <any>array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setArray3(uniform: Nullable<WebGLUniformLocation>, array: FloatArray): boolean {\r\n        if (!uniform || array.length % 3 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3fv(uniform, <any>array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setArray4(uniform: Nullable<WebGLUniformLocation>, array: FloatArray): boolean {\r\n        if (!uniform || array.length % 4 !== 0) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4fv(uniform, <any>array);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as matrices)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrices defines the array of float32 to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setMatrices(uniform: Nullable<WebGLUniformLocation>, matrices: DeepImmutable<FloatArray>): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniformMatrix4fv(uniform, false, matrices);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (3x3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setMatrix3x3(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniformMatrix3fv(uniform, false, matrix);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (2x2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n     * @returns true if the value was set\r\n     */\r\n    public setMatrix2x2(uniform: Nullable<WebGLUniformLocation>, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniformMatrix2fv(uniform, false, matrix);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (float)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the float number to store\r\n     * @returns true if the value was transferred\r\n     */\r\n    public setFloat(uniform: Nullable<WebGLUniformLocation>, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform1f(uniform, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setFloat2(uniform: Nullable<WebGLUniformLocation>, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform2f(uniform, x, y);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setFloat3(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform3f(uniform, x, y, z);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if the value was set\r\n     */\r\n    public setFloat4(uniform: Nullable<WebGLUniformLocation>, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._gl.uniform4f(uniform, x, y, z, w);\r\n\r\n        return true;\r\n    }\r\n\r\n    // States\r\n\r\n    /**\r\n     * Apply all cached states (depth, culling, stencil and alpha)\r\n     */\r\n    public applyStates() {\r\n        this._depthCullingState.apply(this._gl);\r\n        this._stencilStateComposer.apply(this._gl);\r\n        this._alphaState.apply(this._gl);\r\n\r\n        if (this._colorWriteChanged) {\r\n            this._colorWriteChanged = false;\r\n            const enable = this._colorWrite;\r\n            this._gl.colorMask(enable, enable, enable, enable);\r\n        }\r\n    }\r\n\r\n    // Textures\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames && !bruteForce) {\r\n            return;\r\n        }\r\n        this._currentEffect = null;\r\n        this._viewportCached.x = 0;\r\n        this._viewportCached.y = 0;\r\n        this._viewportCached.z = 0;\r\n        this._viewportCached.w = 0;\r\n\r\n        // Done before in case we clean the attributes\r\n        this._unbindVertexArrayObject();\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n            this.resetTextureCache();\r\n\r\n            this._stencilStateComposer.reset();\r\n\r\n            this._depthCullingState.reset();\r\n            this._depthCullingState.depthFunc = this._gl.LEQUAL;\r\n\r\n            this._alphaState.reset();\r\n            this._alphaMode = Constants.ALPHA_ADD;\r\n            this._alphaEquation = Constants.ALPHA_DISABLE;\r\n\r\n            this._colorWrite = true;\r\n            this._colorWriteChanged = true;\r\n\r\n            this._unpackFlipYCached = null;\r\n\r\n            this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);\r\n            this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n\r\n            this._mustWipeVertexAttributes = true;\r\n            this.unbindAllAttributes();\r\n        }\r\n\r\n        this._resetVertexBufferBinding();\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n        this.bindIndexBuffer(null);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getSamplingParameters(samplingMode: number, generateMipMaps: boolean): { min: number; mag: number } {\r\n        const gl = this._gl;\r\n        let magFilter: GLenum = gl.NEAREST;\r\n        let minFilter: GLenum = gl.NEAREST;\r\n\r\n        switch (samplingMode) {\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n                magFilter = gl.LINEAR;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.LINEAR_MIPMAP_NEAREST;\r\n                } else {\r\n                    minFilter = gl.LINEAR;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n                magFilter = gl.LINEAR;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.LINEAR_MIPMAP_LINEAR;\r\n                } else {\r\n                    minFilter = gl.LINEAR;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n                magFilter = gl.NEAREST;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.NEAREST_MIPMAP_LINEAR;\r\n                } else {\r\n                    minFilter = gl.NEAREST;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n                magFilter = gl.NEAREST;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.NEAREST_MIPMAP_NEAREST;\r\n                } else {\r\n                    minFilter = gl.NEAREST;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n                magFilter = gl.NEAREST;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.LINEAR_MIPMAP_NEAREST;\r\n                } else {\r\n                    minFilter = gl.LINEAR;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n                magFilter = gl.NEAREST;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.LINEAR_MIPMAP_LINEAR;\r\n                } else {\r\n                    minFilter = gl.LINEAR;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_LINEAR:\r\n                magFilter = gl.NEAREST;\r\n                minFilter = gl.LINEAR;\r\n                break;\r\n            case Constants.TEXTURE_NEAREST_NEAREST:\r\n                magFilter = gl.NEAREST;\r\n                minFilter = gl.NEAREST;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n                magFilter = gl.LINEAR;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.NEAREST_MIPMAP_NEAREST;\r\n                } else {\r\n                    minFilter = gl.NEAREST;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n                magFilter = gl.LINEAR;\r\n                if (generateMipMaps) {\r\n                    minFilter = gl.NEAREST_MIPMAP_LINEAR;\r\n                } else {\r\n                    minFilter = gl.NEAREST;\r\n                }\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_LINEAR:\r\n                magFilter = gl.LINEAR;\r\n                minFilter = gl.LINEAR;\r\n                break;\r\n            case Constants.TEXTURE_LINEAR_NEAREST:\r\n                magFilter = gl.LINEAR;\r\n                minFilter = gl.NEAREST;\r\n                break;\r\n        }\r\n\r\n        return {\r\n            min: minFilter,\r\n            mag: magFilter,\r\n        };\r\n    }\r\n\r\n    /** @internal */\r\n    protected _createTexture(): WebGLTexture {\r\n        const texture = this._gl.createTexture();\r\n\r\n        if (!texture) {\r\n            throw new Error(\"Unable to create texture\");\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new WebGLHardwareTexture(this._createTexture(), this._gl);\r\n    }\r\n\r\n    /**\r\n     * Creates an internal texture without binding it to a framebuffer\r\n     * @internal\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\r\n     * @param source source type of the texture\r\n     * @returns a new internal texture\r\n     */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        let generateMipMaps = false;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        let samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        let format = Constants.TEXTUREFORMAT_RGBA;\r\n        let useSRGBBuffer = false;\r\n        let samples = 1;\r\n        let label: string | undefined;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\r\n            samples = options.samples ?? 1;\r\n            label = options.label;\r\n        } else {\r\n            generateMipMaps = !!options;\r\n        }\r\n\r\n        useSRGBBuffer &&= this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const gl = this._gl;\r\n        const texture = new InternalTexture(this, source);\r\n        const width = (<{ width: number; height: number; depth?: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; depth?: number; layers?: number }>size).height || <number>size;\r\n        const depth = (<{ width: number; height: number; depth?: number; layers?: number }>size).depth || 0;\r\n        const layers = (<{ width: number; height: number; depth?: number; layers?: number }>size).layers || 0;\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : depth !== 0 ? gl.TEXTURE_3D : gl.TEXTURE_2D;\r\n        const sizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const textureType = this._getWebGLTextureType(type);\r\n\r\n        // Bind\r\n        this._bindTextureDirectly(target, texture);\r\n\r\n        if (layers !== 0) {\r\n            texture.is2DArray = true;\r\n            gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, textureType, null);\r\n        } else if (depth !== 0) {\r\n            texture.is3D = true;\r\n            gl.texImage3D(target, 0, sizedFormat, width, height, depth, 0, internalFormat, textureType, null);\r\n        } else {\r\n            gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, textureType, null);\r\n        }\r\n\r\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        // MipMaps\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = samples;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture.format = format;\r\n        texture.label = label;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getUseSRGBBuffer(useSRGBBuffer: boolean, noMipmap: boolean): boolean {\r\n        // Generating mipmaps for sRGB textures is not supported in WebGL1 so we must disable the support if mipmaps is enabled\r\n        return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || noMipmap);\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ): InternalTexture {\r\n        return this._createTextureBase(\r\n            url,\r\n            noMipmap,\r\n            invertY,\r\n            scene,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            (...args: Parameters<PrepareTextureFunction>) => this._prepareWebGLTexture(...args, format),\r\n            (potWidth, potHeight, img, extension, texture, continuationCallback) => {\r\n                const gl = this._gl;\r\n                const isPot = img.width === potWidth && img.height === potHeight;\r\n\r\n                texture._creationFlags = creationFlags ?? 0;\r\n\r\n                const tip = this._getTexImageParametersForCreateTexture(texture.format, texture._useSRGBBuffer);\r\n                if (isPot) {\r\n                    gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img as any);\r\n                    return false;\r\n                }\r\n\r\n                const maxTextureSize = this._caps.maxTextureSize;\r\n\r\n                if (img.width > maxTextureSize || img.height > maxTextureSize || !this._supportsHardwareTextureRescaling) {\r\n                    this._prepareWorkingCanvas();\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        return false;\r\n                    }\r\n\r\n                    this._workingCanvas.width = potWidth;\r\n                    this._workingCanvas.height = potHeight;\r\n\r\n                    this._workingContext.drawImage(img as any, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);\r\n                    gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, this._workingCanvas as TexImageSource);\r\n\r\n                    texture.width = potWidth;\r\n                    texture.height = potHeight;\r\n\r\n                    return false;\r\n                } else {\r\n                    // Using shaders when possible to rescale because canvas.drawImage is lossy\r\n                    const source = new InternalTexture(this, InternalTextureSource.Temp);\r\n                    this._bindTextureDirectly(gl.TEXTURE_2D, source, true);\r\n                    gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img as any);\r\n\r\n                    this._rescaleTexture(source, texture, scene, tip.format, () => {\r\n                        this._releaseTexture(source);\r\n                        this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n\r\n                        continuationCallback();\r\n                    });\r\n                }\r\n\r\n                return true;\r\n            },\r\n            buffer,\r\n            fallback,\r\n            format,\r\n            forcedExtension,\r\n            mimeType,\r\n            loaderOptions,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Calls to the GL texImage2D and texImage3D functions require three arguments describing the pixel format of the texture.\r\n     * createTexture derives these from the babylonFormat and useSRGBBuffer arguments and also the file extension of the URL it's working with.\r\n     * This function encapsulates that derivation for easy unit testing.\r\n     * @param babylonFormat Babylon's format enum, as specified in ITextureCreationOptions.\r\n     * @param fileExtension The file extension including the dot, e.g. .jpg.\r\n     * @param useSRGBBuffer Use SRGB not linear.\r\n     * @returns The options to pass to texImage2D or texImage3D calls.\r\n     * @internal\r\n     */\r\n    public _getTexImageParametersForCreateTexture(babylonFormat: number, useSRGBBuffer: boolean): TexImageParameters {\r\n        let format: number, internalFormat: number;\r\n        if (this.webGLVersion === 1) {\r\n            // In WebGL 1, format and internalFormat must be the same and taken from a limited set of values, see https://docs.gl/es2/glTexImage2D.\r\n            // The SRGB extension (https://developer.mozilla.org/en-US/docs/Web/API/EXT_sRGB) adds some extra values, hence passing useSRGBBuffer\r\n            // to getInternalFormat.\r\n            format = this._getInternalFormat(babylonFormat, useSRGBBuffer);\r\n            internalFormat = format;\r\n        } else {\r\n            // In WebGL 2, format has a wider range of values and internal format can be one of the sized formats, see\r\n            // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml.\r\n            // SRGB is included in the sized format and should not be passed in \"format\", hence always passing useSRGBBuffer as false.\r\n            format = this._getInternalFormat(babylonFormat, false);\r\n            internalFormat = this._getRGBABufferInternalSizedFormat(Constants.TEXTURETYPE_UNSIGNED_BYTE, babylonFormat, useSRGBBuffer);\r\n        }\r\n\r\n        return {\r\n            internalFormat,\r\n            format,\r\n            type: this._gl.UNSIGNED_BYTE,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rescaleTexture(source: InternalTexture, destination: InternalTexture, scene: Nullable<any>, internalFormat: number, onComplete: () => void): void {}\r\n\r\n    private _unpackFlipYCached: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * In case you are sharing the context with other applications, it might\r\n     * be interested to not cache the unpack flip y state to ensure a consistent\r\n     * value would be set.\r\n     */\r\n    public enableUnpackFlipYCached = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unpackFlipY(value: boolean): void {\r\n        if (this._unpackFlipYCached !== value) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);\r\n\r\n            if (this.enableUnpackFlipYCached) {\r\n                this._unpackFlipYCached = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _getUnpackAlignement(): number {\r\n        return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getTextureTarget(texture: InternalTexture): number {\r\n        if (texture.isCube) {\r\n            return this._gl.TEXTURE_CUBE_MAP;\r\n        } else if (texture.is3D) {\r\n            return this._gl.TEXTURE_3D;\r\n        } else if (texture.is2DArray || texture.isMultiview) {\r\n            return this._gl.TEXTURE_2D_ARRAY;\r\n        }\r\n        return this._gl.TEXTURE_2D;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     * @param generateMipMaps defines whether to generate mipmaps for the texture\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture, generateMipMaps: boolean = false): void {\r\n        const target = this._getTextureTarget(texture);\r\n        const filters = this._getSamplingParameters(samplingMode, texture.useMipMaps || generateMipMaps);\r\n\r\n        this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);\r\n        this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            texture.generateMipMaps = true;\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the dimensions of a texture\r\n     * @param texture texture to update\r\n     * @param width new width of the texture\r\n     * @param height new height of the texture\r\n     * @param depth new depth of the texture\r\n     */\r\n    public updateTextureDimensions(texture: InternalTexture, width: number, height: number, depth: number = 1): void {}\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param texture defines the texture to update\r\n     * @param wrapU defines the texture wrap mode of the u coordinates\r\n     * @param wrapV defines the texture wrap mode of the v coordinates\r\n     * @param wrapR defines the texture wrap mode of the r coordinates\r\n     */\r\n    public updateTextureWrappingMode(texture: InternalTexture, wrapU: Nullable<number>, wrapV: Nullable<number> = null, wrapR: Nullable<number> = null): void {\r\n        const target = this._getTextureTarget(texture);\r\n\r\n        if (wrapU !== null) {\r\n            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);\r\n            texture._cachedWrapU = wrapU;\r\n        }\r\n        if (wrapV !== null) {\r\n            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);\r\n            texture._cachedWrapV = wrapV;\r\n        }\r\n        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\r\n            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);\r\n            texture._cachedWrapR = wrapR;\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        const gl = this._gl;\r\n\r\n        let target: GLenum = gl.TEXTURE_2D;\r\n        if (texture.isCube) {\r\n            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\r\n        }\r\n\r\n        if (texture._useSRGBBuffer) {\r\n            switch (internalFormat) {\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n                    // Note, if using ETC1 and sRGB is requested, this will use ETC2 if available.\r\n                    if (this._caps.etc2) {\r\n                        internalFormat = gl.COMPRESSED_SRGB8_ETC2;\r\n                    } else {\r\n                        texture._useSRGBBuffer = false;\r\n                    }\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n                    if (this._caps.etc2) {\r\n                        internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;\r\n                    } else {\r\n                        texture._useSRGBBuffer = false;\r\n                    }\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n                    internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n                    internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n                    if (this._caps.s3tc_srgb) {\r\n                        internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;\r\n                    } else {\r\n                        // S3TC sRGB extension not supported\r\n                        texture._useSRGBBuffer = false;\r\n                    }\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n                    if (this._caps.s3tc_srgb) {\r\n                        internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\r\n                    } else {\r\n                        // S3TC sRGB extension not supported\r\n                        texture._useSRGBBuffer = false;\r\n                    }\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n                    if (this._caps.s3tc_srgb) {\r\n                        internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\r\n                    } else {\r\n                        // S3TC sRGB extension not supported\r\n                        texture._useSRGBBuffer = false;\r\n                    }\r\n                    break;\r\n                default:\r\n                    // We don't support a sRGB format corresponding to internalFormat, so revert to non sRGB format\r\n                    texture._useSRGBBuffer = false;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, <DataView>data);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        babylonInternalFormat?: number,\r\n        useTextureWidthAndHeight = false\r\n    ): void {\r\n        const gl = this._gl;\r\n\r\n        const textureType = this._getWebGLTextureType(texture.type);\r\n        const format = this._getInternalFormat(texture.format);\r\n        const internalFormat =\r\n            babylonInternalFormat === undefined\r\n                ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer)\r\n                : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);\r\n\r\n        this._unpackFlipY(texture.invertY);\r\n\r\n        let target: GLenum = gl.TEXTURE_2D;\r\n        if (texture.isCube) {\r\n            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\r\n        }\r\n\r\n        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\r\n        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\r\n        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\r\n        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\r\n\r\n        gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        const gl = this._gl;\r\n\r\n        const textureType = this._getWebGLTextureType(texture.type);\r\n        const format = this._getInternalFormat(texture.format);\r\n\r\n        this._unpackFlipY(texture.invertY);\r\n\r\n        let targetForBinding: GLenum = gl.TEXTURE_2D;\r\n        let target: GLenum = gl.TEXTURE_2D;\r\n        if (texture.isCube) {\r\n            target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\r\n            targetForBinding = gl.TEXTURE_CUBE_MAP;\r\n        }\r\n\r\n        this._bindTextureDirectly(targetForBinding, texture, true);\r\n\r\n        gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(targetForBinding, null);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        const gl = this._gl;\r\n        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\r\n\r\n        this._bindTextureDirectly(bindTarget, texture, true);\r\n\r\n        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\r\n\r\n        this._bindTextureDirectly(bindTarget, null, true);\r\n    }\r\n\r\n    protected _prepareWebGLTextureContinuation(texture: InternalTexture, scene: Nullable<ISceneLike>, noMipmap: boolean, isCompressed: boolean, samplingMode: number): void {\r\n        const gl = this._gl;\r\n        if (!gl) {\r\n            return;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, !noMipmap);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (!noMipmap && !isCompressed) {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n\r\n        // this.resetTextureCache();\r\n        if (scene) {\r\n            scene.removePendingData(texture);\r\n        }\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n    }\r\n\r\n    private _prepareWebGLTexture(\r\n        texture: InternalTexture,\r\n        extension: string,\r\n        scene: Nullable<ISceneLike>,\r\n        img: HTMLImageElement | ImageBitmap | { width: number; height: number },\r\n        invertY: boolean,\r\n        noMipmap: boolean,\r\n        isCompressed: boolean,\r\n        processFunction: PrepareTextureProcessFunction,\r\n        samplingMode: number,\r\n        format: Nullable<number>\r\n    ): void {\r\n        const maxTextureSize = this.getCaps().maxTextureSize;\r\n        const potWidth = Math.min(maxTextureSize, this.needPOTTextures ? GetExponentOfTwo(img.width, maxTextureSize) : img.width);\r\n        const potHeight = Math.min(maxTextureSize, this.needPOTTextures ? GetExponentOfTwo(img.height, maxTextureSize) : img.height);\r\n\r\n        const gl = this._gl;\r\n        if (!gl) {\r\n            return;\r\n        }\r\n\r\n        if (!texture._hardwareTexture) {\r\n            //  this.resetTextureCache();\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        texture.baseWidth = img.width;\r\n        texture.baseHeight = img.height;\r\n        texture.width = potWidth;\r\n        texture.height = potHeight;\r\n        texture.isReady = true;\r\n        texture.type = texture.type !== -1 ? texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        texture.format =\r\n            texture.format !== -1 ? texture.format : format ?? (extension === \".jpg\" && !texture._useSRGBBuffer ? Constants.TEXTUREFORMAT_RGB : Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        if (\r\n            processFunction(potWidth, potHeight, img, extension, texture, () => {\r\n                this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);\r\n            })\r\n        ) {\r\n            // Returning as texture needs extra async steps\r\n            return;\r\n        }\r\n\r\n        this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setupFramebufferDepthAttachments(\r\n        generateStencilBuffer: boolean,\r\n        generateDepthBuffer: boolean,\r\n        width: number,\r\n        height: number,\r\n        samples = 1\r\n    ): Nullable<WebGLRenderbuffer> {\r\n        const gl = this._gl;\r\n\r\n        // Create the depth/stencil buffer\r\n        if (generateStencilBuffer && generateDepthBuffer) {\r\n            return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);\r\n        }\r\n        if (generateDepthBuffer) {\r\n            let depthFormat: GLenum = gl.DEPTH_COMPONENT16;\r\n            if (this._webGLVersion > 1) {\r\n                depthFormat = gl.DEPTH_COMPONENT32F;\r\n            }\r\n\r\n            return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);\r\n        }\r\n        if (generateStencilBuffer) {\r\n            return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createRenderBuffer(\r\n        width: number,\r\n        height: number,\r\n        samples: number,\r\n        internalFormat: number,\r\n        msInternalFormat: number,\r\n        attachment: number,\r\n        unbindBuffer = true\r\n    ): Nullable<WebGLRenderbuffer> {\r\n        const gl = this._gl;\r\n        const renderBuffer = gl.createRenderbuffer();\r\n        return this._updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer);\r\n    }\r\n\r\n    public _updateRenderBuffer(\r\n        renderBuffer: Nullable<WebGLRenderbuffer>,\r\n        width: number,\r\n        height: number,\r\n        samples: number,\r\n        internalFormat: number,\r\n        msInternalFormat: number,\r\n        attachment: number,\r\n        unbindBuffer = true\r\n    ): Nullable<WebGLRenderbuffer> {\r\n        const gl = this._gl;\r\n\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);\r\n\r\n        if (samples > 1 && gl.renderbufferStorageMultisample) {\r\n            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);\r\n        } else {\r\n            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);\r\n        }\r\n\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);\r\n\r\n        if (unbindBuffer) {\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n        }\r\n\r\n        return renderBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n        this._deleteTexture(texture._hardwareTexture as Nullable<WebGLHardwareTexture>);\r\n\r\n        // Unbind channels\r\n        this.unbindAllTextures();\r\n\r\n        const index = this._internalTexturesCache.indexOf(texture);\r\n        if (index !== -1) {\r\n            this._internalTexturesCache.splice(index, 1);\r\n        }\r\n\r\n        // Integrated fixed lod samplers.\r\n        if (texture._lodTextureHigh) {\r\n            texture._lodTextureHigh.dispose();\r\n        }\r\n        if (texture._lodTextureMid) {\r\n            texture._lodTextureMid.dispose();\r\n        }\r\n        if (texture._lodTextureLow) {\r\n            texture._lodTextureLow.dispose();\r\n        }\r\n\r\n        // Integrated irradiance map.\r\n        if (texture._irradianceTexture) {\r\n            texture._irradianceTexture.dispose();\r\n        }\r\n    }\r\n\r\n    protected _deleteTexture(texture: Nullable<WebGLHardwareTexture>): void {\r\n        texture?.release();\r\n    }\r\n\r\n    protected _setProgram(program: WebGLProgram): void {\r\n        if (this._currentProgram !== program) {\r\n            _setProgram(program, this._gl);\r\n            this._currentProgram = program;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _boundUniforms: { [key: number]: WebGLUniformLocation } = {};\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public bindSamplers(effect: Effect): void {\r\n        const webGLPipelineContext = effect.getPipelineContext() as WebGLPipelineContext;\r\n        this._setProgram(webGLPipelineContext.program!);\r\n        const samplers = effect.getSamplers();\r\n        for (let index = 0; index < samplers.length; index++) {\r\n            const uniform = effect.getUniform(samplers[index]);\r\n\r\n            if (uniform) {\r\n                this._boundUniforms[index] = uniform;\r\n            }\r\n        }\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    private _activateCurrentTexture() {\r\n        if (this._currentTextureChannel !== this._activeChannel) {\r\n            this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);\r\n            this._currentTextureChannel = this._activeChannel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTextureDirectly(target: number, texture: Nullable<InternalTexture>, forTextureDataUpdate = false, force = false): boolean {\r\n        let wasPreviouslyBound = false;\r\n        const isTextureForRendering = texture && texture._associatedChannel > -1;\r\n        if (forTextureDataUpdate && isTextureForRendering) {\r\n            this._activeChannel = texture!._associatedChannel;\r\n        }\r\n\r\n        const currentTextureBound = this._boundTexturesCache[this._activeChannel];\r\n\r\n        if (currentTextureBound !== texture || force) {\r\n            this._activateCurrentTexture();\r\n\r\n            if (texture && texture.isMultiview) {\r\n                //this._gl.bindTexture(target, texture ? texture._colorTextureArray : null);\r\n                Logger.Error([\"_bindTextureDirectly called with a multiview texture!\", target, texture]);\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"_bindTextureDirectly called with a multiview texture!\";\r\n            } else {\r\n                this._gl.bindTexture(target, texture?._hardwareTexture?.underlyingResource ?? null);\r\n            }\r\n\r\n            this._boundTexturesCache[this._activeChannel] = texture;\r\n\r\n            if (texture) {\r\n                texture._associatedChannel = this._activeChannel;\r\n            }\r\n        } else if (forTextureDataUpdate) {\r\n            wasPreviouslyBound = true;\r\n            this._activateCurrentTexture();\r\n        }\r\n\r\n        if (isTextureForRendering && !forTextureDataUpdate) {\r\n            this._bindSamplerUniformToChannel(texture!._associatedChannel, this._activeChannel);\r\n        }\r\n\r\n        return wasPreviouslyBound;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: Nullable<InternalTexture>, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (texture) {\r\n            texture._associatedChannel = channel;\r\n        }\r\n\r\n        this._activeChannel = channel;\r\n        const target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;\r\n        this._bindTextureDirectly(target, texture);\r\n    }\r\n\r\n    /**\r\n     * Unbind all textures from the webGL context\r\n     */\r\n    public unbindAllTextures(): void {\r\n        for (let channel = 0; channel < this._maxSimultaneousTextures; channel++) {\r\n            this._activeChannel = channel;\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n            if (this.webGLVersion > 1) {\r\n                this._bindTextureDirectly(this._gl.TEXTURE_3D, null);\r\n                this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to the according uniform.\r\n     * @param channel The texture channel\r\n     * @param uniform The uniform to set\r\n     * @param texture The texture to apply\r\n     * @param name The name of the uniform in the effect\r\n     */\r\n    public setTexture(channel: number, uniform: Nullable<WebGLUniformLocation>, texture: Nullable<ThinTexture>, name: string): void {\r\n        if (channel === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (uniform) {\r\n            this._boundUniforms[channel] = uniform;\r\n        }\r\n\r\n        this._setTexture(channel, texture);\r\n    }\r\n\r\n    private _bindSamplerUniformToChannel(sourceSlot: number, destination: number) {\r\n        const uniform = this._boundUniforms[sourceSlot];\r\n        if (!uniform || uniform._currentState === destination) {\r\n            return;\r\n        }\r\n        this._gl.uniform1i(uniform, destination);\r\n        uniform._currentState = destination;\r\n    }\r\n\r\n    private _getTextureWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n                return this._gl.REPEAT;\r\n            case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n                return this._gl.CLAMP_TO_EDGE;\r\n            case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n                return this._gl.MIRRORED_REPEAT;\r\n        }\r\n        return this._gl.REPEAT;\r\n    }\r\n\r\n    public override _setTexture(channel: number, texture: Nullable<ThinTexture>, isPartOfTextureArray = false, depthStencilTexture = false, name = \"\"): boolean {\r\n        // Not ready?\r\n        if (!texture) {\r\n            if (this._boundTexturesCache[channel] != null) {\r\n                this._activeChannel = channel;\r\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n                if (this.webGLVersion > 1) {\r\n                    this._bindTextureDirectly(this._gl.TEXTURE_3D, null);\r\n                    this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Video\r\n        if ((<VideoTexture>texture).video) {\r\n            this._activeChannel = channel;\r\n            const videoInternalTexture = (<VideoTexture>texture).getInternalTexture();\r\n            if (videoInternalTexture) {\r\n                videoInternalTexture._associatedChannel = channel;\r\n            }\r\n            (<VideoTexture>texture).update();\r\n        } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            // Delay loading\r\n            texture.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        let internalTexture: InternalTexture;\r\n        if (depthStencilTexture) {\r\n            internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n        } else if (texture.isReady()) {\r\n            internalTexture = <InternalTexture>texture.getInternalTexture();\r\n        } else if (texture.isCube) {\r\n            internalTexture = this.emptyCubeTexture;\r\n        } else if (texture.is3D) {\r\n            internalTexture = this.emptyTexture3D;\r\n        } else if (texture.is2DArray) {\r\n            internalTexture = this.emptyTexture2DArray;\r\n        } else {\r\n            internalTexture = this.emptyTexture;\r\n        }\r\n\r\n        if (!isPartOfTextureArray && internalTexture) {\r\n            internalTexture._associatedChannel = channel;\r\n        }\r\n\r\n        let needToBind = true;\r\n        if (this._boundTexturesCache[channel] === internalTexture) {\r\n            if (!isPartOfTextureArray) {\r\n                this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);\r\n            }\r\n\r\n            needToBind = false;\r\n        }\r\n\r\n        this._activeChannel = channel;\r\n        const target = this._getTextureTarget(internalTexture);\r\n        if (needToBind) {\r\n            this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);\r\n        }\r\n\r\n        if (internalTexture && !internalTexture.isMultiview) {\r\n            // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\r\n            if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\r\n                internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\r\n\r\n                const textureWrapMode =\r\n                    texture.coordinatesMode !== Constants.TEXTURE_CUBIC_MODE && texture.coordinatesMode !== Constants.TEXTURE_SKYBOX_MODE\r\n                        ? Constants.TEXTURE_WRAP_ADDRESSMODE\r\n                        : Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                texture.wrapU = textureWrapMode;\r\n                texture.wrapV = textureWrapMode;\r\n            }\r\n\r\n            if (internalTexture._cachedWrapU !== texture.wrapU) {\r\n                internalTexture._cachedWrapU = texture.wrapU;\r\n                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);\r\n            }\r\n\r\n            if (internalTexture._cachedWrapV !== texture.wrapV) {\r\n                internalTexture._cachedWrapV = texture.wrapV;\r\n                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);\r\n            }\r\n\r\n            if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {\r\n                internalTexture._cachedWrapR = texture.wrapR;\r\n                this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);\r\n            }\r\n\r\n            this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets an array of texture to the webGL context\r\n     * @param channel defines the channel where the texture array must be set\r\n     * @param uniform defines the associated uniform location\r\n     * @param textures defines the array of textures to bind\r\n     * @param name name of the channel\r\n     */\r\n    public setTextureArray(channel: number, uniform: Nullable<WebGLUniformLocation>, textures: ThinTexture[], name: string): void {\r\n        if (channel === undefined || !uniform) {\r\n            return;\r\n        }\r\n\r\n        if (!this._textureUnits || this._textureUnits.length !== textures.length) {\r\n            this._textureUnits = new Int32Array(textures.length);\r\n        }\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i].getInternalTexture();\r\n\r\n            if (texture) {\r\n                this._textureUnits[i] = channel + i;\r\n                texture._associatedChannel = channel + i;\r\n            } else {\r\n                this._textureUnits[i] = -1;\r\n            }\r\n        }\r\n        this._gl.uniform1iv(uniform, this._textureUnits);\r\n\r\n        for (let index = 0; index < textures.length; index++) {\r\n            this._setTexture(this._textureUnits[index], textures[index], true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setAnisotropicLevel(target: number, internalTexture: InternalTexture, anisotropicFilteringLevel: number) {\r\n        const anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;\r\n        if (\r\n            internalTexture.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST &&\r\n            internalTexture.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR &&\r\n            internalTexture.samplingMode !== Constants.TEXTURE_LINEAR_LINEAR\r\n        ) {\r\n            anisotropicFilteringLevel = 1; // Forcing the anisotropic to 1 because else webgl will force filters to linear\r\n        }\r\n\r\n        if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\r\n            this._setTextureParameterFloat(\r\n                target,\r\n                anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT,\r\n                Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy),\r\n                internalTexture\r\n            );\r\n            internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;\r\n        }\r\n    }\r\n\r\n    private _setTextureParameterFloat(target: number, parameter: number, value: number, texture: InternalTexture): void {\r\n        this._bindTextureDirectly(target, texture, true, true);\r\n        this._gl.texParameterf(target, parameter, value);\r\n    }\r\n\r\n    private _setTextureParameterInteger(target: number, parameter: number, value: number, texture?: InternalTexture) {\r\n        if (texture) {\r\n            this._bindTextureDirectly(target, texture, true, true);\r\n        }\r\n        this._gl.texParameteri(target, parameter, value);\r\n    }\r\n\r\n    /**\r\n     * Unbind all vertex attributes from the webGL context\r\n     */\r\n    public unbindAllAttributes() {\r\n        if (this._mustWipeVertexAttributes) {\r\n            this._mustWipeVertexAttributes = false;\r\n\r\n            for (let i = 0; i < this._caps.maxVertexAttribs; i++) {\r\n                this.disableAttributeByIndex(i);\r\n            }\r\n            return;\r\n        }\r\n\r\n        for (let i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {\r\n            if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {\r\n                continue;\r\n            }\r\n\r\n            this.disableAttributeByIndex(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n        for (const name in this._compiledEffects) {\r\n            const webGLPipelineContext = this._compiledEffects[name].getPipelineContext() as WebGLPipelineContext;\r\n            this._deletePipelineContext(webGLPipelineContext);\r\n        }\r\n\r\n        this._compiledEffects = {};\r\n    }\r\n\r\n    /**\r\n     * Dispose and release all associated resources\r\n     */\r\n    public override dispose(): void {\r\n        // Events\r\n        if (IsWindowObjectExist()) {\r\n            if (this._renderingCanvas) {\r\n                if (!this._doNotHandleContextLost) {\r\n                    this._renderingCanvas.removeEventListener(\"webglcontextlost\", this._onContextLost);\r\n                    this._renderingCanvas.removeEventListener(\"webglcontextrestored\", this._onContextRestored);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Should not be moved up of renderingCanvas will be null.\r\n        super.dispose();\r\n\r\n        if (this._dummyFramebuffer) {\r\n            this._gl.deleteFramebuffer(this._dummyFramebuffer);\r\n        }\r\n\r\n        // Unbind\r\n        this.unbindAllAttributes();\r\n        this._boundUniforms = {};\r\n\r\n        this._workingCanvas = null;\r\n        this._workingContext = null;\r\n        this._currentBufferPointers.length = 0;\r\n        this._currentProgram = null;\r\n\r\n        if ((this._creationOptions as EngineOptions).loseContextOnDispose) {\r\n            this._gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\r\n        }\r\n        // clear the state object\r\n        deleteStateObject(this._gl);\r\n    }\r\n\r\n    /**\r\n     * Attach a new callback raised when context lost event is fired\r\n     * @param callback defines the callback to call\r\n     */\r\n    public attachContextLostEvent(callback: (event: WebGLContextEvent) => void): void {\r\n        if (this._renderingCanvas) {\r\n            this._renderingCanvas.addEventListener(\"webglcontextlost\", <any>callback, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach a new callback raised when context restored event is fired\r\n     * @param callback defines the callback to call\r\n     */\r\n    public attachContextRestoredEvent(callback: (event: WebGLContextEvent) => void): void {\r\n        if (this._renderingCanvas) {\r\n            this._renderingCanvas.addEventListener(\"webglcontextrestored\", <any>callback, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n     */\r\n    public getError(): number {\r\n        return this._gl.getError();\r\n    }\r\n\r\n    private _canRenderToFloatFramebuffer(): boolean {\r\n        if (this._webGLVersion > 1) {\r\n            return this._caps.colorBufferFloat;\r\n        }\r\n        return this._canRenderToFramebuffer(Constants.TEXTURETYPE_FLOAT);\r\n    }\r\n\r\n    private _canRenderToHalfFloatFramebuffer(): boolean {\r\n        if (this._webGLVersion > 1) {\r\n            return this._caps.colorBufferFloat;\r\n        }\r\n        return this._canRenderToFramebuffer(Constants.TEXTURETYPE_HALF_FLOAT);\r\n    }\r\n\r\n    // Thank you : http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture\r\n    private _canRenderToFramebuffer(type: number): boolean {\r\n        const gl = this._gl;\r\n\r\n        //clear existing errors\r\n        // eslint-disable-next-line no-empty\r\n        while (gl.getError() !== gl.NO_ERROR) {}\r\n\r\n        let successful = true;\r\n\r\n        const texture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n        const fb = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n\r\n        successful = successful && status === gl.FRAMEBUFFER_COMPLETE;\r\n        successful = successful && gl.getError() === gl.NO_ERROR;\r\n\r\n        //try render by clearing frame buffer's color buffer\r\n        if (successful) {\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n            successful = successful && gl.getError() === gl.NO_ERROR;\r\n        }\r\n\r\n        //try reading from frame to ensure render occurs (just creating the FBO is not sufficient to determine if rendering is supported)\r\n        if (successful) {\r\n            //in practice it's sufficient to just read from the backbuffer rather than handle potentially issues reading from the texture\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            const readFormat = gl.RGBA;\r\n            const readType = gl.UNSIGNED_BYTE;\r\n            const buffer = new Uint8Array(4);\r\n            gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);\r\n            successful = successful && gl.getError() === gl.NO_ERROR;\r\n        }\r\n\r\n        //clean up\r\n        gl.deleteTexture(texture);\r\n        gl.deleteFramebuffer(fb);\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        //clear accumulated errors\r\n        // eslint-disable-next-line no-empty\r\n        while (!successful && gl.getError() !== gl.NO_ERROR) {}\r\n\r\n        return successful;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getWebGLTextureType(type: number): number {\r\n        if (this._webGLVersion === 1) {\r\n            switch (type) {\r\n                case Constants.TEXTURETYPE_FLOAT:\r\n                    return this._gl.FLOAT;\r\n                case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                    return this._gl.HALF_FLOAT_OES;\r\n                case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                    return this._gl.UNSIGNED_BYTE;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                    return this._gl.UNSIGNED_SHORT_4_4_4_4;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                    return this._gl.UNSIGNED_SHORT_5_5_5_1;\r\n                case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                    return this._gl.UNSIGNED_SHORT_5_6_5;\r\n            }\r\n            return this._gl.UNSIGNED_BYTE;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                return this._gl.BYTE;\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                return this._gl.UNSIGNED_BYTE;\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                return this._gl.SHORT;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                return this._gl.UNSIGNED_SHORT;\r\n            case Constants.TEXTURETYPE_INT:\r\n                return this._gl.INT;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                return this._gl.UNSIGNED_INT;\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                return this._gl.FLOAT;\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                return this._gl.HALF_FLOAT;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                return this._gl.UNSIGNED_SHORT_4_4_4_4;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                return this._gl.UNSIGNED_SHORT_5_5_5_1;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                return this._gl.UNSIGNED_SHORT_5_6_5;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                return this._gl.UNSIGNED_INT_2_10_10_10_REV;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_24_8:\r\n                return this._gl.UNSIGNED_INT_24_8;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                return this._gl.UNSIGNED_INT_10F_11F_11F_REV;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                return this._gl.UNSIGNED_INT_5_9_9_9_REV;\r\n            case Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV:\r\n                return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n        }\r\n\r\n        return this._gl.UNSIGNED_BYTE;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getInternalFormat(format: number, useSRGBBuffer = false): number {\r\n        let internalFormat: GLenum = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;\r\n\r\n        switch (format) {\r\n            case Constants.TEXTUREFORMAT_ALPHA:\r\n                internalFormat = this._gl.ALPHA;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                internalFormat = this._gl.LUMINANCE;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                internalFormat = this._gl.LUMINANCE_ALPHA;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_RED:\r\n                internalFormat = this._gl.RED;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_RG:\r\n                internalFormat = this._gl.RG;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_RGB:\r\n                internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;\r\n                break;\r\n            case Constants.TEXTUREFORMAT_RGBA:\r\n                internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;\r\n                break;\r\n        }\r\n\r\n        if (this._webGLVersion > 1) {\r\n            switch (format) {\r\n                case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                    internalFormat = this._gl.RED_INTEGER;\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                    internalFormat = this._gl.RG_INTEGER;\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                    internalFormat = this._gl.RGB_INTEGER;\r\n                    break;\r\n                case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                    internalFormat = this._gl.RGBA_INTEGER;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return internalFormat;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getRGBABufferInternalSizedFormat(type: number, format?: number, useSRGBBuffer = false): number {\r\n        if (this._webGLVersion === 1) {\r\n            if (format !== undefined) {\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        return this._gl.ALPHA;\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        return this._gl.LUMINANCE;\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        return this._gl.LUMINANCE_ALPHA;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;\r\n                }\r\n            }\r\n            return this._gl.RGBA;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return this._gl.R8_SNORM;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return this._gl.RG8_SNORM;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        return this._gl.RGB8_SNORM;\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R8I;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG8I;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB8I;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA8I;\r\n                    default:\r\n                        return this._gl.RGBA8_SNORM;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return this._gl.R8;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return this._gl.RG8;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8; // By default. Other possibilities are RGB565, SRGB8.\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8; // By default. Other possibilities are RGB5_A1, RGBA4, SRGB8_ALPHA8.\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R8UI;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG8UI;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB8UI;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA8UI;\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        return this._gl.ALPHA;\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        return this._gl.LUMINANCE;\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        return this._gl.LUMINANCE_ALPHA;\r\n                    default:\r\n                        return this._gl.RGBA8;\r\n                }\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R16I;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG16I;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB16I;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA16I;\r\n                    default:\r\n                        return this._gl.RGBA16I;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R16UI;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG16UI;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB16UI;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA16UI;\r\n                    default:\r\n                        return this._gl.RGBA16UI;\r\n                }\r\n            case Constants.TEXTURETYPE_INT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R32I;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG32I;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB32I;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA32I;\r\n                    default:\r\n                        return this._gl.RGBA32I;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return this._gl.R32UI;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return this._gl.RG32UI;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        return this._gl.RGB32UI;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGBA32UI;\r\n                    default:\r\n                        return this._gl.RGBA32UI;\r\n                }\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return this._gl.R32F; // By default. Other possibility is R16F.\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return this._gl.RG32F; // By default. Other possibility is RG16F.\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        return this._gl.RGB32F; // By default. Other possibilities are RGB16F, R11F_G11F_B10F, RGB9_E5.\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return this._gl.RGBA32F; // By default. Other possibility is RGBA16F.\r\n                    default:\r\n                        return this._gl.RGBA32F;\r\n                }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return this._gl.R16F;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return this._gl.RG16F;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        return this._gl.RGB16F; // By default. Other possibilities are R11F_G11F_B10F, RGB9_E5.\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return this._gl.RGBA16F;\r\n                    default:\r\n                        return this._gl.RGBA16F;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                return this._gl.RGB565;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                return this._gl.R11F_G11F_B10F;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                return this._gl.RGB9_E5;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                return this._gl.RGBA4;\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                return this._gl.RGB5_A1;\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return this._gl.RGB10_A2; // By default. Other possibility is RGB5_A1.\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return this._gl.RGB10_A2UI;\r\n                    default:\r\n                        return this._gl.RGB10_A2;\r\n                }\r\n        }\r\n\r\n        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;\r\n    }\r\n\r\n    /**\r\n     * Reads pixels from the current frame buffer. Please note that this function can be slow\r\n     * @param x defines the x coordinate of the rectangle where pixels must be read\r\n     * @param y defines the y coordinate of the rectangle where pixels must be read\r\n     * @param width defines the width of the rectangle where pixels must be read\r\n     * @param height defines the height of the rectangle where pixels must be read\r\n     * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\r\n     */\r\n    public readPixels(x: number, y: number, width: number, height: number, hasAlpha = true, flushRenderer = true): Promise<ArrayBufferView> {\r\n        const numChannels = hasAlpha ? 4 : 3;\r\n        const format = hasAlpha ? this._gl.RGBA : this._gl.RGB;\r\n        const data = new Uint8Array(height * width * numChannels);\r\n        if (flushRenderer) {\r\n            this.flushFramebuffer();\r\n        }\r\n        this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    // Statics\r\n\r\n    private static _IsSupported: Nullable<boolean> = null;\r\n    private static _HasMajorPerformanceCaveat: Nullable<boolean> = null;\r\n\r\n    /**\r\n     * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a webGL context can be found)\r\n     */\r\n    public static get IsSupportedAsync(): Promise<boolean> {\r\n        return Promise.resolve(this.isSupported());\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        return this.isSupported(); // Backward compat\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)\r\n     * @returns true if the engine can be created\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static isSupported(): boolean {\r\n        if (this._HasMajorPerformanceCaveat !== null) {\r\n            return !this._HasMajorPerformanceCaveat; // We know it is performant so WebGL is supported\r\n        }\r\n\r\n        if (this._IsSupported === null) {\r\n            try {\r\n                const tempcanvas = AbstractEngine._CreateCanvas(1, 1);\r\n                const gl = tempcanvas.getContext(\"webgl\") || (tempcanvas as any).getContext(\"experimental-webgl\");\r\n\r\n                this._IsSupported = gl != null && !!window.WebGLRenderingContext;\r\n            } catch (e) {\r\n                this._IsSupported = false;\r\n            }\r\n        }\r\n\r\n        return this._IsSupported;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the engine can be instantiated on a performant device (ie. if a webGL context can be found and it does not use a slow implementation)\r\n     */\r\n    public static get HasMajorPerformanceCaveat(): boolean {\r\n        if (this._HasMajorPerformanceCaveat === null) {\r\n            try {\r\n                const tempcanvas = AbstractEngine._CreateCanvas(1, 1);\r\n                const gl =\r\n                    tempcanvas.getContext(\"webgl\", { failIfMajorPerformanceCaveat: true }) ||\r\n                    (tempcanvas as any).getContext(\"experimental-webgl\", { failIfMajorPerformanceCaveat: true });\r\n\r\n                this._HasMajorPerformanceCaveat = !gl;\r\n            } catch (e) {\r\n                this._HasMajorPerformanceCaveat = false;\r\n            }\r\n        }\r\n\r\n        return this._HasMajorPerformanceCaveat;\r\n    }\r\n\r\n    /**\r\n     * Find the next highest power of two.\r\n     * @param x Number to start search from.\r\n     * @returns Next highest power of two.\r\n     */\r\n    public static CeilingPOT: (x: number) => number = CeilingPOT;\r\n\r\n    /**\r\n     * Find the next lowest power of two.\r\n     * @param x Number to start search from.\r\n     * @returns Next lowest power of two.\r\n     */\r\n    public static FloorPOT: (x: number) => number = FloorPOT;\r\n\r\n    /**\r\n     * Find the nearest power of two.\r\n     * @param x Number to start search from.\r\n     * @returns Next nearest power of two.\r\n     */\r\n    public static NearestPOT: (x: number) => number = NearestPOT;\r\n\r\n    /**\r\n     * Get the closest exponent of two\r\n     * @param value defines the value to approximate\r\n     * @param max defines the maximum value to return\r\n     * @param mode defines how to define the closest value\r\n     * @returns closest exponent of two of the given value\r\n     */\r\n    public static GetExponentOfTwo: (value: number, max: number, mode: number) => number = GetExponentOfTwo;\r\n\r\n    /**\r\n     * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)\r\n     * @param func - the function to be called\r\n     * @param requester - the object that will request the next frame. Falls back to window.\r\n     * @returns frame number\r\n     */\r\n    public static QueueNewFrame: (func: () => void, requester?: any) => number = QueueNewFrame;\r\n}\r\n\r\ninterface TexImageParameters {\r\n    internalFormat: number;\r\n    format: number;\r\n    type: number;\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\n/**\r\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\r\n * @param type type of the texture\r\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\r\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\r\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\r\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\r\n */\r\nexport function allocateAndCopyTypedBuffer(type: number, sizeOrDstBuffer: number | ArrayBuffer, sizeInBytes = false, copyBuffer?: ArrayBuffer): ArrayBufferView {\r\n    switch (type) {\r\n        case Constants.TEXTURETYPE_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_SHORT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n        case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_INT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_24_8:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n        case Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Float32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n    if (copyBuffer) {\r\n        buffer.set(new Uint8Array(copyBuffer));\r\n    }\r\n    return buffer;\r\n}\r\n\r\nThinEngine.prototype._readTexturePixelsSync = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): ArrayBufferView {\r\n    const gl = this._gl;\r\n    if (!gl) {\r\n        throw new Error(\"Engine does not have gl rendering context.\");\r\n    }\r\n    if (!this._dummyFramebuffer) {\r\n        const dummy = gl.createFramebuffer();\r\n\r\n        if (!dummy) {\r\n            throw new Error(\"Unable to create dummy framebuffer\");\r\n        }\r\n\r\n        this._dummyFramebuffer = dummy;\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\r\n\r\n    if (faceIndex > -1) {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._hardwareTexture?.underlyingResource, level);\r\n    } else {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture?.underlyingResource, level);\r\n    }\r\n\r\n    let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\r\n\r\n    if (!noDataConversion) {\r\n        switch (readType) {\r\n            case gl.UNSIGNED_BYTE:\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(4 * width * height);\r\n                }\r\n                readType = gl.UNSIGNED_BYTE;\r\n                break;\r\n            default:\r\n                if (!buffer) {\r\n                    buffer = new Float32Array(4 * width * height);\r\n                }\r\n                readType = gl.FLOAT;\r\n                break;\r\n        }\r\n    } else if (!buffer) {\r\n        buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);\r\n    }\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    gl.readPixels(x, y, width, height, gl.RGBA, readType, <DataView>buffer);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);\r\n\r\n    return buffer;\r\n};\r\n\r\nThinEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));\r\n};\r\n", "import { serialize, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\nimport \"../../Engines/Extensions/engine.readTexture\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public override set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public override get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public override set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public override set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public override anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public override toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | AbstractEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<AbstractEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(_fromContextLost = false): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | AbstractEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { Vector3, Matrix } from \"./math.vector\";\r\nimport type { IPlaneLike } from \"./math.like\";\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane implements IPlaneLike {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\r\n        let magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        const x = this.normal.x;\r\n        const y = this.normal.y;\r\n        const z = this.normal.z;\r\n        const d = this.d;\r\n\r\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to construct the plane\r\n     * @param point2 one of the points used to construct the plane\r\n     * @param point3 one of the points used to construct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const x1 = point2.x - point1.x;\r\n        const y1 = point2.y - point1.y;\r\n        const z1 = point2.z - point1.z;\r\n        const x2 = point3.x - point1.x;\r\n        const y2 = point3.y - point1.y;\r\n        const z2 = point3.z - point1.z;\r\n        const yz = y1 * z2 - z1 * y2;\r\n        const xz = z1 * x2 - x1 * z2;\r\n        const xy = x1 * y2 - y1 * x2;\r\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\r\n        let invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        } else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        const dot = Vector3.Dot(this.normal, direction);\r\n        return dot <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        const plane = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        return this.FromPositionAndNormalToRef(origin, normal, plane);\r\n    }\r\n\r\n    /**\r\n     * Updates the given Plane \"result\" from an origin point and a normal.\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal the normalized normals of the plane to be constructed\r\n     * @param result defines the Plane where to store the result\r\n     * @returns result input\r\n     */\r\n    static FromPositionAndNormalToRef<T extends Plane>(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, result: T): T {\r\n        result.normal.copyFrom(normal);\r\n        result.normal.normalize();\r\n        result.d = -origin.dot(result.normal);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n", "/**\r\n * Options used to control default behaviors regarding compatibility support\r\n */\r\nexport class CompatibilityOptions {\r\n    /**\r\n     * Defines if the system should use OpenGL convention for UVs when creating geometry or loading .babylon files (false by default)\r\n     */\r\n    public static UseOpenGLOrientationForUV = false;\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { InstantiationTools } from \"../../Misc/instantiationTools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { EncodeArrayBufferToBase64 } from \"../../Misc/stringTools\";\r\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport type { MirrorTexture } from \"../../Materials/Textures/mirrorTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { VideoTexture, VideoTextureSettings } from \"./videoTexture\";\r\n\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Defines the available options when creating a texture\r\n */\r\nexport interface ITextureCreationOptions {\r\n    /** Defines if the texture will require mip maps or not (default: false) */\r\n    noMipmap?: boolean;\r\n\r\n    /** Defines if the texture needs to be inverted on the y axis during loading (default: true) */\r\n    invertY?: boolean;\r\n\r\n    /** Defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...) (default: Texture.TRILINEAR_SAMPLINGMODE) */\r\n    samplingMode?: number;\r\n\r\n    /** Defines a callback triggered when the texture has been loaded (default: null) */\r\n    onLoad?: Nullable<() => void>;\r\n\r\n    /** Defines a callback triggered when an error occurred during the loading session (default: null) */\r\n    onError?: Nullable<(message?: string, exception?: any) => void>;\r\n\r\n    /** Defines the buffer to load the texture from in case the texture is loaded from a buffer representation (default: null) */\r\n    buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;\r\n\r\n    /** Defines if the buffer we are loading the texture from should be deleted after load (default: false) */\r\n    deleteBuffer?: boolean;\r\n\r\n    /** Defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...) (default: ) */\r\n    format?: number;\r\n\r\n    /** Defines an optional mime type information (default: undefined) */\r\n    mimeType?: string;\r\n\r\n    /** Options to be passed to the loader (default: undefined) */\r\n    loaderOptions?: any;\r\n\r\n    /** Specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg) (default: undefined) */\r\n    creationFlags?: number;\r\n\r\n    /** Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture from an already existing one */\r\n    internalTexture?: InternalTexture;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    public static ForceSerializeBuffers = false;\r\n\r\n    /**\r\n     * This observable will notify when any texture had a loading error\r\n     */\r\n    public static OnTextureLoadErrorObservable = new Observable<BaseTexture>();\r\n\r\n    /** @internal */\r\n    public static _SerializeInternalTextureUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _WarnImport(\"CubeTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _WarnImport(\"MirrorTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number): RenderTargetTexture => {\r\n        throw _WarnImport(\"RenderTargetTexture\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateVideoTexture(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ): VideoTexture {\r\n        throw _WarnImport(\"VideoTexture\");\r\n    }\r\n\r\n    /** nearest is mag = nearest and min = nearest and no mip */\r\n    public static readonly NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and no mip */\r\n    public static readonly BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n     */\r\n    @serialize()\r\n    public homogeneousRotationInUVTransform = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    /** @internal */\r\n    public _noMipmap: boolean = false;\r\n    /** @internal */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedReflectionProjectionMatrixId: number = -1;\r\n    private _cachedURotationCenter: number = -1;\r\n    private _cachedVRotationCenter: number = -1;\r\n    private _cachedWRotationCenter: number = -1;\r\n    private _cachedHomogeneousRotationInUVTransform: boolean = false;\r\n    private _cachedIdentity3x2: boolean = true;\r\n\r\n    private _cachedReflectionTextureMatrix: Nullable<Matrix> = null;\r\n    private _cachedReflectionUOffset = -1;\r\n    private _cachedReflectionVOffset = -1;\r\n    private _cachedReflectionUScale = 0;\r\n    private _cachedReflectionVScale = 0;\r\n    private _cachedReflectionCoordinatesMode = -1;\r\n\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n    private _loaderOptions?: any;\r\n    private _creationFlags?: number;\r\n    /** @internal */\r\n    public _useSRGBBuffer?: boolean;\r\n    private _forcedExtension?: string;\r\n\r\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n    public get mimeType() {\r\n        return this._mimeType;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public override set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public override get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    constructor(\r\n        url: Nullable<string>,\r\n        sceneOrEngine?: Nullable<Scene | AbstractEngine>,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        deleteBuffer: boolean = false,\r\n        format?: number,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n\r\n        let noMipmap: boolean;\r\n        let useSRGBBuffer: boolean = false;\r\n        let internalTexture: Nullable<InternalTexture> = null;\r\n        let gammaSpace = true;\r\n\r\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\r\n            noMipmap = noMipmapOrOptions.noMipmap ?? false;\r\n            invertY = noMipmapOrOptions.invertY ?? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true);\r\n            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            onLoad = noMipmapOrOptions.onLoad ?? null;\r\n            onError = noMipmapOrOptions.onError ?? null;\r\n            buffer = noMipmapOrOptions.buffer ?? null;\r\n            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;\r\n            format = noMipmapOrOptions.format;\r\n            mimeType = noMipmapOrOptions.mimeType;\r\n            loaderOptions = noMipmapOrOptions.loaderOptions;\r\n            creationFlags = noMipmapOrOptions.creationFlags;\r\n            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;\r\n            internalTexture = noMipmapOrOptions.internalTexture ?? null;\r\n            gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;\r\n        } else {\r\n            noMipmap = !!noMipmapOrOptions;\r\n        }\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY === undefined ? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true) : invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        this._loaderOptions = loaderOptions;\r\n        this._creationFlags = creationFlags;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._forcedExtension = forcedExtension;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        const load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texture to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this.url && !internalTexture) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = errorHandler;\r\n            return;\r\n        }\r\n\r\n        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                try {\r\n                    this._texture = engine.createTexture(\r\n                        this.url,\r\n                        noMipmap,\r\n                        this._invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        load,\r\n                        errorHandler,\r\n                        this._buffer,\r\n                        undefined,\r\n                        this._format,\r\n                        this._forcedExtension,\r\n                        mimeType,\r\n                        loaderOptions,\r\n                        creationFlags,\r\n                        useSRGBBuffer\r\n                    );\r\n                } catch (e) {\r\n                    errorHandler(\"error loading\", e);\r\n                    throw e;\r\n                }\r\n                if (deleteBuffer) {\r\n                    this._buffer = null;\r\n                }\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = errorHandler;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                const loadObserver = this._texture.onLoadedObservable.add(load);\r\n                this._texture.onErrorObservable.add((e) => {\r\n                    errorHandler(e.message, e.exception);\r\n                    this._texture?.onLoadedObservable.remove(loadObserver);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        onLoad?: () => void,\r\n        forcedExtension?: string\r\n    ): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this._forcedExtension = forcedExtension;\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @internal\r\n     */\r\n    public override delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene\r\n                .getEngine()\r\n                .createTexture(\r\n                    this.url,\r\n                    this._noMipmap,\r\n                    this._invertY,\r\n                    scene,\r\n                    this.samplingMode,\r\n                    this._delayedOnLoad,\r\n                    this._delayedOnError,\r\n                    this._buffer,\r\n                    null,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._mimeType,\r\n                    this._loaderOptions,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @param uBase The horizontal base offset multiplier (1 by default)\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public override getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform\r\n        ) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix!, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        } else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n            this._t1!.subtractInPlace(this._t0!);\r\n            this._t2!.subtractInPlace(this._t0!);\r\n\r\n            Matrix.FromValuesToRef(\r\n                this._t1!.x,\r\n                this._t1!.y,\r\n                this._t1!.z,\r\n                0.0,\r\n                this._t2!.x,\r\n                this._t2!.y,\r\n                this._t2!.z,\r\n                0.0,\r\n                this._t0!.x,\r\n                this._t0!.y,\r\n                this._t0!.z,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                this._cachedTextureMatrix\r\n            );\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        const previousIdentity3x2 = this._cachedIdentity3x2;\r\n        this._cachedIdentity3x2 = this._cachedTextureMatrix.isIdentityAs3x2();\r\n\r\n        if (this.optimizeUVAllocation && previousIdentity3x2 !== this._cachedIdentity3x2) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\r\n            // will get different values (see PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedReflectionTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedReflectionUOffset &&\r\n            this.vOffset === this._cachedReflectionVOffset &&\r\n            this.uScale === this._cachedReflectionUScale &&\r\n            this.vScale === this._cachedReflectionVScale &&\r\n            this.coordinatesMode === this._cachedReflectionCoordinatesMode\r\n        ) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedReflectionTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedReflectionTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedReflectionTextureMatrix) {\r\n            this._cachedReflectionTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;\r\n\r\n        this._cachedReflectionUOffset = this.uOffset;\r\n        this._cachedReflectionVOffset = this.vOffset;\r\n        this._cachedReflectionUScale = this.uScale;\r\n        this._cachedReflectionVScale = this.vScale;\r\n        this._cachedReflectionCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE: {\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                (<any>this._cachedReflectionTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedReflectionTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            }\r\n            case Texture.PROJECTION_MODE: {\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n\r\n                const projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);\r\n                break;\r\n            }\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        if (flagMaterialsAsTextureDirty) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\r\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedReflectionTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        const options: ITextureCreationOptions = {\r\n            noMipmap: this._noMipmap,\r\n            invertY: this._invertY,\r\n            samplingMode: this.samplingMode,\r\n            onLoad: undefined,\r\n            onError: undefined,\r\n            buffer: this._texture ? this._texture._buffer : undefined,\r\n            deleteBuffer: this._deleteBuffer,\r\n            format: this.textureFormat,\r\n            mimeType: this.mimeType,\r\n            loaderOptions: this._loaderOptions,\r\n            creationFlags: this._creationFlags,\r\n            useSRGBBuffer: this._useSRGBBuffer,\r\n        };\r\n\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public override serialize(): any {\r\n        const savedName = this.name;\r\n\r\n        if (!Texture.SerializeBuffers) {\r\n            if (this.name.startsWith(\"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        if (this.name.startsWith(\"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n\r\n        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && this.url.startsWith(\"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\r\n            } else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith(\"blob:\")) || this._forceSerialize) {\r\n                serializationObject.base64String =\r\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        serializationObject._creationFlags = this._creationFlags;\r\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\r\n        if (Texture._SerializeInternalTextureUniqueId) {\r\n            serializationObject.internalTextureUniqueId = this._texture?.uniqueId ?? undefined;\r\n        }\r\n        serializationObject.noMipmap = this._noMipmap;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n        this._buffer = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            const parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {\r\n            return null;\r\n        }\r\n\r\n        let internalTexture: InternalTexture | undefined;\r\n\r\n        if (hasInternalTextureUniqueId) {\r\n            const cache = scene.getEngine().getLoadedTexturesCache();\r\n            for (const texture of cache) {\r\n                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {\r\n                    internalTexture = texture;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const onLoaded = (texture: Texture | null) => {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                const sampling: number = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    const internalClass = GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (hasInternalTextureUniqueId && !internalTexture) {\r\n                texture?._texture?._setUniqueId(parsedTexture.internalTextureUniqueId);\r\n            }\r\n        };\r\n\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let generateMipMaps: boolean = true;\r\n                if (parsedTexture.noMipmap) {\r\n                    generateMipMaps = false;\r\n                }\r\n                if (parsedTexture.mirrorPlane) {\r\n                    const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                    mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                    onLoaded(mirrorTexture);\r\n                    return mirrorTexture;\r\n                } else if (parsedTexture.isRenderTarget) {\r\n                    let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                    if (parsedTexture.isCube) {\r\n                        // Search for an existing reflection probe (which contains a cube render target texture)\r\n                        if (scene.reflectionProbes) {\r\n                            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                                const probe = scene.reflectionProbes[index];\r\n                                if (probe.name === parsedTexture.name) {\r\n                                    return probe.cubeTexture;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        renderTargetTexture = Texture._CreateRenderTargetTexture(\r\n                            parsedTexture.name,\r\n                            parsedTexture.renderTargetSize,\r\n                            scene,\r\n                            generateMipMaps,\r\n                            parsedTexture._creationFlags ?? 0\r\n                        );\r\n                        renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                    }\r\n                    onLoaded(renderTargetTexture);\r\n                    return renderTargetTexture;\r\n                } else if (parsedTexture.isVideo) {\r\n                    const texture = Texture._CreateVideoTexture(\r\n                        rootUrl + (parsedTexture.url || parsedTexture.name),\r\n                        rootUrl + (parsedTexture.src || parsedTexture.url),\r\n                        scene,\r\n                        generateMipMaps,\r\n                        parsedTexture.invertY,\r\n                        parsedTexture.samplingMode,\r\n                        parsedTexture.settings || {}\r\n                    );\r\n                    onLoaded(texture);\r\n                    return texture;\r\n                } else {\r\n                    let texture: Texture;\r\n\r\n                    if (parsedTexture.base64String && !internalTexture) {\r\n                        // name and url are the same to ensure caching happens from the actual base64 string\r\n                        texture = Texture.CreateFromBase64String(\r\n                            parsedTexture.base64String,\r\n                            parsedTexture.base64String,\r\n                            scene,\r\n                            !generateMipMaps,\r\n                            parsedTexture.invertY,\r\n                            parsedTexture.samplingMode,\r\n                            () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            parsedTexture._creationFlags ?? 0,\r\n                            parsedTexture._useSRGBBuffer ?? false\r\n                        );\r\n\r\n                        // prettier name to fit with the loaded data\r\n                        texture.name = parsedTexture.name;\r\n                    } else {\r\n                        let url: string;\r\n                        if (parsedTexture.name && (parsedTexture.name.indexOf(\"://\") > 0 || parsedTexture.name.startsWith(\"data:\"))) {\r\n                            url = parsedTexture.name;\r\n                        } else {\r\n                            url = rootUrl + parsedTexture.name;\r\n                        }\r\n\r\n                        if (parsedTexture.url && (parsedTexture.url.startsWith(\"data:\") || Texture.UseSerializedUrlIfAny)) {\r\n                            url = parsedTexture.url;\r\n                        }\r\n\r\n                        const options: ITextureCreationOptions = {\r\n                            noMipmap: !generateMipMaps,\r\n                            invertY: parsedTexture.invertY,\r\n                            samplingMode: parsedTexture.samplingMode,\r\n                            onLoad: () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            internalTexture,\r\n                        };\r\n\r\n                        texture = new Texture(url, scene, options);\r\n                    }\r\n\r\n                    return texture;\r\n                }\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(\r\n        data: string,\r\n        name: string,\r\n        scene: Scene,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<() => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        return new Texture(\r\n            \"data:\" + name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            data,\r\n            false,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(\r\n        name: string,\r\n        buffer: any,\r\n        scene: Scene,\r\n        deleteBuffer: boolean = false,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY: boolean = true,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ): Texture {\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(\r\n            name,\r\n            scene,\r\n            noMipmapOrOptions,\r\n            invertY,\r\n            samplingMode,\r\n            onLoad,\r\n            onError,\r\n            buffer,\r\n            deleteBuffer,\r\n            format,\r\n            undefined,\r\n            undefined,\r\n            creationFlags,\r\n            forcedExtension\r\n        );\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nRegisterClass(\"BABYLON.Texture\", Texture);\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n", "import { PrecisionDate } from \"./precisionDate\";\r\n\r\n/**\r\n * This class is used to track a performance counter which is number based.\r\n * The user has access to many properties which give statistics of different nature.\r\n *\r\n * The implementer can track two kinds of Performance Counter: time and count.\r\n * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.\r\n * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.\r\n */\r\nexport class PerfCounter {\r\n    /**\r\n     * Gets or sets a global boolean to turn on and off all the counters\r\n     */\r\n    public static Enabled = true;\r\n\r\n    /**\r\n     * Returns the smallest value ever\r\n     */\r\n    public get min(): number {\r\n        return this._min;\r\n    }\r\n\r\n    /**\r\n     * Returns the biggest value ever\r\n     */\r\n    public get max(): number {\r\n        return this._max;\r\n    }\r\n\r\n    /**\r\n     * Returns the average value since the performance counter is running\r\n     */\r\n    public get average(): number {\r\n        return this._average;\r\n    }\r\n\r\n    /**\r\n     * Returns the average value of the last second the counter was monitored\r\n     */\r\n    public get lastSecAverage(): number {\r\n        return this._lastSecAverage;\r\n    }\r\n\r\n    /**\r\n     * Returns the current value\r\n     */\r\n    public get current(): number {\r\n        return this._current;\r\n    }\r\n\r\n    /**\r\n     * Gets the accumulated total\r\n     */\r\n    public get total(): number {\r\n        return this._totalAccumulated;\r\n    }\r\n\r\n    /**\r\n     * Gets the total value count\r\n     */\r\n    public get count(): number {\r\n        return this._totalValueCount;\r\n    }\r\n\r\n    /**\r\n     * Creates a new counter\r\n     */\r\n    constructor() {\r\n        this._startMonitoringTime = 0;\r\n        this._min = 0;\r\n        this._max = 0;\r\n        this._average = 0;\r\n        this._lastSecAverage = 0;\r\n        this._current = 0;\r\n        this._totalValueCount = 0;\r\n        this._totalAccumulated = 0;\r\n        this._lastSecAccumulated = 0;\r\n        this._lastSecTime = 0;\r\n        this._lastSecValueCount = 0;\r\n    }\r\n\r\n    /**\r\n     * Call this method to start monitoring a new frame.\r\n     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\r\n     */\r\n    public fetchNewFrame() {\r\n        this._totalValueCount++;\r\n        this._current = 0;\r\n        this._lastSecValueCount++;\r\n    }\r\n\r\n    /**\r\n     * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)\r\n     * @param newCount the count value to add to the monitored count\r\n     * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.\r\n     */\r\n    public addCount(newCount: number, fetchResult: boolean) {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n        this._current += newCount;\r\n        if (fetchResult) {\r\n            this._fetchResult();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start monitoring this performance counter\r\n     */\r\n    public beginMonitoring() {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n        this._startMonitoringTime = PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Compute the time lapsed since the previous beginMonitoring() call.\r\n     * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter\r\n     */\r\n    public endMonitoring(newFrame: boolean = true) {\r\n        if (!PerfCounter.Enabled) {\r\n            return;\r\n        }\r\n\r\n        if (newFrame) {\r\n            this.fetchNewFrame();\r\n        }\r\n\r\n        const currentTime = PrecisionDate.Now;\r\n        this._current = currentTime - this._startMonitoringTime;\r\n\r\n        if (newFrame) {\r\n            this._fetchResult();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call this method to end the monitoring of a frame.\r\n     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the end of the frame, after beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\r\n     */\r\n    public endFrame() {\r\n        this._fetchResult();\r\n    }\r\n\r\n    /** @internal */\r\n    public _fetchResult() {\r\n        this._totalAccumulated += this._current;\r\n        this._lastSecAccumulated += this._current;\r\n\r\n        // Min/Max update\r\n        this._min = Math.min(this._min, this._current);\r\n        this._max = Math.max(this._max, this._current);\r\n        this._average = this._totalAccumulated / this._totalValueCount;\r\n\r\n        // Reset last sec?\r\n        const now = PrecisionDate.Now;\r\n        if (now - this._lastSecTime > 1000) {\r\n            this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;\r\n            this._lastSecTime = now;\r\n            this._lastSecAccumulated = 0;\r\n            this._lastSecValueCount = 0;\r\n        }\r\n    }\r\n\r\n    private _startMonitoringTime: number;\r\n    private _min: number;\r\n    private _max: number;\r\n    private _average: number;\r\n    private _current: number;\r\n    private _totalValueCount: number;\r\n    private _totalAccumulated: number;\r\n    private _lastSecAverage: number;\r\n    private _lastSecAccumulated: number;\r\n    private _lastSecTime: number;\r\n    private _lastSecValueCount: number;\r\n}\r\n", "import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport { WebGLDataBuffer } from \"../../Meshes/WebGL/webGLDataBuffer\";\r\nimport type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { WebGLPipelineContext } from \"../WebGL/webGLPipelineContext\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create an uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @param label defines a name for the buffer (for debugging purpose)\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n        /**\r\n         * Create a dynamic uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @param label defines a name for the buffer (for debugging purpose)\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createDynamicUniformBuffer(elements: FloatArray, label?: string): DataBuffer;\r\n\r\n        /**\r\n         * Update an existing uniform buffer\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\r\n         * @param uniformBuffer defines the target uniform buffer\r\n         * @param elements defines the content to update\r\n         * @param offset defines the offset in the uniform buffer where update should start\r\n         * @param count defines the size of the data to update\r\n         */\r\n        updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n        /**\r\n         * Bind an uniform buffer to the current webGL context\r\n         * @param buffer defines the buffer to bind\r\n         */\r\n        bindUniformBuffer(buffer: Nullable<DataBuffer>): void;\r\n\r\n        /**\r\n         * Bind a buffer to the current webGL context at a given location\r\n         * @param buffer defines the buffer to bind\r\n         * @param location defines the index where to bind the buffer\r\n         * @param name Name of the uniform variable to bind\r\n         */\r\n        bindUniformBufferBase(buffer: DataBuffer, location: number, name: string): void;\r\n\r\n        /**\r\n         * Bind a specific block at a given index in a specific shader program\r\n         * @param pipelineContext defines the pipeline context to use\r\n         * @param blockName defines the block name\r\n         * @param index defines the index where to bind the block\r\n         */\r\n        bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createUniformBuffer = function (elements: FloatArray, _label?: string): DataBuffer {\r\n    const ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create uniform buffer\");\r\n    }\r\n    const result = new WebGLDataBuffer(ubo);\r\n\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.STATIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.STATIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.createDynamicUniformBuffer = function (elements: FloatArray, _label?: string): DataBuffer {\r\n    const ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create dynamic uniform buffer\");\r\n    }\r\n\r\n    const result = new WebGLDataBuffer(ubo);\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.DYNAMIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.DYNAMIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.updateUniformBuffer = function (uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void {\r\n    this.bindUniformBuffer(uniformBuffer);\r\n\r\n    if (offset === undefined) {\r\n        offset = 0;\r\n    }\r\n\r\n    if (count === undefined) {\r\n        if (elements instanceof Float32Array) {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, <Float32Array>elements);\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(<number[]>elements));\r\n        }\r\n    } else {\r\n        if (elements instanceof Float32Array) {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, <Float32Array>elements.subarray(offset, offset + count));\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(<number[]>elements).subarray(offset, offset + count));\r\n        }\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBuffer = function (buffer: Nullable<DataBuffer>): void {\r\n    this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nThinEngine.prototype.bindUniformBufferBase = function (buffer: DataBuffer, location: number, name: string): void {\r\n    this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBlock = function (pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n    const program = (pipelineContext as WebGLPipelineContext).program!;\r\n\r\n    const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\r\n\r\n    if (uniformLocation !== 0xffffffff) {\r\n        this._gl.uniformBlockBinding(program, uniformLocation, index);\r\n    }\r\n};\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from \"../Maths/math.like\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { InternalTexture } from \"./Textures/internalTexture\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport \"../Engines/Extensions/engine.uniformBuffer\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    /** @internal */\r\n    public static _UpdatedUbosInFrame: { [name: string]: number } = {};\r\n\r\n    private _engine: AbstractEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _buffers: Array<[DataBuffer, Float32Array | undefined]>;\r\n    private _bufferIndex: number;\r\n    private _createBufferOnWrite: boolean;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic?: boolean;\r\n    private _uniformLocations: { [key: string]: number };\r\n    private _uniformSizes: { [key: string]: number };\r\n    private _uniformArraySizes: { [key: string]: { strideSize: number; arraySize: number } };\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n    private _currentEffectName: string;\r\n    private _name: string;\r\n    private _currentFrameId: number;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n    private static _TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\r\n    private static _TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloatArray: (name: string, array: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateArray: (name: string, array: number[]) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateIntArray: (name: string, array: Int32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of number in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUIntArray: (name: string, array: Uint32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: IMatrixLike) => void;\r\n\r\n    /**\r\n     * Lambda to Update an array of 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrices: (name: string, mat: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: IVector3Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: IVector4Like) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: IColor3Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: IColor3Like, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateDirectColor4: (name: string, color: IColor4Like, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a unsigned int a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt: (name: string, x: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of unsigned int in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateUInt4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     * @param name to assign to the buffer (debugging purpose)\r\n     * @param forceNoUniformBuffer define that this object must not rely on UBO objects\r\n     */\r\n    constructor(engine: AbstractEngine, data?: number[], dynamic?: boolean, name?: string, forceNoUniformBuffer = false) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\r\n        this._dynamic = dynamic;\r\n        this._name = name ?? \"no-name\";\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformArraySizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._bufferIndex = -1;\r\n            this._createBufferOnWrite = false;\r\n            this._currentFrameId = 0;\r\n        }\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateFloatArray = this._updateFloatArrayForEffect;\r\n            this.updateArray = this._updateArrayForEffect;\r\n            this.updateIntArray = this._updateIntArrayForEffect;\r\n            this.updateUIntArray = this._updateUIntArrayForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateMatrices = this._updateMatricesForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForEffect;\r\n            this.updateInt = this._updateIntForEffect;\r\n            this.updateInt2 = this._updateInt2ForEffect;\r\n            this.updateInt3 = this._updateInt3ForEffect;\r\n            this.updateInt4 = this._updateInt4ForEffect;\r\n            this.updateUInt = this._updateUIntForEffect;\r\n            this.updateUInt2 = this._updateUInt2ForEffect;\r\n            this.updateUInt3 = this._updateUInt3ForEffect;\r\n            this.updateUInt4 = this._updateUInt4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateFloatArray = this._updateFloatArrayForUniform;\r\n            this.updateArray = this._updateArrayForUniform;\r\n            this.updateIntArray = this._updateIntArrayForUniform;\r\n            this.updateUIntArray = this._updateUIntArrayForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateMatrices = this._updateMatricesForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n            this.updateDirectColor4 = this._updateDirectColor4ForUniform;\r\n            this.updateInt = this._updateIntForUniform;\r\n            this.updateInt2 = this._updateInt2ForUniform;\r\n            this.updateInt3 = this._updateInt3ForUniform;\r\n            this.updateInt4 = this._updateInt4ForUniform;\r\n            this.updateUInt = this._updateUIntForUniform;\r\n            this.updateUInt2 = this._updateUInt2ForUniform;\r\n            this.updateUInt3 = this._updateUInt3ForUniform;\r\n            this.updateUInt4 = this._updateUInt4ForUniform;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     * @param size\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        let alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if (this._uniformLocationPointer % alignment !== 0) {\r\n            const oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            const diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (let i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\r\n     * meaning size=1,2,3,4 or 16. It does not handle struct types.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     * @param arraySize The number of elements in the array, 0 if not an array.\r\n     */\r\n    public addUniform(name: string, size: number | number[], arraySize = 0) {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        let data;\r\n\r\n        // std140 FTW...\r\n        if (arraySize > 0) {\r\n            if (size instanceof Array) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"addUniform should not be use with Array in UBO: \" + name;\r\n            }\r\n\r\n            this._fillAlignment(4);\r\n\r\n            this._uniformArraySizes[name] = { strideSize: size, arraySize };\r\n            if (size == 16) {\r\n                size = size * arraySize;\r\n            } else {\r\n                const perElementPadding = 4 - size;\r\n                const totalPadding = perElementPadding * arraySize;\r\n                size = size * arraySize + totalPadding;\r\n            }\r\n\r\n            data = [];\r\n            // Fill with zeros\r\n            for (let i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        } else {\r\n            if (size instanceof Array) {\r\n                data = size;\r\n                size = data.length;\r\n            } else {\r\n                size = <number>size;\r\n                data = [];\r\n\r\n                // Fill with zeros\r\n                for (let i = 0; i < size; i++) {\r\n                    data.push(0);\r\n                }\r\n            }\r\n            this._fillAlignment(<number>size);\r\n        }\r\n\r\n        this._uniformSizes[name] = <number>size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += <number>size;\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: IMatrixLike) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.asArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        const temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        const temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: IColor3Like) {\r\n        const temp = [color.r, color.g, color.b];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: IColor3Like, alpha: number) {\r\n        const temp = [color.r, color.g, color.b, alpha];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: IVector3Like) {\r\n        const temp = [vector.x, vector.y, vector.z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    // The result of this method is used for debugging purpose, as part of the buffer name\r\n    // It is meant to more easily know what this buffer is about when debugging\r\n    // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them\r\n    // (should be enough to understand what the buffer is for)\r\n    private _getNames() {\r\n        const names = [];\r\n        let i = 0;\r\n        for (const name in this._uniformLocations) {\r\n            names.push(name);\r\n            if (++i === 10) {\r\n                break;\r\n            }\r\n        }\r\n        return names.join(\",\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\r\n            this._bufferIndex = this._buffers.length - 1;\r\n            this._createBufferOnWrite = false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuildAfterContextLost(): void {\r\n        if (this._engine._features.trackUbosInFrame) {\r\n            this._buffers = [];\r\n            this._currentFrameId = 0;\r\n        }\r\n        this._rebuild();\r\n    }\r\n\r\n    /** @internal */\r\n    public get _numBuffers(): number {\r\n        return this._buffers.length;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _indexBuffer(): number {\r\n        return this._bufferIndex;\r\n    }\r\n\r\n    /** Gets the name of this buffer */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the current effect */\r\n    public get currentEffect(): Nullable<Effect> {\r\n        return this._currentEffect;\r\n    }\r\n\r\n    private _buffersEqual(buf1: Float32Array, buf2: Float32Array): boolean {\r\n        for (let i = 0; i < buf1.length; ++i) {\r\n            if (buf1[i] !== buf2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _copyBuffer(src: Float32Array, dst: Float32Array): void {\r\n        for (let i = 0; i < src.length; ++i) {\r\n            dst[i] = src[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        this.bindUniformBuffer();\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n            return;\r\n        }\r\n\r\n        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\r\n            if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]!)) {\r\n                this._needSync = false;\r\n                this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n                return;\r\n            } else {\r\n                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]!);\r\n            }\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        if (this._engine._features._collectUbosUpdatedInFrame) {\r\n            if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\r\n                UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\r\n            }\r\n            UniformBuffer._UpdatedUbosInFrame[this._name]++;\r\n        }\r\n\r\n        this._needSync = false;\r\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\r\n    }\r\n\r\n    private _createNewBuffer() {\r\n        if (this._bufferIndex + 1 < this._buffers.length) {\r\n            this._bufferIndex++;\r\n            this._buffer = this._buffers[this._bufferIndex][0];\r\n            this._createBufferOnWrite = false;\r\n            this._needSync = true;\r\n        } else {\r\n            this._rebuild();\r\n        }\r\n    }\r\n\r\n    private _checkNewFrame(): void {\r\n        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\r\n            this._currentFrameId = this._engine.frameId;\r\n            this._createBufferOnWrite = false;\r\n            if (this._buffers && this._buffers.length > 0) {\r\n                this._needSync = this._bufferIndex !== 0;\r\n                this._bufferIndex = 0;\r\n                this._buffer = this._buffers[this._bufferIndex][0];\r\n            } else {\r\n                this._bufferIndex = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        let location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created. uniformName=\" + uniformName);\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n\r\n            for (let i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if ((size === 16 && !this._engine._features.uniformBufferHardCheckMatrix) || this._bufferData[location + i] !== Math.fround(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniformArray(uniformName: string, data: FloatArray, size: number) {\r\n        this._checkNewFrame();\r\n\r\n        const location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        const arraySizes = this._uniformArraySizes[uniformName];\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            let changed = false;\r\n            let countToFour = 0;\r\n            let baseStride = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\r\n                    changed = true;\r\n                    if (this._createBufferOnWrite) {\r\n                        this._createNewBuffer();\r\n                    }\r\n                    this._bufferData[location + baseStride * 4 + countToFour] = data[i];\r\n                }\r\n                countToFour++;\r\n                if (countToFour === arraySizes.strideSize) {\r\n                    for (; countToFour < 4; countToFour++) {\r\n                        this._bufferData[location + baseStride * 4 + countToFour] = 0;\r\n                    }\r\n                    countToFour = 0;\r\n                    baseStride++;\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (let i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: number } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        this._checkNewFrame();\r\n\r\n        const cache = this._valueCache[name];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 3; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (let i = 0; i < 2; i++) {\r\n            UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number) {\r\n        this._currentEffect.setFloat(name, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBuffer[0] = x;\r\n        UniformBuffer._TempBuffer[1] = y;\r\n        UniformBuffer._TempBuffer[2] = z;\r\n        UniformBuffer._TempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateFloatArrayForEffect(name: string, array: Float32Array) {\r\n        this._currentEffect.setFloatArray(name, array);\r\n    }\r\n\r\n    private _updateFloatArrayForUniform(name: string, array: Float32Array) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateArrayForEffect(name: string, array: number[]) {\r\n        this._currentEffect.setArray(name, array);\r\n    }\r\n\r\n    private _updateArrayForUniform(name: string, array: number[]) {\r\n        this.updateUniformArray(name, array, array.length);\r\n    }\r\n\r\n    private _updateIntArrayForEffect(name: string, array: Int32Array) {\r\n        this._currentEffect.setIntArray(name, array);\r\n    }\r\n\r\n    private _updateIntArrayForUniform(name: string, array: Int32Array) {\r\n        UniformBuffer._TempBufferInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateUIntArrayForEffect(name: string, array: Uint32Array) {\r\n        this._currentEffect.setUIntArray(name, array);\r\n    }\r\n\r\n    private _updateUIntArrayForUniform(name: string, array: Uint32Array) {\r\n        UniformBuffer._TempBufferUInt32View.set(array);\r\n        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: IMatrixLike) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: IMatrixLike) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.asArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateMatricesForEffect(name: string, mat: Float32Array) {\r\n        this._currentEffect.setMatrices(name, mat);\r\n    }\r\n\r\n    private _updateMatricesForUniform(name: string, mat: Float32Array) {\r\n        this.updateUniform(name, mat, mat.length);\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: IVector3Like) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: IVector3Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: IVector4Like) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: IVector4Like) {\r\n        UniformBuffer._TempBuffer[0] = vector.x;\r\n        UniformBuffer._TempBuffer[1] = vector.y;\r\n        UniformBuffer._TempBuffer[2] = vector.z;\r\n        UniformBuffer._TempBuffer[3] = vector.w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: IColor3Like, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: IColor3Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: IColor3Like, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateDirectColor4ForEffect(name: string, color: IColor4Like, suffix = \"\") {\r\n        this._currentEffect.setDirectColor4(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: IColor3Like, alpha: number) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateDirectColor4ForUniform(name: string, color: IColor4Like) {\r\n        UniformBuffer._TempBuffer[0] = color.r;\r\n        UniformBuffer._TempBuffer[1] = color.g;\r\n        UniformBuffer._TempBuffer[2] = color.b;\r\n        UniformBuffer._TempBuffer[3] = color.a;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferInt32View[0] = x;\r\n        UniformBuffer._TempBufferInt32View[1] = y;\r\n        UniformBuffer._TempBufferInt32View[2] = z;\r\n        UniformBuffer._TempBufferInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    private _updateUIntForEffect(name: string, x: number, suffix = \"\") {\r\n        this._currentEffect.setUInt(name + suffix, x);\r\n    }\r\n\r\n    private _updateUIntForUniform(name: string, x: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 1);\r\n    }\r\n\r\n    private _updateUInt2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setUInt2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateUInt2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 2);\r\n    }\r\n\r\n    private _updateUInt3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setUInt3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateUInt3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 3);\r\n    }\r\n\r\n    private _updateUInt4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setUInt4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateUInt4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._TempBufferUInt32View[0] = x;\r\n        UniformBuffer._TempBufferUInt32View[1] = y;\r\n        UniformBuffer._TempBufferUInt32View[2] = z;\r\n        UniformBuffer._TempBufferUInt32View[3] = w;\r\n        this.updateUniform(name, UniformBuffer._TempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<ThinTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the (internal) texture to set in the sampler\r\n     */\r\n    public bindTexture(name: string, texture: Nullable<InternalTexture>) {\r\n        this._currentEffect._bindTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Associates an effect to this uniform buffer\r\n     * @param effect Define the effect to associate the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n        this._currentEffectName = name;\r\n    }\r\n\r\n    /**\r\n     * Binds the current (GPU) buffer to the effect\r\n     */\r\n    public bindUniformBuffer(): void {\r\n        if (!this._noUBO && this._buffer && this._currentEffect) {\r\n            this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dissociates the current effect from this uniform buffer\r\n     */\r\n    public unbindEffect(): void {\r\n        this._currentEffect = undefined as any;\r\n        this._currentEffectName = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\r\n     * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\r\n     * @param dataBuffer buffer to look for\r\n     * @returns true if the buffer has been found and the class internal state points to it, else false\r\n     */\r\n    public setDataBuffer(dataBuffer: DataBuffer): boolean {\r\n        if (!this._buffers) {\r\n            return this._buffer === dataBuffer;\r\n        }\r\n\r\n        for (let b = 0; b < this._buffers.length; ++b) {\r\n            const buffer = this._buffers[b];\r\n            if (buffer[0] === dataBuffer) {\r\n                this._bufferIndex = b;\r\n                this._buffer = dataBuffer;\r\n                this._createBufferOnWrite = false;\r\n                this._currentEffect = undefined as any;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        const index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (this._engine._features.trackUbosInFrame && this._buffers) {\r\n            for (let i = 0; i < this._buffers.length; ++i) {\r\n                const buffer = this._buffers[i][0];\r\n                this._engine._releaseBuffer(buffer!);\r\n            }\r\n        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index", "match", "createPipelineContext", "_preparePipelineContext", "_executeWhenRenderingStateIsCompiled", "InternalTextureSource", "proxy", "requestAnimationFrame", "cancelAnimationFrame", "url", "DecodeBase64UrlToBinary", "DecodeBase64UrlToString", "FileToolsOptions", "IsBase64DataUrl", "IsFileURL", "LoadFile", "LoadImage", "ReadFile", "RequestFile", "SetCorsBehavior", "className", "className", "quality", "buffer", "index", "texture", "location", "location"]
}
